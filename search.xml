<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树算法习题</title>
      <link href="/2025/08/03/er-cha-shu-suan-fa-xi-ti/"/>
      <url>/2025/08/03/er-cha-shu-suan-fa-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】用「遍历」思维解题-I"><a href="#【练习】用「遍历」思维解题-I" class="headerlink" title="【练习】用「遍历」思维解题 I"></a>【练习】用「遍历」思维解题 I</h1><p>一般来说，如果让你在二叉树的「树枝」上做文章，那么用遍历的思维模式解题是比较自然的想法。</p><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_binary-tree-paths">257. 二叉树的所有路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">257. 二叉树的所有路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>，返回所有从根节点到叶子节点的路径。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶子节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p>&nbsp;<p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/03/12/paths-tree.jpg" style="max-width: 100%; width: 207px; height: 293px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,5]<strong style="font-weight: 600;">输出：</strong>["1-&gt;2-&gt;5","1-&gt;3"]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>["1"]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-paths/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 257. 二叉树的所有路径</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>你让我求所有根节点到叶子节点的路径，那我遍历一遍二叉树肯定可以搞定，遍历到叶子节点的时候想办法把路径生成出来就行了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历一遍二叉树就能出结果了</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 traverse 函数递归时的路径</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 记录所有从根节点到叶子节点的路径</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># root 是叶子节点</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 将这条路径装入 res</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"->"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 递归遍历左右子树</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-paths" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-paths" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-paths/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_sum-root-to-leaf-numbers">129. 求根节点到叶节点数字之和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">129. 求根节点到叶节点数字之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div>给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，树中每个节点都存放有一个<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">9</code><span>&nbsp;</span>之间的数字。<div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;">每条从根节点到叶节点的路径都代表一个数字：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，从根节点到叶节点的路径<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 -&gt; 2 -&gt; 3</code><span>&nbsp;</span>表示数字<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">123</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">计算从根节点到叶节点生成的<span>&nbsp;</span><strong style="font-weight: 600;">所有数字之和</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/num1tree.jpg" style="max-width: 100%; width: 212px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3]<strong style="font-weight: 600;">输出：</strong>25<strong style="font-weight: 600;">解释：</strong>从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1-&gt;2</code> 代表数字 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">12</code>从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1-&gt;3</code> 代表数字 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">13</code>因此，数字总和 = 12 + 13 = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">25</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/num2tree.jpg" style="max-width: 100%; width: 292px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,9,0,5,1]<strong style="font-weight: 600;">输出：</strong>1026<strong style="font-weight: 600;">解释：</strong>从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;9-&gt;5</code> 代表数字 495从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;9-&gt;1</code> 代表数字 491从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;0</code> 代表数字 40因此，数字总和 = 495 + 491 + 40 = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1026</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 129. 求根节点到叶节点数字之和</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>你想，让我获取所有路径数字之和，那我递归遍历一遍二叉树，沿路记录下来路径上的数字，到叶子节点的时候求和，不就完事了？</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token string">""</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历一遍二叉树就能出结果</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置，记录节点值</span>        self<span class="token punctuation">.</span>path <span class="token operator">+=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 到达叶子节点，累加路径和</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">)</span>        <span class="token comment"># 二叉树递归框架，遍历左右子树</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后续遍历位置，撤销节点值</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/3Etpl5">剑指 Offer II 049. 从根节点到叶节点的路径数字之和 🟠</a></li></ul><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_binary-tree-right-side-view">199. 二叉树的右视图</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">199. 二叉树的右视图</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-right-side-view/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">根节点</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/02/14/tree.jpg" style="max-width: 100%; width: 270px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> [1,2,3,null,5,null,4]<strong style="font-weight: 600;">输出:</strong> [1,3,4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> [1,null,3]<strong style="font-weight: 600;">输出:</strong> [1,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> []<strong style="font-weight: 600;">输出:</strong> []</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,100]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 199. 二叉树的右视图</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这题有两个思路：</p><p>1、用 BFS 层序遍历算法，每一层的最后一个节点就是二叉树的右侧视图。我们可以把 BFS 反过来，从右往左遍历每一行，进一步提升效率。</p><p>2、用 DFS 递归遍历算法，同样需要反过来，先递归 <code>root.right</code> 再递归 <code>root.left</code>，同时用 <code>res</code> 记录每一层的最右侧节点作为右侧视图。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># BFS 层序遍历解法</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token comment"># BFS 层序遍历，计算右侧视图</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 每一层头部就是最右侧的元素</span>            last <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 控制每一层从右向左遍历</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token comment"># 每一层的最后一个节点就是二叉树的右侧视图</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>last<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token comment"># DFS 递归遍历解法</span>    <span class="token keyword">def</span> <span class="token function">rightSideView_DFS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 记录递归的层数</span>        self<span class="token punctuation">.</span>depth <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>depth<span class="token punctuation">:</span>            <span class="token comment"># 这一层还没有记录值</span>            <span class="token comment"># 说明 root 就是右侧视图的第一个节点</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 注意，这里反过来，先遍历右子树再遍历左子树</span>        <span class="token comment"># 这样首先遍历的一定是右侧节点</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-right-side-view" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-right-side-view" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-right-side-view/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree">662. 二叉树最大宽度 🟠</a></li><li><a href="https://leetcode.cn/problems/WNC0Lk">剑指 Offer II 046. 二叉树的右侧视图 🟠</a></li></ul><h2 id="988-从叶结点开始的最小字符串"><a href="#988-从叶结点开始的最小字符串" class="headerlink" title="988. 从叶结点开始的最小字符串"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_smallest-string-starting-from-leaf">988. 从叶结点开始的最小字符串</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">988. 从叶结点开始的最小字符串</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一颗根结点为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，树中的每一个结点都有一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 25]</code>&nbsp;范围内的值，分别代表字母&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'a'</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'z'</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回<span>&nbsp;</span><em><strong style="font-weight: 600;">按字典序最小</strong><span>&nbsp;</span>的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束</em>。</p><blockquote style="margin: 1rem 0px; padding-block: 0.25rem; padding-inline: 1rem 0px; border-inline-start: 3px solid rgb(184, 184, 186); color: rgba(60, 60, 67, 0.78); font-size: 1rem; overflow-wrap: break-word; transition: border-color 0.3s, color 0.3s;"><p style="line-height: 1.6; overflow-wrap: break-word; margin: inherit;">注<strong style="font-weight: 600;">：</strong>字符串中任何较短的前缀在<span>&nbsp;</span><strong style="font-weight: 600;">字典序上</strong><span>&nbsp;</span>都是<span>&nbsp;</span><strong style="font-weight: 600;">较小</strong><span>&nbsp;</span>的：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，在字典序上&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"ab"</code><span>&nbsp;</span>比&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"aba"</code>&nbsp;要小。叶结点是指没有子结点的结点。&nbsp;</li></ul></blockquote><p style="line-height: 1.6; overflow-wrap: break-word;">节点的叶节点是没有子节点的节点。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/02/tree1.png" style="max-width: 100%; height: 358px; width: 534px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,1,2,3,4,3,4]<strong style="font-weight: 600;">输出：</strong>"dba"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/01/30/tree2.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [25,1,3,1,3,0,2]<strong style="font-weight: 600;">输出：</strong>"adz"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/02/01/tree3.png" style="max-width: 100%; height: 513px; width: 490px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,2,1,null,1,0,null,0]<strong style="font-weight: 600;">输出：</strong>"abc"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定树的结点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 8500]</code><span>&nbsp;</span>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 25</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 988. 从叶结点开始的最小字符串</a>。</strong></details><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>代码看起来虽然多，但思路非常简单：用 <code>path</code> 维护递归遍历的路径，到达叶子节点的时候判断字典序最小的路径。</p><p>不要忘了在叶子节点的时候也要正确维护 <code>path</code> 变量，而且要把 StringBuilder 中的字符串反转才是题目想要的答案。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">smallestFromLeaf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        <span class="token comment"># 遍历过程中的路径</span>    path <span class="token operator">=</span> <span class="token string">""</span>    res <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 找到叶子结点，比较字典序最小的路径</span>            <span class="token comment"># 结果字符串是从叶子向根，所以需要反转</span>            self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>path            s <span class="token operator">=</span> self<span class="token punctuation">.</span>path            <span class="token keyword">if</span> self<span class="token punctuation">.</span>res <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>res <span class="token operator">></span> s<span class="token punctuation">:</span>                <span class="token comment"># 如果字典序更小，则更新 res</span>                self<span class="token punctuation">.</span>res <span class="token operator">=</span> s            <span class="token comment"># 恢复，正确维护 path 中的元素</span>            self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>path        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_smallest-string-starting-from-leaf" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_smallest-string-starting-from-leaf" src="https://labuladong.online/algo-visualize/leetcode/smallest-string-starting-from-leaf/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1022-从根到叶的二进制数之和"><a href="#1022-从根到叶的二进制数之和" class="headerlink" title="1022. 从根到叶的二进制数之和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_sum-of-root-to-leaf-binary-numbers">1022. 从根到叶的二进制数之和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1022. 从根到叶的二进制数之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出一棵二叉树，其上每个结点的值都是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;或&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，如果路径为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">01101</code>，也就是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">13</code>&nbsp;。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回这些数字之和。题目数据保证答案是一个<span>&nbsp;</span><strong style="font-weight: 600;">32 位<span>&nbsp;</span></strong>整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,1,0,1,0,1]<strong style="font-weight: 600;">输出：</strong>22<strong style="font-weight: 600;">解释：</strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;仅为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1022. 从根到叶的二进制数之和</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>用 <code>path</code> 变量维护每一条从根节点到叶子节点的路径形成的二进制数，到了叶子节点之后将这条路径的二进制数累加到 <code>res</code> 中即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumRootToLeaf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 叶子节点</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> self<span class="token punctuation">.</span>path <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> root<span class="token punctuation">.</span>val            <span class="token keyword">return</span>        <span class="token comment"># 前序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> root<span class="token punctuation">.</span>val        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path <span class="token operator">>></span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_sum-of-root-to-leaf-binary-numbers" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-root-to-leaf-binary-numbers" src="https://labuladong.online/algo-visualize/leetcode/sum-of-root-to-leaf-binary-numbers/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1457-二叉树中的伪回文路径"><a href="#1457-二叉树中的伪回文路径" class="headerlink" title="1457. 二叉树中的伪回文路径"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_pseudo-palindromic-paths-in-a-binary-tree">1457. 二叉树中的伪回文路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1457. 二叉树中的伪回文路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong style="font-weight: 600;">伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回从根到叶子节点的所有路径中&nbsp;<strong style="font-weight: 600;">伪回文&nbsp;</strong>路径的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png" style="max-width: 100%; height: 201px; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,3,1,3,1,null,1]<strong style="font-weight: 600;">输出：</strong>2 <strong style="font-weight: 600;">解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png" style="max-width: 100%; height: 314px; width: 300px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]<strong style="font-weight: 600;">输出：</strong>1 <strong style="font-weight: 600;">解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [9]<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定二叉树的节点数目在范围&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>5</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 9</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1457. 二叉树中的伪回文路径</a>。</strong></details><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>遍历一遍二叉树就能得到每条路径上的数字，但这题的考点在于，如何判断一组数字是否存在一个回文串组合？</p><p>稍加思考不难想到：<strong>如果一组数字中，只有最多一个数字出现的次数为奇数，剩余数字的出现次数均为偶数，那么这组数字可以组成一个回文串</strong>。</p><p>题目说了 <code>1 &lt;= root.val &lt;= 9</code>，所以我们可以用一个大小为 10 的 <code>count</code> 数组做计数器来记录每条路径上的元素出现次数，到达叶子节点之后根据元素出现的次数判断是否可以构成回文串。</p><p>当然，我们也可以用更巧妙的位运算来实现上述逻辑：</p><p>1、首先用到异或运算的特性，1 ^ 1 &#x3D; 0, 0 ^ 0 &#x3D; 0, 1 ^ 0 &#x3D; 1。</p><p>2、其次用到 <code>n &amp; (n - 1)</code> 去除二进制最后一个 1 的技巧，详见 <a href="https://labuladong.online/algo/frequency-interview/bitwise-operation/">东哥教你几招常用的位运算技巧</a>。</p><p>我同时实现了这两种方法，供你参考。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">pseudoPalindromicPaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 遇到叶子节点，判断路径是否是伪回文串</span>            self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 如果路径上出现奇数次的数字个数大于 1，</span>            <span class="token comment"># 则不可能组成回文串，反之则可以组成回文串</span>            odd <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> n <span class="token keyword">in</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>                <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    odd <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> odd <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token comment"># 用位运算代替数组计数，进一步提升效率</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">pseudoPalindromicPaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 遇到叶子节点，判断路径是否是伪回文串</span>            self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 判断二进制中只有一位 1，原理见 https://labuladong.online/algo/frequency-interview/bitwise-operation/</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">&amp;</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-4"><a href="#可视化-4" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_pseudo-palindromic-paths-in-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 0px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_pseudo-palindromic-paths-in-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/pseudo-palindromic-paths-in-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_sum-of-left-leaves">404. 左叶子之和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">404. 左叶子之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-left-leaves/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-left-leaves/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，返回所有左叶子之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/04/08/leftsum-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [3,9,20,null,null,15,7] <strong style="font-weight: 600;">输出:</strong> 24 <strong style="font-weight: 600;">解释:</strong> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [1]<strong style="font-weight: 600;">输出:</strong> 0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-left-leaves/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 404. 左叶子之和</a>。</strong></details><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>无非就是遍历一遍二叉树，然后找到那些左叶子节点，累加它们的值罢了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录左叶子之和</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 找到左侧的叶子节点，记录累加值</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val        <span class="token comment"># 递归框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-5"><a href="#可视化-5" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_sum-of-left-leaves" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-left-leaves" src="https://labuladong.online/algo-visualize/leetcode/sum-of-left-leaves/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_add-one-row-to-tree">623. 在二叉树中增加一行</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">623. 在二叉树中增加一行</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/add-one-row-to-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/add-one-row-to-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的根&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;和两个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>&nbsp;，在给定的深度&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>&nbsp;处添加一个值为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>的节点行。</p><p style="line-height: 1.6; overflow-wrap: break-word;">注意，根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;位于深度&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">加法规则如下:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>，对于深度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth - 1</code><span>&nbsp;</span>的每个非空树节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>，创建两个值为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>的树节点作为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>的左子树根和右子树根。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>原来的左子树应该是新的左子树根的左子树。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>原来的右子树应该是新的右子树根的右子树。</li><li>如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth == 1<span>&nbsp;</span></code>意味着&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth - 1</code>&nbsp;根本没有深度，那么创建一个树节点，值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val<span>&nbsp;</span></code>作为整个原始树的新根，而原始树就是新根的左子树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/15/addrow-tree.jpg" style="max-width: 100%; height: 231px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2<strong style="font-weight: 600;">输出:</strong> [4,1,1,2,null,null,6,3,1,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/11/add2-tree.jpg" style="max-width: 100%; height: 277px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [4,2,null,3,1], val = 1, depth = 3<strong style="font-weight: 600;">输出:</strong>  [4,2,null,1,1,3,null,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>&nbsp;范围内</li><li>树的深度在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= val &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= depth &lt;= the depth of tree + 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/add-one-row-to-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 623. 在二叉树中增加一行</a>。</strong></details><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>用 <code>traverse</code> 函数遍历到对应行，进行插入即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-7"><a href="#解法代码-7" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>targetVal <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>targetDepth <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">addOneRow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> depth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>targetVal <span class="token operator">=</span> val        self<span class="token punctuation">.</span>targetDepth <span class="token operator">=</span> depth        <span class="token comment"># 插入到第一行的话特殊对待一下</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>targetDepth <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            newRoot <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>targetVal<span class="token punctuation">)</span>            newRoot<span class="token punctuation">.</span>left <span class="token operator">=</span> root            <span class="token keyword">return</span> newRoot        <span class="token comment"># 遍历二叉树，走到对应行进行插入</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> curDepth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历</span>        <span class="token keyword">if</span> curDepth <span class="token operator">==</span> self<span class="token punctuation">.</span>targetDepth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 进行插入</span>            newLeft <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>targetVal<span class="token punctuation">)</span>            newRight <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>targetVal<span class="token punctuation">)</span>            newLeft<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left            newRight<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right            root<span class="token punctuation">.</span>left <span class="token operator">=</span> newLeft            root<span class="token punctuation">.</span>right <span class="token operator">=</span> newRight        <span class="token comment"># Recursively traverse the left and right subtree</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> curDepth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> curDepth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 后序遍历</span>        <span class="token comment"># Note: The original Java code does not have any action in the post-order position,</span>        <span class="token comment"># but we keep the comment for consistency.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-6"><a href="#可视化-6" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_add-one-row-to-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_add-one-row-to-tree" src="https://labuladong.online/algo-visualize/leetcode/add-one-row-to-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="971-翻转二叉树以匹配先序遍历"><a href="#971-翻转二叉树以匹配先序遍历" class="headerlink" title="971. 翻转二叉树以匹配先序遍历"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_flip-binary-tree-to-match-preorder-traversal">971. 翻转二叉树以匹配先序遍历</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">971. 翻转二叉树以匹配先序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，树中有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点，每个节点都有一个不同于其他节点且处于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>之间的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">另给你一个由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个值组成的行程序列<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span>，表示<span>&nbsp;</span><strong style="font-weight: 600;">预期</strong><span>&nbsp;</span>的二叉树<span>&nbsp;</span><a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;"><strong style="font-weight: 600;">先序遍历</strong></a><span>&nbsp;</span>结果。</p><p style="line-height: 1.6; overflow-wrap: break-word;">通过交换节点的左右子树，可以<span>&nbsp;</span><strong style="font-weight: 600;">翻转</strong><span>&nbsp;</span>该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/15/fliptree.jpg" style="max-width: 100%; width: 400px; height: 187px;"><p style="line-height: 1.6; overflow-wrap: break-word;">请翻转<span>&nbsp;</span><strong style="font-weight: 600;">最少<span>&nbsp;</span></strong>的树中节点，使二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">先序遍历</strong><span>&nbsp;</span>与预期的遍历行程<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span><strong style="font-weight: 600;">相匹配</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果可以，则返回<span>&nbsp;</span><strong style="font-weight: 600;">翻转的</strong><span>&nbsp;</span>所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-1]</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-01.png" style="max-width: 100%; width: 150px; height: 205px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2], voyage = [2,1]<strong style="font-weight: 600;">输出：</strong>[-1]<strong style="font-weight: 600;">解释：</strong>翻转节点无法令先序遍历匹配预期行程。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-02.png" style="max-width: 100%; width: 150px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], voyage = [1,3,2]<strong style="font-weight: 600;">输出：</strong>[1]<strong style="font-weight: 600;">解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-02.png" style="max-width: 100%; width: 150px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], voyage = [1,2,3]<strong style="font-weight: 600;">输出：</strong>[]<strong style="font-weight: 600;">解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数目为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == voyage.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val, voyage[i] &lt;= n</code></li><li>树中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span>中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 971. 翻转二叉树以匹配先序遍历</a>。</strong></details><h3 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>用 <code>traverse</code> 函数遍历整棵二叉树，对比前序遍历结果，如果节点的值对不上，就无解；如果子树对不上 <code>voyage</code>，就尝试翻转子树。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-8"><a href="#解法代码-8" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipMatchVoyage</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> voyage<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>can_flip <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 遍历的过程中尝试进行反转</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> node <span class="token keyword">or</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>can_flip<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>val <span class="token operator">!=</span> voyage<span class="token punctuation">[</span>self<span class="token punctuation">.</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># 节点的 val 对不上，必然无解</span>                self<span class="token punctuation">.</span>can_flip <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            self<span class="token punctuation">.</span>i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># Only flip if there's a left child and the next value in voyage doesn't match the left child's value</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> voyage<span class="token punctuation">[</span>self<span class="token punctuation">.</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># 前序遍历结果不对，尝试翻转左右子树</span>                self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left            <span class="token comment"># 记录翻转节点</span>            <span class="token comment"># Note: This comment was not in the original Java code, but added to match the pattern of comments. </span>            <span class="token comment"># If this was not intended, it can be removed.</span>            <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-7"><a href="#可视化-7" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_flip-binary-tree-to-match-preorder-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_flip-binary-tree-to-match-preorder-traversal" src="https://labuladong.online/algo-visualize/leetcode/flip-binary-tree-to-match-preorder-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="987-二叉树的垂序遍历"><a href="#987-二叉树的垂序遍历" class="headerlink" title="987. 二叉树的垂序遍历"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_vertical-order-traversal-of-a-binary-tree">987. 二叉树的垂序遍历</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">987. 二叉树的垂序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请你设计算法计算二叉树的<em><span>&nbsp;</span></em><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">对位于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row, col)</code>&nbsp;的每个结点而言，其左右子结点分别位于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row + 1, col - 1)</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row + 1, col + 1)</code><span>&nbsp;</span>。树的根结点位于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(0, 0)</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree1.jpg" style="max-width: 100%; width: 431px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>[[9],[3,15],[20],[7]]<strong style="font-weight: 600;">解释：</strong>列 -1 ：只有结点 9 在此列中。列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。列  1 ：只有结点 20 在此列中。列  2 ：只有结点 7 在此列中。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree2.jpg" style="max-width: 100%; width: 512px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6,7]<strong style="font-weight: 600;">输出：</strong>[[4],[2],[1,5,6],[3],[7]]<strong style="font-weight: 600;">解释：</strong>列 -2 ：只有结点 4 在此列中。列 -1 ：只有结点 2 在此列中。列  0 ：结点 1 、5 和 6 都在此列中。          1 在上面，所以它出现在前面。          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。列  1 ：只有结点 3 在此列中。列  2 ：只有结点 7 在此列中。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree3.jpg" style="max-width: 100%; width: 512px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,6,5,7]<strong style="font-weight: 600;">输出：</strong>[[4],[2],[1,5,6],[3],[7]]<strong style="font-weight: 600;">解释：</strong>这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中结点数目总数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 987. 二叉树的垂序遍历</a>。</strong></details><h3 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>看这题的难度是困难，但你别被吓住了，我们从简单的开始，如果以整棵树的根节点为坐标 <code>(0, 0)</code>，你如何打印出其他节点的坐标？</p><p>很简单，写出如下代码遍历一遍二叉树即可：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">print</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就简单了，把这些坐标收集起来，依据题目要求进行排序，组装成题目要求的返回数据格式即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-9"><a href="#解法代码-9" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 记录每个节点和对应的坐标 (row, col)</span>    <span class="token keyword">class</span> <span class="token class-name">Triple</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>node <span class="token operator">=</span> node            self<span class="token punctuation">.</span>row <span class="token operator">=</span> row            self<span class="token punctuation">.</span>col <span class="token operator">=</span> col    <span class="token keyword">def</span> <span class="token function">verticalTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历二叉树，并且为所有节点生成对应的坐标</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># 根据题意，根据坐标值对所有节点进行排序：</span>        <span class="token comment"># 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，</span>        <span class="token comment"># 如果 col 和 row 都相同，按照 node.val 从小到大排序。</span>        self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>col<span class="token punctuation">,</span> x<span class="token punctuation">.</span>row<span class="token punctuation">,</span> x<span class="token punctuation">.</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 将排好序的节点组装成题目要求的返回格式</span>        res <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 记录上一列编号，初始化一个特殊值</span>        preCol <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> cur <span class="token keyword">in</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>col <span class="token operator">!=</span> preCol<span class="token punctuation">:</span>                <span class="token comment"># 开始记录新的一列</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                preCol <span class="token operator">=</span> cur<span class="token punctuation">.</span>col            res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span> <span class="token keyword">for</span> col <span class="token keyword">in</span> res<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token comment"># 二叉树遍历函数，记录所有节点对应的坐标</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> row<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> col<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 记录坐标</span>        self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Triple<span class="token punctuation">(</span>root<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/path-sum-iv">666. 路径总和 IV 🟠</a></li></ul><h2 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_cousins-in-binary-tree">993. 二叉树的堂兄弟节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">993. 二叉树的堂兄弟节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/cousins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/cousins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在二叉树中，根节点位于深度<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>处，每个深度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>的节点的子节点位于深度<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k+1</code><span>&nbsp;</span>处。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果二叉树的两个节点深度相同，但<strong style="font-weight: 600;"><span>&nbsp;</span>父节点不同</strong><span>&nbsp;</span>，则它们是一对<em>堂兄弟节点</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">我们给出了具有唯一值的二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，以及树中两个不同节点的值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">只有与值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code><span>&nbsp;</span>对应的节点是堂兄弟节点时，才返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>。否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" style="max-width: 100%; height: 160px; width: 180px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4], x = 4, y = 3<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" style="max-width: 100%; height: 160px; width: 201px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" style="max-width: 100%; height: 160px; width: 156px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4], x = 2, y = 3<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点数介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>之间。</li><li>每个节点的值都是唯一的、范围为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>的整数。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/cousins-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 993. 二叉树的堂兄弟节点</a>。</strong></details><h3 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>遍历找到 x，y 的深度和父节点，对比即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-10"><a href="#解法代码-10" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>parentX <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>parentY <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>depthX <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>depthY <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">isCousins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x        self<span class="token punctuation">.</span>y <span class="token operator">=</span> y        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>depthX <span class="token operator">==</span> self<span class="token punctuation">.</span>depthY <span class="token keyword">and</span> self<span class="token punctuation">.</span>parentX <span class="token operator">!=</span> self<span class="token punctuation">.</span>parentY<span class="token punctuation">:</span>            <span class="token comment"># 判断 x，y 是否是表兄弟节点</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> depth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> parent<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>x<span class="token punctuation">:</span>            <span class="token comment"># 找到 x，记录它的深度和父节点</span>            self<span class="token punctuation">.</span>parentX <span class="token operator">=</span> parent            self<span class="token punctuation">.</span>depthX <span class="token operator">=</span> depth        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>y<span class="token punctuation">:</span>            <span class="token comment"># 找到 y，记录它的深度和父节点</span>            self<span class="token punctuation">.</span>parentY <span class="token operator">=</span> parent            self<span class="token punctuation">.</span>depthY <span class="token operator">=</span> depth        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-8"><a href="#可视化-8" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_cousins-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_cousins-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/cousins-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1315-祖父节点值为偶数的节点和"><a href="#1315-祖父节点值为偶数的节点和" class="headerlink" title="1315. 祖父节点值为偶数的节点和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_sum-of-nodes-with-even-valued-grandparent">1315. 祖父节点值为偶数的节点和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1315. 祖父节点值为偶数的节点和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">如果不存在祖父节点值为偶数的节点，那么返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png" style="max-width: 100%; height: 214px; width: 350px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<strong style="font-weight: 600;">输出：</strong>18<strong style="font-weight: 600;">解释：</strong>图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10^4</code>&nbsp;之间。</li><li>每个节点的值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1315. 祖父节点值为偶数的节点和</a>。</strong></details><h3 id="基本思路-11"><a href="#基本思路-11" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>很简单，遍历一遍二叉树，对于节点值为偶数的节点，累加它的孙子节点的值即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-11"><a href="#解法代码-11" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">sumEvenGrandparent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>    <span class="token comment"># 二叉树的遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 累加左子树孙子节点的值</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val            <span class="token comment"># 累加右子树孙子节点的值</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val        <span class="token comment"># 二叉树的遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-9"><a href="#可视化-9" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_sum-of-nodes-with-even-valued-grandparent" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-nodes-with-even-valued-grandparent" src="https://labuladong.online/algo-visualize/leetcode/sum-of-nodes-with-even-valued-grandparent/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448. 统计二叉树中好节点的数目"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_count-good-nodes-in-binary-tree">1448. 统计二叉树中好节点的数目</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1448. 统计二叉树中好节点的数目</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵根为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，请你返回二叉树中好节点的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;">「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png" style="max-width: 100%; height: 156px; width: 263px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,1,4,3,null,1,5]<strong style="font-weight: 600;">输出：</strong>4<strong style="font-weight: 600;">解释：</strong>图中蓝色节点为好节点。根节点 (3) 永远是个好节点。节点 4 -&gt; (3,4) 是路径中的最大值。节点 5 -&gt; (3,4,5) 是路径中的最大值。节点 3 -&gt; (3,1,3) 是路径中的最大值。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png" style="max-width: 100%; height: 161px; width: 157px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,3,null,4,2]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>节点 2 -&gt; (3, 3, 2) 不是好节点，因为 "3" 比它大。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>1<strong style="font-weight: 600;">解释：</strong>根节点是好节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树中节点数目范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10^5]</code>&nbsp;。</li><li>每个节点权值的范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-10^4, 10^4]</code>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1448. 统计二叉树中好节点的数目</a>。</strong></details><h3 id="基本思路-12"><a href="#基本思路-12" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维，利用函数参数给子树传递信息。</p><p>函数参数 <code>pathMax</code> 记录从根节点到当前节点路径中的最大值，通过比较 <code>root.val</code> 和 <code>pathMax</code> 比较就可判断 <code>root</code> 节点是不是「好节点」。然后再把 <code>pathMax</code> 传递到子树中继续判断其他节点。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-12"><a href="#解法代码-12" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">goodNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count    <span class="token comment"># 二叉树遍历函数，pathMax 参数记录从根节点到当前节点路径中的最大值</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> pathMax<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> pathMax <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token comment"># 找到一个「好节点」</span>            self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 更新路径上的最大值</span>        pathMax <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>pathMax<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pathMax<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> pathMax<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-10"><a href="#可视化-10" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_count-good-nodes-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_count-good-nodes-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/count-good-nodes-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>]]></content>
      
      
      <categories>
          
          <category> 二叉树算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2025/08/03/er-cha-sou-suo-shu/"/>
      <url>/2025/08/03/er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树心法（构造篇）"><a href="#二叉搜索树心法（构造篇）" class="headerlink" title="二叉搜索树心法（构造篇）"></a>二叉搜索树心法（构造篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">95. Unique Binary Search Trees II</a></td><td align="center"><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></td><td align="center"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td><td align="center">🟠</td></tr></tbody></table><p>前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树结构基础</a></li><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的 DFS&#x2F;BFS 遍历</a></li></ul><p>之前写了两篇手把手刷 BST 算法题的文章，<a href="https://labuladong.online/algo/data-structure/bst-part1/">第一篇</a> 讲了中序遍历对 BST 的重要意义，<a href="https://labuladong.online/algo/data-structure/bst-part2/">第二篇</a> 写了 BST 的基本操作。</p><p>本文就来写手把手刷 BST 系列的第三篇，循序渐进地讲两道题，如何计算所有有效 BST。</p><p>第一道题是力扣第 96 题「<a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">96. 不同的二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/unique-binary-search-trees/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/unique-binary-search-trees/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，求恰由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点组成且节点值从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>互不相同的<span>&nbsp;</span><strong style="font-weight: 600;">二叉搜索树</strong><span>&nbsp;</span>有多少种？返回满足题意的二叉搜索树的种数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/uniquebstn3.jpg" style="max-width: 100%; width: 600px; height: 148px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 3<strong style="font-weight: 600;">输出：</strong>5</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 1<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 19</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 96. 不同的二叉搜索树</a>。</strong></details><p>函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就是一个正宗的穷举问题，那么什么方式能够正确地穷举有效 BST 的数量呢？</p><p>我们前文说过，不要小看「穷举」，这是一件看起来简单但是比较有技术含量的事情，问题的关键就是不能数漏，也不能数多，你咋整？</p><p>之前 <a href="https://labuladong.online/algo/data-structure/binary-tree-part1/">手把手刷二叉树第一期</a> 说过，二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。</p><p>举个例子，比如给算法输入 <code>n = 5</code>，也就是说用 <code>&#123;1,2,3,4,5&#125;</code> 这些数字去构造 BST。</p><p>首先，这棵 BST 的根节点总共有几种情况？</p><p>显然有 5 种情况对吧，因为每个数字都可以作为根节点。</p><p>比如说我们固定 <code>3</code> 作为根节点，这个前提下能有几种不同的 BST 呢？</p><p>根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。</p><p>所以如果固定 <code>3</code> 作为根节点，左子树节点就是 <code>&#123;1,2&#125;</code> 的组合，右子树就是 <code>&#123;4,5&#125;</code> 的组合。</p><p><strong>左子树的组合数和右子树的组合数乘积</strong>就是 <code>3</code> 作为根节点时的 BST 个数。</p><p><img src="/2025/08/03/er-cha-sou-suo-shu/1.jpeg" alt="img"></p><p>我们这是说了 <code>3</code> 为根节点这一种特殊情况，其实其他的节点也是一样的。</p><p>那你可能会问，我们可以一眼看出 <code>&#123;1,2&#125;</code> 和 <code>&#123;4,5&#125;</code> 有几种组合，但是怎么让算法进行计算呢？</p><p>其实很简单，只需要递归就行了，我们可以写这样一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：闭区间 [lo, hi] 的数字能组成 count(lo, hi) 种 BST</span><span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据这个函数的定义，结合刚才的分析，可以写出代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 计算闭区间 [1, n] 组成的 BST 个数</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment"># 计算闭区间 [lo, hi] 组成的 BST 个数</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> lo <span class="token operator">></span> hi<span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># i 的值作为根节点 root</span>            left <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            right <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            <span class="token comment"># 左右子树的组合数乘积是 BST 的总数</span>            res <span class="token operator">+=</span> left <span class="token operator">*</span> right        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 base case，显然当 <code>lo &gt; hi</code> 闭区间 <code>[lo, hi]</code> 肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p><p>这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。</p><p>前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 备忘录</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 备忘录的值初始化为 0</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment"># 定义：返回 [lo, hi] 范围内构造的不同 BST 的数量</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token comment"># 查备忘录</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> mid <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            right <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            res <span class="token operator">+=</span> left <span class="token operator">*</span> right        <span class="token comment"># 将结果存入备忘录</span>        self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，这道题就完全解决了。</p><p>那么，如果给一个进阶题目，不止让你计算有几个不同的 BST，而是要你构建出所有有效的 BST，如何实现这个算法呢？</p><p>这道题就是力扣第 95 题「<a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a>」，让你构建所有 BST：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">95. 不同的二叉搜索树 II</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，请你生成并返回所有由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点组成且节点值从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>互不相同的不同<span>&nbsp;</span><strong style="font-weight: 600;">二叉搜索树</strong><em><span>&nbsp;</span></em>。可以按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>返回答案。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/uniquebstn3.jpg" style="max-width: 100%; width: 600px; height: 148px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 3<strong style="font-weight: 600;">输出：</strong>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 1<strong style="font-weight: 600;">输出：</strong>[[1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 8</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 95. 不同的二叉搜索树 II</a>。</strong></details><p>函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> generateTrees<span class="token punctuation">(</span><span class="token builtin">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>明白了上道题构造有效 BST 的方法，这道题的思路也是一样的</strong>：</p><p>1、穷举 <code>root</code> 节点的所有可能。</p><p>2、递归构造出左右子树的所有有效 BST。</p><p>3、给 <code>root</code> 节点穷举所有左右子树的组合。</p><p>我们可以直接看代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 构造闭区间 [1, n] 组成的 BST </span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment"># 构造闭区间 [lo, hi] 组成的 BST </span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> lo <span class="token operator">></span> hi<span class="token punctuation">:</span>            <span class="token comment"># 这里需要装一个 null 元素，这样才能让下面的两个内层 for 循环都能进入，正确地创建出叶子节点</span>            <span class="token comment"># 举例来说吧，什么时候会进到这个 if 语句？当你创建叶子节点的时候，对吧。</span>            <span class="token comment"># 那么如果你这里不加 null，直接返回空列表，那么下面的内层两个 for 循环都无法进入        </span>            <span class="token comment"># 你的那个叶子节点就没有创建出来，看到了吗？所以这里要加一个 null，确保下面能把叶子节点做出来</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> res        <span class="token comment"># 1、穷举 root 节点的所有可能。</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 2、递归构造出左右子树的所有有效 BST。</span>            leftTree <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            rightTree <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            <span class="token comment"># 3、给 root 节点穷举所有左右子树的组合。</span>            <span class="token keyword">for</span> left <span class="token keyword">in</span> leftTree<span class="token punctuation">:</span>                <span class="token keyword">for</span> right <span class="token keyword">in</span> rightTree<span class="token punctuation">:</span>                    <span class="token comment"># i 作为根节点 root 的值</span>                    root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees-ii" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees-ii" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，两道题都解决了。</p><p>本文就到这里，更多经典的二叉树习题以及递归思维的训练，请参见二叉树章节中的 <a href="https://labuladong.online/algo/problem-set/bst1/">递归专项练习</a></p><h1 id="二叉搜索树心法（后序篇）"><a href="#二叉搜索树心法（后序篇）" class="headerlink" title="二叉搜索树心法（后序篇）"></a>二叉搜索树心法（后序篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/">1373. Maximum Sum BST in Binary Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和</a></td><td align="center">🔴</td></tr></tbody></table><p>前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树结构基础</a></li><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的 DFS&#x2F;BFS 遍历</a></li><li><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a></li></ul><p>本文是承接 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a> 的第五篇文章，主要讲二叉树后序位置的妙用，复述下前文关于后序遍历的描述：</p><blockquote><p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</p><p><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p></blockquote><p>其实二叉树的题目真的不难，无非就是前中后序遍历框架来回倒嘛，只要你把一个节点该做的事情安排好，剩下的抛给递归框架即可。</p><p>但是对于有的题目，不同的遍历顺序时间复杂度不同。尤其是这个后序位置的代码，有时候可以大幅提升算法效率。</p><p>我们再看看后序遍历的代码框架：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 后序代码的位置</span>    <span class="token comment"># 在这里处理当前节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看这个代码框架，你说什么情况下需要在后序位置写代码呢？</p><p><strong>如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历</strong>。</p><p>下面就讲一个经典的算法问题，可以直观地体会到后序位置的妙用。这是力扣第 1373 题「<a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">二叉搜索子树的最大键值和</a>」，函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">maxSumBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90">题目分析</a></h2><p>题目会给你输入一棵二叉树，这棵二叉树的子树中可能包含<strong>二叉搜索树</strong>对吧，请你找到<strong>节点之和最大的</strong>那棵二叉搜索树，返回它的节点值之和。</p><p>二叉搜索树（简写作 BST）的性质详见基础知识章节 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础</a>，简单说就是「左小右大」，对于每个节点，整棵左子树都比该节点的值小，整棵右子树都比该节点的值大。</p><p>比如题目给了这个例子：</p><p><img src="/2025/08/03/er-cha-sou-suo-shu/1.png" alt="img"></p><p>如果输入这棵二叉树，算法应该返回 20，也就是图中绿圈的那棵子树的节点值之和，因为它是一棵 BST，且节点之和最大。</p><p>那有的读者可能会问，输入的是一棵普通二叉树，有没有可能其中不存在 BST？</p><p>不会的，因为按照 BST 的定义，任何一个单独的节点肯定是 BST，也就是说，再不济，二叉树最下面的叶子节点肯定都是 BST。</p><p>比如说如果输入下面这棵二叉树：</p><p><img src="/2025/08/03/er-cha-sou-suo-shu/2.png" alt="img"></p><p>两个叶子节点 <code>1</code> 和 <code>2</code> 就是 BST，比较一下节点之和，算法应该返回 2。</p><p>好了，到这里，题目应该解释地很清楚了，下面我们来分析一下这道题应该怎么做。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></h2><p>刚才说了，<strong>二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么</strong>。</p><p><strong>那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢</strong>？</p><p>1、我肯定得知道左右子树是不是合法的 BST，如果下面的这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。</p><p>2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。</p><p>3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。</p><p><strong>根据以上三点，站在当前节点的视角，需要知道以下具体信息</strong>：</p><p>1、左右子树是否是 BST。</p><p>2、左子树的最大值和右子树的最小值。</p><p>3、左右子树的节点值之和。</p><p>只有知道了这几个值，我们才能满足题目的要求，现在可以尝试用伪码写出算法的大致逻辑：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 全局变量，记录 BST 最大节点之和</span>        self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">maxSumBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxSum    <span class="token comment"># 遍历二叉树</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># ******* 前序位置 *******</span>        <span class="token comment"># 判断左右子树是不是 BST</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 计算左子树的最大值和右子树的最小值</span>            leftMax <span class="token operator">=</span> self<span class="token punctuation">.</span>findMax<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            rightMin <span class="token operator">=</span> self<span class="token punctuation">.</span>findMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 判断以 root 节点为根的树是不是 BST</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> leftMax <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> rightMin<span class="token punctuation">:</span>                <span class="token comment"># 如果条件都符合，计算当前 BST 的节点之和</span>                leftSum <span class="token operator">=</span> self<span class="token punctuation">.</span>findSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                rightSum <span class="token operator">=</span> self<span class="token punctuation">.</span>findSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                rootSum <span class="token operator">=</span> leftSum <span class="token operator">+</span> rightSum <span class="token operator">+</span> root<span class="token punctuation">.</span>val                <span class="token comment"># 计算 BST 节点的最大和</span>                self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxSum<span class="token punctuation">,</span> rootSum<span class="token punctuation">)</span>        <span class="token comment"># **************************</span>        <span class="token comment"># 二叉树遍历框架，遍历子树节点</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 计算以 root 为根的二叉树的最大值</span>    <span class="token keyword">def</span> <span class="token function">findMax</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 计算以 root 为根的二叉树的最小值</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 计算以 root 为根的二叉树的节点和</span>    <span class="token keyword">def</span> <span class="token function">findSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 判断以 root 为根的二叉树是否是 BST</span>    <span class="token keyword">def</span> <span class="token function">isBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码逻辑应该是不难理解的，代码在前序遍历的位置把之前的分析都实现了一遍。</p><p>其中有四个辅助函数比较简单，我就不具体实现了，其中只有判断合法 BST 的函数稍有技术含量，前文 <a href="https://labuladong.online/algo/data-structure/bst-part2/">二叉搜索树操作集锦</a> 写过，这里就不展开了。</p><p><strong>稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 <code>traverse</code> 函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的</strong>。</p><p>具体来说，每一个辅助方法都是二叉树遍历函数，时间复杂度是 O(N)<em>O</em>(<em>N</em>)，而 <code>traverse</code> 遍历框架会在每个节点上都把这些辅助函数调用一遍，所以总的时间复杂度是 O(N2)<em>O</em>(<em>N</em>2)。</p><p>但是根据刚才的分析，像 <code>leftMax</code>、<code>rootSum</code> 这些变量又都得算出来，否则无法完成题目的要求。</p><h2 id="思路优化"><a href="#思路优化" class="headerlink" title="思路优化"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E6%80%9D%E8%B7%AF%E4%BC%98%E5%8C%96">思路优化</a></h2><p>我们希望既算出这些变量，又避免辅助函数带来的额外复杂度，鱼和熊掌全都要，可以做到吗？</p><p>其实是可以的，<strong>只要把前序遍历变成后序遍历，让 <code>traverse</code> 函数把辅助函数做的事情顺便做掉</strong>。</p><p>你仔细想想，如果我知道了我的左右子树的最大值，那么把我的值和它们比较一下，就可以推导出以我为根的这整棵二叉树的最大值。根本没必要再遍历一遍所有节点，对吧？求最小节点的值和节点的和也是一样的道理。</p><p>这就是我在前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手带你刷二叉树（纲领篇）</a> 所讲的后序遍历位置的妙用。</p><p>当然，正如前文所讲，如果要利用函数的返回值，就不建议使用 <code>traverse</code> 这个函数名了，我们想计算最大值、最小值和所有节点之和，不妨叫这个函数 <code>findMaxMinSum</code> 好了。</p><p>其他代码不变，我们让 <code>findMaxMinSum</code> 函数做一些计算任务，返回一个大小为 4 的 int 数组，我们暂且称它为 <code>res</code>，其中：</p><p><code>res[0]</code> 记录以 <code>root</code> 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；</p><p><code>res[1]</code> 记录以 <code>root</code> 为根的二叉树所有节点中的最小值；</p><p><code>res[2]</code> 记录以 <code>root</code> 为根的二叉树所有节点中的最大值；</p><p><code>res[3]</code> 记录以 <code>root</code> 为根的二叉树所有节点值之和。</p><p>对于当前节点，如果分别对左右子树计算出了这 4 个值，只需要简单的运算，就可以推导出以当前节点为根的二叉树的这 4 个值，避免了重复遍历。</p><p>直接看代码实现吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 BST 最大节点之和</span>        self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">maxSumBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>findMaxMinSum<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxSum    <span class="token comment"># 计算以 root 为根的二叉树的最大值、最小值、节点和</span>    <span class="token keyword">def</span> <span class="token function">findMaxMinSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>                <span class="token comment"># 递归计算左右子树</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>findMaxMinSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>findMaxMinSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># ******* 后序位置 *******</span>        <span class="token comment"># 通过 left 和 right 推导返回值</span>        <span class="token comment"># 并且正确更新 maxSum 变量</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> left<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 以 root 为根的二叉树是 BST</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token comment"># 计算以 root 为根的这棵 BST 的最小值</span>            res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 计算以 root 为根的这棵 BST 的最大值</span>            res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 计算以 root 为根的这棵 BST 所有节点之和</span>            res<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val            <span class="token comment"># 更新全局变量</span>            self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxSum<span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 以 root 为根的二叉树不是 BST</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 其他的值都没必要计算了，因为用不到</span>                    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，这道题就解决了，<code>findMaxMinSum</code> 函数在遍历二叉树的同时顺便把之前辅助函数做的事情都做了，避免了在递归函数中调用递归函数，时间复杂度只有 O(N)。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">最后总结</a></h2><p>你看，这就是后序遍历的妙用，相对前序遍历的解法，现在的解法不仅效率高，而且代码量少，比较优美。</p><p>这个优化属于前文 <a href="https://labuladong.online/algo/essential-technique/algorithm-summary/">算法的本质</a> 中提到的「如何聪明的穷举」的范畴。</p><p>那可能有读者问，后序遍历这么好，是不是就应该尽可能多用后序遍历？</p><p>不是，主要是看题目，看你这个问题适合「遍历」的思路还是「分解问题」的思路。为什么这道题用后序遍历有奇效呢，因为我们需要的这些变量全都可以通过子问题的结果推到出来，适合用「分解问题」的思路求解。</p><p>你计算以 <code>root</code> 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 <code>root.val</code> 计算出来？</p><p>你计算以 <code>root</code> 为根的二叉树的最大值&#x2F;最小值，是不是可以通过左右子树的最大值&#x2F;最小值和 <code>root.val</code> 比较出来？</p><p>你判断以 <code>root</code> 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？</p><p>那么充分利用子问题的答案，当然要比每次都傻乎乎遍历所有节点要高效。</p><p><strong>以我的刷题经验，我们要尽可能避免递归函数中调用其他递归函数</strong>，如果出现这种情况，大概率是代码实现有瑕疵，可以进行类似本文的优化来避免递归套递归。</p><p>本文就到这里，更多经典的二叉树习题以及递归思维的训练，请参见二叉树章节中的 <a href="https://labuladong.online/algo/intro/binary-tree-practice/">递归专项练习</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 二叉树算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo分支管理及图片显示</title>
      <link href="/2025/07/25/hexo-fen-zhi-guan-li-ji-tu-pian-xian-shi/"/>
      <url>/2025/07/25/hexo-fen-zhi-guan-li-ji-tu-pian-xian-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-分支"><a href="#Hexo-分支" class="headerlink" title="Hexo 分支"></a>Hexo 分支</h2><p>在使用 Hexo 搭建 GitHub Page 博客时，通常会遇到如何保存 Hexo 环境和博客源码的问题。一个常见的解决方案是使用 GitHub 分支来管理不同的内容。</p><h3 id="创建和管理分支"><a href="#创建和管理分支" class="headerlink" title="创建和管理分支"></a>创建和管理分支</h3><p>首先，在 GitHub 上创建一个新的仓库，例如 <em><code>username.github.io</code></em>。然后，在该仓库下创建两个分支：<em><code>master</code></em> 和 <em><code>hexo</code></em>。其中，<em><code>master</code></em> 分支用于保存 <code>Hexo</code> 生成的静态 HTML 文件，而 <em><code>hexo</code></em> 分支用于保存 <code>Hexo</code> 环境和博客的 Markdown 源码。</p><h3 id="初始化-Hexo-环境"><a href="#初始化-Hexo-环境" class="headerlink" title="初始化 Hexo 环境"></a>初始化 Hexo 环境</h3><p>在本地克隆仓库后，依次执行以下命令来初始化 Hexo 环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexohexo init<span class="token function">npm</span> <span class="token function">install</span><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，配置 Hexo 的 <em>_config.yml</em> 文件中的 <em>deploy</em> 参数，将分支设置为 <em>master</em>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span><span class="token key atrule">type</span><span class="token punctuation">:</span> git<span class="token key atrule">repo</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>username/username.github.io.git<span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span class="token comment"># 现在GitHub已经默认主分支为main</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="提交和部署"><a href="#提交和部署" class="headerlink" title="提交和部署"></a>提交和部署</h3><p>每次修改或新增博文后，依次执行以下命令将博客源码提交到 <em><code>hexo</code></em> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"更新博客"</span><span class="token function">git</span> push origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，执行 <em><code>hexo generate -d</code></em> 命令生成网站并部署到 GitHub 上的 <em>master</em> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h3><p>在完成初始配置后，日常操作只需重复上述提交和部署步骤即可。在本地修改博客内容后，通过以下命令将改动推送到 GitHub：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"更新博客"</span><span class="token function">git</span> push origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，执行以下命令发布网站到 <em>master</em> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="处理本地资料丢失"><a href="#处理本地资料丢失" class="headerlink" title="处理本地资料丢失"></a>处理本地资料丢失</h3><p>如果需要在其他电脑上修改博客，可以通过以下步骤恢复环境：</p><ul><li>克隆仓库到本地：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:username/username.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>重新安装 Hexo 编译环境：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo<span class="token function">npm</span> <span class="token function">install</span><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<em><code>hexo init</code></em> 命令会初始化 Hexo 环境，但会清空 <em>.git</em> 文件夹，导致版本控制信息丢失。因此，除非环境损坏，否则无需运行此命令</p><p>通过以上步骤，可以高效地管理 Hexo 环境和博客源码，确保博客内容的安全和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树心法（序列化篇</title>
      <link href="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/"/>
      <url>/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/</url>
      
        <content type="html"><![CDATA[<p>本文是承接 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a> 的第三篇文章，前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a> 带你学习了二叉树构造技巧，本文加大难度，让你对二叉树同时进行「序列化」和「反序列化」。</p><p>要说序列化和反序列化，得先从 JSON 数据格式说起。</p><p>JSON 的运用非常广泛，比如我们经常将编程语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。</p><p>这就是序列化和反序列化的目的，以某种特定格式组织数据，使得数据可以独立于编程语言。</p><p>那么假设现在有一棵用 Java 实现的二叉树，我想把它通过某些方式存储下来，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行序列化和反序列化了。</p><h2 id="零、前-中-后序和二叉树的唯一性"><a href="#零、前-中-后序和二叉树的唯一性" class="headerlink" title="零、前&#x2F;中&#x2F;后序和二叉树的唯一性"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E9%9B%B6%E3%80%81%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7">零、前&#x2F;中&#x2F;后序和二叉树的唯一性</a></h2><p>谈具体的题目之前，我们先思考一个问题：<strong>什么样的序列化的数据可以反序列化出唯一的一棵二叉树</strong>？</p><p>比如说，如果给你一棵二叉树的前序遍历结果，你是否能够根据这个结果还原出这棵二叉树呢？</p><p>答案是也许可以，也许不可以，具体要看你给的前序遍历结果是否包含空指针的信息。如果包含了空指针，那么就可以唯一确定一棵二叉树，否则就不行。</p><p>举例来说，如果我给你这样一个不包含空指针的前序遍历结果 <code>[1,2,3,4,5]</code>，那么如下两棵二叉树都是满足这个前序遍历结果的：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/dup-preorder.jpg" alt="img"></p><p>所以给定不包含空指针信息的前序遍历结果，是不能还原出唯一的一棵二叉树的。</p><p>但如果我的前序遍历结果包含空指针的信息，那么就能还原出唯一的一棵二叉树了。比如说用 <code>#</code> 表示空指针，上图左侧的二叉树的前序遍历结果就是 <code>[1,2,3,#,#,4,#,#,5,#,#]</code>，上图右侧的二叉树的前序遍历结果就是 <code>[1,2,#,3,#,#,4,5,#,#,#]</code>，它俩就区分开了。</p><p>那么估计就有聪明的小伙伴说了：二叉树心法了。</p><p>首先要夸一下这种举一反三的思维，但很不幸，正确答案是，即便你包含了空指针的信息，也只有前序和后序的遍历结果才能唯一还原二叉树，中序遍历结果做不到。</p><p>本文后面会具体探讨这个问题，这里只简单说下原因：因为前序&#x2F;后序遍历的结果中，可以确定根节点的位置，而中序遍历的结果中，根节点的位置是无法确定的。</p><p>更直观的，比如如下两棵二叉树显然拥有不同的结构，但它俩的中序遍历结果都是 <code>[#,1,#,1,#]</code>，无法区分：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/dup-inorder.jpg" alt="img"></p><p>说了这么多，总结下结论，<strong>当二叉树中节点的值不存在重复时</strong>：</p><ol><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你会给出<strong>两种</strong>遍历顺序，分两种情况：</p><p>2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。</p><p>2.2. 如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，也要分两种情况：</p><p>3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。</p><p>3.2. 如果你给出的是中序，那么你无法还原出唯一的一棵二叉树。</p></li></ol><p>我在开头提一下这些总结性的认识，可以理解性记忆，之后会遇到一些相关的题目，再回过头来看看这些总结，会有更深的理解，下面看具体的题目吧。</p><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">一、题目描述</a></h2><p>力扣第 297 题「<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a>」就是给你输入一棵二叉树的根节点 <code>root</code>，要求你实现如下一个类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>        <span class="token comment"># 把一棵二叉树序列化成字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 把字符串反序列化成二叉树</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用 <code>serialize</code> 方法将二叉树序列化成字符串，用 <code>deserialize</code> 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。</p><p>比如说输入如下这样一棵二叉树：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/1.jpg" alt="img"></p><p><code>serialize</code> 方法也许会把它序列化成字符串 <code>2,1,#,6,#,#,3,#,#</code>，其中 <code>#</code> 表示 <code>null</code> 指针，那么把这个字符串再输入 <code>deserialize</code> 方法，依然可以还原出这棵二叉树。</p><p>也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。</p><p>想象一下，二叉树是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。<strong>所谓的序列化不过就是把结构化的数据「打平」，本质就是在考察二叉树的遍历方式</strong>。</p><p>二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 <code>serialize</code> 方法和 <code>deserialize</code> 方法。</p><h2 id="二、前序遍历解法"><a href="#二、前序遍历解法" class="headerlink" title="二、前序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%BA%8C%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">二、前序遍历解法</a></h2><p>前文 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的遍历基础</a> 说过了二叉树的几种遍历方式，在前序位置收集节点，即可获得前序遍历结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 暂且用数字 -1 代表空指针 null</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token comment"># ****** 前序位置 ******</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token comment"># **********************</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>traverse</code> 函数之后，你是否可以立即想出这个 <code>res</code> 列表中元素的顺序是怎样的？比如如下二叉树（<code>#</code> 代表空指针 null），可以直观看出前序遍历做的事情：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/1.jpeg" alt="img"></p><p>那么 <code>res = [1,2,-1,4,-1,-1,3,-1,-1]</code>，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。</p><p>那么，将二叉树打平到一个字符串中也是完全一样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 代表分隔符的字符</span>SEP <span class="token operator">=</span> <span class="token string">","</span><span class="token comment"># 代表 null 空指针的字符</span>NULL <span class="token operator">=</span> <span class="token string">"#"</span><span class="token comment"># 用于拼接字符串</span>sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 将二叉树打平为字符串</span><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token comment"># ***** 前序位置 *****</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>    <span class="token comment"># *******************</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码依然是收集前序遍历结果，用 <code>,</code> 作为分隔符，用 <code>#</code> 表示空指针 null，调用完 <code>traverse</code> 函数后，<code>sb</code> 中的字符串应该是 <code>1,2,#,4,#,#,3,#,#,</code>。</p><p>至此，我们已经可以写出序列化函数 <code>serialize</code> 的代码了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 主函数，将二叉树序列化为字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sb<span class="token punctuation">)</span>    <span class="token comment"># 辅助函数，将二叉树存入 StringBuilder</span>    <span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment"># ****** 前序位置 ********</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        <span class="token comment"># ***********************</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，思考一下如何写 <code>deserialize</code> 函数，将字符串反过来构造二叉树。</p><p>首先我们可以把字符串转化成列表：</p><pre class="line-numbers language-none"><code class="language-none">data &#x3D; &quot;1,2,#,4,#,#,3,#,#,&quot;nodes &#x3D; data.split(&quot;,&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，<code>nodes</code> 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？</p><p>Tip</p><p>前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a> 说过，至少要得到前、中、后序遍历中的两种互相配合才能还原二叉树。那是因为前文的遍历结果没有记录空指针的信息。这里的 <code>nodes</code> 列表包含了空指针的信息，所以只使用 <code>nodes</code> 列表就可以还原二叉树。</p><p>根据我们刚才的分析，<code>nodes</code> 列表就是一棵打平的二叉树：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/1.jpeg" alt="img"></p><p>那么，反序列化过程也是一样，<strong>先确定根节点 <code>root</code>，然后遵循前序遍历的规则，递归生成左右子树即可</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 主函数，将字符串反序列化为二叉树结构</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># 将字符串转化成列表</span>        nodes <span class="token operator">=</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 辅助函数，通过 nodes 列表构造二叉树</span>    <span class="token keyword">def</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> nodes<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># ****** 前序位置 *******</span>        <span class="token comment"># 列表最左侧就是根节点</span>        first <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> first <span class="token operator">==</span> self<span class="token punctuation">.</span>NULL<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment"># *********************</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现，根据树的递归性质，<code>nodes</code> 列表的第一个元素就是一棵树的根节点，所以只要将列表的第一个元素取出作为根节点，剩下的交给递归函数去解决即可。</p><h2 id="三、后序遍历解法"><a href="#三、后序遍历解法" class="headerlink" title="三、后序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%B8%89%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">三、后序遍历解法</a></h2><p>二叉树的后序遍历框架：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置的代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明白了前序遍历的解法，后序遍历就比较容易理解了。<code>serialize</code> 序列化方法非常容易实现，只需要稍微修改前文的 <code>_serialize</code>辅助方法即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 辅助函数，将二叉树存入 StringBuilder</span><span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span>    _serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    _serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token comment"># ****** 后序位置 ********</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>    <span class="token comment"># ***********************</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把对 <code>StringBuilder</code> 的拼接操作放到了后序遍历的位置，后序遍历导致结果的顺序发生变化：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/2.jpeg" alt="img"></p><p>关键点在于，如何实现后序遍历的 <code>deserialize</code> 方法呢？是不是也简单地将反序列化的关键代码无脑放到后序遍历的位置就行了呢：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 辅助函数，通过 nodes 列表构造二叉树</span><span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> nodes<span class="token punctuation">:</span>       <span class="token keyword">return</span> <span class="token boolean">None</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 后序位置</span>    first <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> first <span class="token operator">==</span> <span class="token string">'NULL'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然上述代码是错误的，变量都没声明呢，就开始用了？生搬硬套肯定是行不通的，回想刚才我们前序遍历方法中的 <code>deserialize</code> 方法，第一件事情在做什么？</p><p><strong><code>deserialize</code> 方法首先寻找 <code>root</code> 节点的值，然后递归计算左右子节点</strong>。那么我们这里也应该顺着这个基本思路走，后序遍历中，<code>root</code> 节点的值能不能找到？</p><p>再看一眼刚才的图：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/2.jpeg" alt="img"></p><p>在后序遍历结果中，<code>root</code> 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 <code>root</code>，然后递归调用生成 <code>root</code> 的左右子树。</p><p><strong>注意，根据上图，从后往前在 <code>nodes</code> 列表中取元素，一定要先构造 <code>root.right</code> 子树，后构造 <code>root.left</code> 子树</strong>。</p><p>看完整代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 主函数，将二叉树序列化为字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sb<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>            <span class="token keyword">return</span>                self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token comment"># ****** 后序位置 ********</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        <span class="token comment"># ***********************</span>    <span class="token comment"># 主函数，将字符串反序列化为二叉树结构</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 将分割结果中的空字符串过滤掉</span>        nodes <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 辅助函数，通过 nodes 列表构造二叉树</span>    <span class="token keyword">def</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nodes <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 从后往前取出元素</span>        last <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">if</span> last <span class="token operator">==</span> self<span class="token punctuation">.</span>NULL <span class="token keyword">or</span> last <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 先构造右子树，后构造左子树</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，后序遍历实现的序列化、反序列化方法也都实现了。</p><h2 id="四、中序遍历解法"><a href="#四、中序遍历解法" class="headerlink" title="四、中序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E5%9B%9B%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">四、中序遍历解法</a></h2><p>先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 <code>deserialize</code>。</p><p>序列化方法 <code>serialize</code> 依然容易，只要把辅助函数 <code>_serialize</code> 中的字符串的拼接操作放到中序遍历的位置就行了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 辅助函数，将二叉树存入 StringBuilder</span><span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> sb<span class="token punctuation">:</span> <span class="token string">'List[str]'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>NULL<span class="token punctuation">)</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span>    serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    <span class="token comment"># ******* 中序位置 *******</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>    <span class="token comment"># ***********************</span>    serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，我们刚才说了，要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p><p>你看上面这段中序遍历的代码，<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p><h2 id="五、层级遍历解法"><a href="#五、层级遍历解法" class="headerlink" title="五、层级遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%BA%94%E3%80%81%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">五、层级遍历解法</a></h2><p>先写出 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树遍历基础</a> 中的层级遍历代码框架：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># 初始化队列，将 root 加入队列</span>    q <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>        sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 层级遍历代码位置</span>            cur <span class="token operator">=</span> q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># *************</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上述代码是标准的二叉树层级遍历框架</strong>，从上到下，从左到右打印每一层二叉树节点的值，可以看到，队列 <code>q</code> 中不会存在 null 指针。</p><p>不过我们在反序列化的过程中是需要记录空指针 null 的，所以可以把标准的层级遍历框架略作修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>         <span class="token keyword">return</span>    <span class="token comment"># 初始化队列，将 root 加入队列</span>    q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>        sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 层级遍历代码位置</span>            <span class="token keyword">if</span> cur <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                 <span class="token keyword">continue</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># **************</span>            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样也可以完成层级遍历，只不过我们把对空指针的检验从「将元素加入队列」的时候改成了「从队列取出元素」的时候。</p><p>那么我们完全仿照这个框架即可写出序列化方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 将二叉树序列化为字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span>        <span class="token comment"># 初始化队列，将 root 加入队列</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment"># 层级遍历代码位置</span>                <span class="token keyword">if</span> cur <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>                    <span class="token keyword">continue</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>                <span class="token comment"># ***************</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> Codec<span class="token punctuation">.</span>SEP<span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>层级遍历序列化得出的结果如下图：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/3.jpeg" alt="img"></p><p>可以看到，每一个非空节点都会对应两个子节点，<strong>那么反序列化的思路也是用队列进行层级遍历，同时用索引 <code>index</code> 记录对应子节点的位置</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 将字符串反序列化为二叉树结构</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> data <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 将分割结果中的空字符串过滤掉</span>        nodes <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">]</span>        <span class="token comment"># 第一个元素就是 root 的值</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 队列 q 记录父节点，将 root 加入队列</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># index 变量记录正在序列化的节点在数组中的位置</span>        index <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                parent <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 为父节点构造左侧子节点</span>                left <span class="token operator">=</span> nodes<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                index <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> left <span class="token operator">!=</span> self<span class="token punctuation">.</span>NULL<span class="token punctuation">:</span>                    parent<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token comment"># 为父节点构造右侧子节点</span>                right <span class="token operator">=</span> nodes<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                index <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> right <span class="token operator">!=</span> self<span class="token punctuation">.</span>NULL<span class="token punctuation">:</span>                    parent<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                            <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难发现，这个反序列化的代码逻辑也是标准的二叉树层级遍历的代码衍生出来的。我们的函数通过 <code>nodes[index]</code> 来计算左右子节点，接到父节点上并加入队列，一层一层地反序列化出来一棵二叉树。</p><h1 id="二叉搜索树心法（特性篇）"><a href="#二叉搜索树心法（特性篇）" class="headerlink" title="二叉搜索树心法（特性篇）"></a>二叉搜索树心法（特性篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/">1038. Binary Search Tree to Greater Sum Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a></td><td align="center"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></td><td align="center">🟠</td></tr></tbody></table><p>前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树结构基础</a></li><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的 DFS&#x2F;BFS 遍历</a></li></ul><p>前文手把手带你刷二叉树已经写了 <a href="https://labuladong.online/algo/data-structure/binary-tree-part1/">思维篇</a>，<a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">构造篇</a>，<a href="https://labuladong.online/algo/data-structure/binary-tree-part3/">后序篇</a> 和 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">序列化篇</a>。</p><p>今天开启二叉搜索树（Binary Search Tree，后文简写 BST）的系列文章，手把手带你刷 BST。</p><p>首先，BST 的特性大家应该都很熟悉了（详见基础知识章节的 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础</a>）：</p><p>1、对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。</p><p>2、对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</p><p>二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p><p><strong>从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</strong>。</p><p>也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    <span class="token comment"># 中序遍历代码位置</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么根据这个性质，我们来做两道算法题。</p><h2 id="寻找第-K-小的元素"><a href="#寻找第-K-小的元素" class="headerlink" title="寻找第 K 小的元素"></a><a href="https://labuladong.online/algo/data-structure/bst-part1/#%E5%AF%BB%E6%89%BE%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">寻找第 K 小的元素</a></h2><p>这是力扣第 230 题「<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第 K 小的元素</a>」，看下题目：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">230. 二叉搜索树中第K小的元素</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉搜索树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>，请你设计一个算法查找其中第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><strong style="font-weight: 600;">&nbsp;</strong>小的元素（从 1 开始计数）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/28/kthtree1.jpg" style="max-width: 100%; width: 212px; height: 301px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,1,4,null,2], k = 1<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/28/kthtree2.jpg" style="max-width: 100%; width: 382px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,3,6,2,4,null,null,1], k = 3<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>小的值，你将如何优化算法？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 230. 二叉搜索树中第K小的元素</a>。</strong></details><p>这个需求很常见吧，一个直接的思路就是升序排序，然后找第 <code>k</code> 个元素呗。BST 的中序遍历其实就是升序排序的结果，找第 <code>k</code> 个元素肯定不是什么难事。</p><p>按照这个思路，可以直接写出代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录结果</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 记录当前元素的排名</span>        self<span class="token punctuation">.</span>rank <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 利用 BST 的中序遍历特性</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token comment"># 中序代码位置</span>        self<span class="token punctuation">.</span>rank <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">:</span>            <span class="token comment"># 找到第 k 小的元素</span>            self<span class="token punctuation">.</span>res <span class="token operator">=</span> root<span class="token punctuation">.</span>val            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_kth-smallest-element-in-a-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_kth-smallest-element-in-a-bst" src="https://labuladong.online/algo-visualize/leetcode/kth-smallest-element-in-a-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这道题就做完了，不过呢，还是要多说几句，因为这个解法并不是最高效的解法，而是仅仅适用于这道题。</p><p>我们后文 <a href="https://labuladong.online/algo/practice-in-action/find-median-from-data-stream/">高效计算数据流的中位数</a> 中就提过今天的这个问题：</p><p>Info</p><p>如果让你实现一个在二叉搜索树中通过排名计算对应元素的方法 <code>select(int k)</code>，你会怎么设计？</p><p>如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第 <code>k</code> 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)<em>O</em>(<em>N</em>)，<code>N</code> 是 BST 的节点个数。</p><p>要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 O(logN)<em>O</em>(<em>l<strong>o</strong>g**N</em>) 的复杂度，让你算一个第 <code>k</code> 小元素，时间复杂度竟然要 O(N)<em>O</em>(<em>N</em>)，有点低效了。</p><p>所以说，计算第 <code>k</code> 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。</p><p>我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。</p><p>那么回到这个问题，想找到第 <code>k</code> 小的元素，或者说找到排名为 <code>k</code> 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p><p>比如说你让我查找排名为 <code>k</code> 的元素，当前节点知道自己排名第 <code>m</code>，那么我可以比较 <code>m</code> 和 <code>k</code> 的大小：</p><p>1、如果 <code>m == k</code>，显然就是找到了第 <code>k</code> 个元素，返回当前节点就行了。</p><p>2、如果 <code>k &lt; m</code>，那说明排名第 <code>k</code> 的元素在左子树，所以可以去左子树搜索第 <code>k</code> 个元素。</p><p>3、如果 <code>k &gt; m</code>，那说明排名第 <code>k</code> 的元素在右子树，所以可以去右子树搜索第 <code>k - m - 1</code> 个元素。</p><p>这样就可以将时间复杂度降到 O(logN)<em>O</em>(<em>l<strong>o</strong>g**N</em>) 了。</p><p>那么，如何让每一个节点知道自己的排名呢？</p><p>这就是我们之前说的，需要在二叉树节点中维护额外信息。<strong>每个节点需要记录，以自己为根的这棵二叉树有多少个节点</strong>。</p><p>也就是说，我们 <code>TreeNode</code> 中的字段应该如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token comment"># 以该节点为根的树的节点总数</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了 <code>size</code> 字段，外加 BST 节点左小右大的性质，对于每个节点 <code>node</code> 就可以通过 <code>node.left</code> 推导出 <code>node</code> 的排名，从而做到我们刚才说到的对数级算法。</p><p>当然，<code>size</code> 字段需要在增删元素的时候需要被正确维护，力扣提供的 <code>TreeNode</code> 是没有 <code>size</code> 这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。</p><h2 id="BST-转化累加树"><a href="#BST-转化累加树" class="headerlink" title="BST 转化累加树"></a><a href="https://labuladong.online/algo/data-structure/bst-part1/#bst-%E8%BD%AC%E5%8C%96%E7%B4%AF%E5%8A%A0%E6%A0%91">BST 转化累加树</a></h2><p>力扣第 538 题和 1038 题都是这道题，完全一样，你可以把它们一块做掉。看下题目：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">538. 把二叉搜索树转换为累加树</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/convert-bst-to-greater-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出二叉<strong style="font-weight: 600;"><span>&nbsp;</span>搜索<span>&nbsp;</span></strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node.val</code>&nbsp;的值之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;">提醒一下，二叉搜索树满足下列约束条件：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点的左子树仅包含键<strong style="font-weight: 600;"><span>&nbsp;</span>小于<span>&nbsp;</span></strong>节点键的节点。</li><li>节点的右子树仅包含键<strong style="font-weight: 600;"><span>&nbsp;</span>大于</strong><span>&nbsp;</span>节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong>本题和 1038:&nbsp;<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a><span>&nbsp;</span>相同</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/05/03/tree.png" style="max-width: 100%; height: 364px; width: 534px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<strong style="font-weight: 600;">输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,null,1]<strong style="font-weight: 600;">输出：</strong>[1,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,2]<strong style="font-weight: 600;">输出：</strong>[3,3,2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,2,4,1]<strong style="font-weight: 600;">输出：</strong>[7,9,4,10]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li><li>每个节点的值介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup></code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code>&nbsp;之间。</li><li>树中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong><span>&nbsp;</span>。</li><li>给定的树为二叉搜索树。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 538. 把二叉搜索树转换为累加树</a>。</strong></details><p>题目应该不难理解，比如图中的节点 5，转化成累加树的话，比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8&#x3D;26。</p><p>我们需要把 BST 转化成累加树，函数签名如下：</p><pre class="line-numbers language-none"><code class="language-none">def convertBST(root: TreeNode) -&gt; TreeNode:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照二叉树的通用思路，需要思考每个节点应该做什么，但是这道题上很难想到什么思路。</p><p>BST 的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？</p><p>这是不行的。对于一个节点来说，确实右子树都是比它大的元素，但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。</p><p><strong>此路不通，我们不妨换一个思路，还是利用 BST 的中序遍历特性</strong>。</p><p>刚才我们说了 BST 的中序遍历代码可以升序打印节点的值，那如果我想降序打印节点的值怎么办？</p><p>很简单，只要把递归顺序改一下，先遍历右子树，后遍历左子树就行了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># 先递归遍历右子树</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 中序遍历代码位置</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token comment"># 后递归遍历左子树</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 <code>sum</code>，然后把 <code>sum</code> 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗</strong>？</p><p>看下代码就明白了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 记录累加和</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">def</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 维护累加和</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>val            <span class="token comment"># 将 BST 转化成累加树</span>            root<span class="token punctuation">.</span>val <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_convert-bst-to-greater-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_convert-bst-to-greater-tree" src="https://labuladong.online/algo-visualize/leetcode/convert-bst-to-greater-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这道题就解决了，核心还是 BST 的中序遍历特性，只不过我们修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。</p><p>简单总结下吧，BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。</p><h1 id="二叉搜索树心法（基操篇）"><a href="#二叉搜索树心法（基操篇）" class="headerlink" title="二叉搜索树心法（基操篇）"></a>二叉搜索树心法（基操篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></td><td align="center"><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td><td align="center">🟢</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></td><td align="center">🟠</td></tr></tbody></table><p>我们前文 <a href="https://labuladong.online/algo/data-structure/bst-part1/">二叉搜索树心法（特性篇）</a> 介绍了 BST 的基本特性，还利用二叉搜索树「中序遍历有序」的特性来解决了几道题目，本文来实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中「删」和「判断合法性」略微复杂。</p><p>BST 的基础操作主要依赖「左小右大」的特性，可以在二叉树中做类似二分搜索的操作，寻找一个元素的效率很高。比如下面这就是一棵合法的二叉树：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/0.png" alt="img"></p><p>对于 BST 相关的问题，你可能会经常看到类似下面这样的代码逻辑：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">BST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">:</span>        <span class="token comment"># 找到目标，做点什么</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>        BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> target<span class="token punctuation">:</span>        BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。接下来看下 BST 这种结构的基础操作是如何实现的。</p><h2 id="一、判断-BST-的合法性"><a href="#一、判断-BST-的合法性" class="headerlink" title="一、判断 BST 的合法性"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E4%B8%80%E3%80%81%E5%88%A4%E6%96%AD-bst-%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7">一、判断 BST 的合法性</a></h2><p>力扣第 98 题「<a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a>」就是让你判断输入的 BST 是否合法：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">98. 验证二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/validate-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/validate-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，判断其是否是一个有效的二叉搜索树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">有效</strong><span>&nbsp;</span>二叉搜索树定义如下：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点的左<span data-keyword="subtree">子树</span>只包含<strong style="font-weight: 600;"><span>&nbsp;</span>小于<span>&nbsp;</span></strong>当前节点的数。</li><li>节点的右子树只包含<span>&nbsp;</span><strong style="font-weight: 600;">大于</strong><span>&nbsp;</span>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/01/tree1.jpg" style="max-width: 100%; width: 302px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,3]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/01/tree2.jpg" style="max-width: 100%; width: 422px; height: 292px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,1,4,null,null,3,6]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目范围在<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 98. 验证二叉搜索树</a>。</strong></details><p>注意，这里是有坑的哦。按照 BST 左小右大的特性，每个节点想要判断自己是否是合法的 BST 节点，要做的事不就是比较自己和左右孩子吗？感觉应该这样写代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># root 的左边应该更小</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment"># root 的右边应该更大</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的<strong>所有</strong>节点，下面这个二叉树显然不是 BST，因为节点 <code>7</code> 的左子树中有一个节点 <code>8</code>，但是我们的算法会把它判定为合法 BST：</p><p>7418910</p><p><strong>错误的原因在于，对于每一个节点 <code>root</code>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，<code>root</code> 的整个左子树都要小于 <code>root.val</code>，整个右子树都要大于 <code>root.val</code></strong>。</p><p>问题是，对于某一个节点 <code>root</code>，他只能管得了自己的左右子节点，怎么把 <code>root</code> 的约束传递给左右子树呢？请看正确的代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment"># 定义：该函数返回 root 为根的子树的所有节点是否满足 max.val > root.val > min.val</span>    <span class="token keyword">def</span> <span class="token function">_isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment"># 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span>        <span class="token keyword">if</span> <span class="token builtin">min</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> <span class="token builtin">min</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> <span class="token builtin">max</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">>=</span> <span class="token builtin">max</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 根据定义，限定左子树的最大值是 root.val，右子树的最小值是 root.val</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>_isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_validate-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_validate-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/validate-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧。</p><h2 id="在-BST-中搜索元素"><a href="#在-BST-中搜索元素" class="headerlink" title="在 BST 中搜索元素"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E5%9C%A8-bst-%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%85%83%E7%B4%A0">在 BST 中搜索元素</a></h2><p>力扣第 700 题「<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a>」就是让你在 BST 中搜索值为 <code>target</code> 的节点，函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是在一棵普通的二叉树中寻找，可以这样写代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> root    <span class="token comment"># 当前节点没找到就递归地去左右子树寻找</span>    left <span class="token operator">=</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    right <span class="token operator">=</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有二叉树。那么应该如何充分利用 BST 的特殊性，把「左小右大」的特性用上？</p><p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 <code>target</code> 和 <code>root.val</code> 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：在以 root 为根的 BST 中搜索值为 target 的节点，返回该节点</span><span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>    <span class="token comment"># 如果二叉树为空，直接返回</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token comment"># 去左子树搜索</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token comment"># 去右子树搜索</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token comment"># 当前节点就是目标值</span>    <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_search-in-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_search-in-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/search-in-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="在-BST-中插入一个数"><a href="#在-BST-中插入一个数" class="headerlink" title="在 BST 中插入一个数"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E5%9C%A8-bst-%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0">在 BST 中插入一个数</a></h2><p>对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p>因为 BST 一般不会存在值重复的节点，所以我们一般不会在 BST 中插入已存在的值。<strong>下面的代码都默认不会向 BST 中插入已存在的值</strong>。</p><p>上一个问题，我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。</p><p><strong>一旦涉及「改」，就类似二叉树的构造问题，函数要返回 <code>TreeNode</code> 类型，并且要对递归调用的返回值进行接收</strong>。</p><p>力扣第 701 题「<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a>」就是这个问题：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">701. 二叉搜索树中的插入操作</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉搜索树（BST）的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;和要插入树中的值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">value</code>&nbsp;，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据<span>&nbsp;</span><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>，新值和原始二叉搜索树中的任意节点值都不同。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回<span>&nbsp;</span><strong style="font-weight: 600;">任意有效的结果</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/05/insertbst.jpg" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,2,7,1,3], val = 5<strong style="font-weight: 600;">输出：</strong>[4,2,7,1,3,5]<strong style="font-weight: 600;">解释：</strong>另一个满足题目要求可以通过的树是：<img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/05/bst.jpg" style="max-width: 100%;"></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [40,20,60,10,30,50,70], val = 25<strong style="font-weight: 600;">输出：</strong>[40,20,60,10,30,50,70,null,null,25]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,2,7,1,3,null,null,null,null,null,null], val = 5<strong style="font-weight: 600;">输出：</strong>[4,2,7,1,3,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数将在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,&nbsp;10<sup>4</sup>]</code>的范围内。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>8</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>8</sup></code></li><li>所有值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;是&nbsp;<strong style="font-weight: 600;">独一无二</strong>&nbsp;的。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>8</sup>&nbsp;&lt;= val &lt;= 10<sup>8</sup></code></li><li><strong style="font-weight: 600;">保证</strong>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code>&nbsp;在原始BST中不存在。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 701. 二叉搜索树中的插入操作</a>。</strong></details><p>直接看解法代码吧，可以结合注释和可视化面板的来理解：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：在以 root 为根的 BST 中插入 val 节点，返回插入后的根节点</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>            <span class="token comment"># 找到空位置插入新节点</span>            <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 去右子树找插入位置</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token comment"># 去左子树找插入位置</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token comment"># 返回 root，上层递归会接收返回值作为子节点</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_insert-into-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_insert-into-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/insert-into-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="三、在-BST-中删除一个数"><a href="#三、在-BST-中删除一个数" class="headerlink" title="三、在 BST 中删除一个数"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E4%B8%89%E3%80%81%E5%9C%A8-bst-%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%95%B0">三、在 BST 中删除一个数</a></h2><p>力扣第 450 题「<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a>」就是让你在 BST 中删除一个值为 <code>key</code> 的节点：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">450. 删除二叉搜索树中的节点</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/delete-node-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/delete-node-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉搜索树的根节点<span>&nbsp;</span><strong style="font-weight: 600;">root<span>&nbsp;</span></strong>和一个值<span>&nbsp;</span><strong style="font-weight: 600;">key</strong>，删除二叉搜索树中的&nbsp;<strong style="font-weight: 600;">key&nbsp;</strong>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一般来说，删除节点可分为两个步骤：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2020/09/04/del_node_1.jpg" style="max-width: 100%; width: 800px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,3,6,2,4,null,7], key = 3<strong style="font-weight: 600;">输出：</strong>[5,4,6,2,null,null,7]<strong style="font-weight: 600;">解释：</strong>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。<img src="https://labuladong.online/algo/images/lc/uploads/2020/09/04/del_node_supp.jpg" style="max-width: 100%; width: 350px;"></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [5,3,6,2,4,null,7], key = 0<strong style="font-weight: 600;">输出:</strong> [5,3,6,2,4,null,7]<strong style="font-weight: 600;">解释:</strong> 二叉树不包含值为 0 的节点</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [], key = 0<strong style="font-weight: 600;">输出:</strong> []</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数的范围&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 10<sup>4</sup>]</code>.</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li><li>节点值唯一</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;是合法的二叉搜索树</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= key &lt;= 10<sup>5</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong><span>&nbsp;</span>要求算法时间复杂度为&nbsp;O(h)，h 为树的高度。</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 450. 删除二叉搜索树中的节点</a>。</strong></details><p>这个问题稍微复杂，跟插入操作类似，先「找」再「改」，先把框架写出来再说：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">:</span>        <span class="token comment"># 找到啦，进行删除</span>    <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> key<span class="token punctuation">:</span>        <span class="token comment"># 去左子树找</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>        <span class="token comment"># 去右子树找</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>找到目标节点了，比方说是节点 <code>A</code>，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p><p><strong>情况 1</strong>：<code>A</code> 恰好是末端节点，两个子节点都为空，那么它可以直接被删除。</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/bst_deletion_case_1.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;</span><span class="token operator">&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>情况 2</strong>：<code>A</code> 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/bst_deletion_case_2.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 排除了情况 <span class="token number">1</span> 之后<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>情况 3</strong>：<code>A</code> 有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code> 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/bst_deletion_case_3.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;</span><span class="token operator">&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">//</span> 找到右子树的最小节点    TreeNode minNode <span class="token operator">=</span> getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 把 root 改成 minNode    root<span class="token punctuation">.</span>val <span class="token operator">=</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token operator">//</span> 转而去删除 minNode    root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种情况分析完毕，填入框架，简化一下代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：在以 root 为根的 BST 中删除值为 key 的节点，返回完成删除后的根节点</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">:</span>            <span class="token comment"># 这两个 if 把情况 1 和 2 都正确处理了</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root<span class="token punctuation">.</span>right            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root<span class="token punctuation">.</span>left            <span class="token comment"># 处理情况 3</span>            <span class="token comment"># 获得右子树最小的节点</span>            minNode <span class="token operator">=</span> self<span class="token punctuation">.</span>getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 删除右子树最小的节点</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 用右子树最小的节点替换 root 节点</span>            minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left            minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right            root <span class="token operator">=</span> minNode        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> key<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># BST 最左边的就是最小的</span>        <span class="token keyword">while</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left        <span class="token keyword">return</span> node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_delete-node-in-a-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_delete-node-in-a-bst" src="https://labuladong.online/algo-visualize/leetcode/delete-node-in-a-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，删除操作就完成了。注意一下，上述代码在处理情况 3 时通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 处理情况 <span class="token number">3</span><span class="token operator">//</span> 获得右子树最小的节点TreeNode minNode <span class="token operator">=</span> getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 删除右子树最小的节点root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 用右子树最小的节点替换 root 节点minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>root <span class="token operator">=</span> minNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有的读者可能会疑惑，替换 <code>root</code> 节点为什么这么麻烦，直接改 <code>val</code> 字段不就行了？看起来还更简洁易懂：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 处理情况 <span class="token number">3</span><span class="token operator">//</span> 获得右子树最小的节点TreeNode minNode <span class="token operator">=</span> getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 删除右子树最小的节点root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 用右子树最小的节点替换 root 节点root<span class="token punctuation">.</span>val <span class="token operator">=</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅对于这道算法题来说是可以的，但这样操作并不完美，我们一般不会通过修改节点内部的值来交换节点。因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。</p><p>最后简单总结一下吧，通过这篇文章，我们总结出了如下几个技巧：</p><p>1、如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p><p>2、掌握 BST 的增删查改方法。</p><p>3、递归修改数据结构时，需要对递归调用的返回值进行接收，并返回修改后的节点。</p>]]></content>
      
      
      <categories>
          
          <category> 二叉树算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/28/pip-pei-zhi/"/>
      <url>/2025/06/28/pip-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>如果想永久使用清华镜像，可以修改 pip 配置文件：</p><p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【练习】单调队列的通用实现及经典习题</title>
      <link href="/2025/06/14/lian-xi-dan-diao-dui-lie-de-tong-yong-shi-xian-ji-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-dan-diao-dui-lie-de-tong-yong-shi-xian-ji-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】单调队列的通用实现及经典习题"><a href="#【练习】单调队列的通用实现及经典习题" class="headerlink" title="【练习】单调队列的通用实现及经典习题"></a>【练习】单调队列的通用实现及经典习题</h1><h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0">通用实现</a></h2><p>我先提供一个单调队列结构的通用实现，这里涉及 Java 的泛型，<code>E</code> 就代表任意类型，<code>E extends Comparable&lt;E&gt;</code> 的意思是这个类型 <code>E</code> 需要实现 <code>Comparable</code> 接口，即类型 <code>E</code> 是可比较的，比如 <code>Integer, String</code> 这种实现了 <code>compareTo</code> 方法的类型。原因也很好理解，因为你要求队列中元素的最值嘛，所以元素当然得是有大小之分（可比较）的。</p><p>我们原先的简陋实现包含了 <code>max</code> 方法的实现，其原理是在底层维护了一个队列 <code>maxq</code>，维护这个队列中从尾部到头部的元素单调递增。</p><p>那么实现 <code>min</code> 方法也是类似的，可以<strong>在底层再维护一个 <code>minq</code> 队列</strong>，维护队列中元素从尾部到头部的元素单调递减，这样头部第一个元素就是所有元素中的最小值了。</p><p>当然，由于 <code>push</code> 方法在添加元素的同时还可能会删除元素，所以 <code>maxq</code> 和 <code>minq</code> 中都没有保存所有元素。如果想实现标准的 <code>pop</code> 方法以及 <code>size</code> 方法，<strong>我们还得再额外维护一个标准队列 <code>q</code></strong>，这个 <code>q</code> 存储所有存在于队列中的元素，不维护单调性。</p><p>综上，可以得到 <code>MonotonicQueue</code> 的通用实现，具体逻辑看注释：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> TypeVar<span class="token punctuation">,</span> GenericE <span class="token operator">=</span> TypeVar<span class="token punctuation">(</span><span class="token string">'E'</span><span class="token punctuation">)</span><span class="token comment"># 单调队列的实现，可以高效维护最大值和最小值</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">(</span>Generic<span class="token punctuation">[</span>E<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 常规队列，存储所有元素</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> E<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> E<span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> E<span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> E<span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">assert</span> deleteVal <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这个通用实现内部维护了三个队列，且涉及到 Java 的泛型，所以在刷题平台上执行的效率不会高，如果你追求效率的话，可以根据具体的题目简化单调队列的实现，从而提升效率。下面看几道单调队列的经典应用。</p><h2 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列 + 滑动窗口"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">单调队列 + 滑动窗口</a></h2><p>单调队列可以和 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口</a> 算法结合，在窗口滑动的过程中快速计算窗口内部的最值。</p><hr><h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit">1438. 绝对差不超过限制的最长连续子数组</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1438. 绝对差不超过限制的最长连续子数组</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>，和一个表示限制的整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">limit</code><em><span>&nbsp;</span>。</em></p><p style="line-height: 1.6; overflow-wrap: break-word;">如果不存在满足条件的子数组，则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [8,2,4,7], limit = 4<strong style="font-weight: 600;">输出：</strong>2 <strong style="font-weight: 600;">解释：</strong>所有子数组如下：[8] 最大绝对差 |8-8| = 0 &lt;= 4.[8,2] 最大绝对差 |8-2| = 6 &gt; 4. [8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.[2] 最大绝对差 |2-2| = 0 &lt;= 4.[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.[4] 最大绝对差 |4-4| = 0 &lt;= 4.[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.[7] 最大绝对差 |7-7| = 0 &lt;= 4. 因此，满足题意的最长子数组的长度为 2 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [10,1,2,4,7,2], limit = 5<strong style="font-weight: 600;">输出：</strong>4 <strong style="font-weight: 600;">解释：</strong>满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [4,2,2,2,4,4,2,2], limit = 0<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums[i] &lt;= 10^9</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= limit &lt;= 10^9</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1438. 绝对差不超过限制的最长连续子数组</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>很明显这道题需要用到前文讲的 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口技巧核心框架详解</a>：</p><p>当窗口内绝对值之差不超过 <code>limit</code> 时扩大窗口，当新加入窗口的元素使得绝对值之差超过 <code>limit</code> 时开始收缩窗口，窗口的最大宽度即最长子数组的长度。</p><p>但有个问题，当窗口进新元素时，我可以更新窗口中的最大值和最小值，但当窗口收缩时，如何更新最大值和最小值呢？难道要遍历一遍窗口中的所有元素吗？这就用到单调队列结构了，这里需要一个通用的 <code>MonotonicQueue</code> 类，用来高效判断窗口中的最大值和最小值。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token number">0</span>        windowSize <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 滑动窗口模板</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 扩大窗口，更新窗口最值</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            windowSize <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> window<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> window<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> limit<span class="token punctuation">:</span>                <span class="token comment"># 缩小窗口，更新窗口最值</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                windowSize <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token comment"># 在窗口收缩判断完之后才更新答案</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> windowSize<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 常规队列，存储所有元素</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" src="https://labuladong.online/algo-visualize/leetcode/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="862-和至少为-K-的最短子数组"><a href="#862-和至少为-K-的最短子数组" class="headerlink" title="862. 和至少为 K 的最短子数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_shortest-subarray-with-sum-at-least-k">862. 和至少为 K 的最短子数组</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">862. 和至少为 K 的最短子数组</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>，找出<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>中和至少为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">最短非空子数组</strong><span>&nbsp;</span>，并返回该子数组的长度。如果不存在这样的<span>&nbsp;</span><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>是数组中<span>&nbsp;</span><strong style="font-weight: 600;">连续</strong><span>&nbsp;</span>的一部分。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1], k = 1<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,2], k = 4<strong style="font-weight: 600;">输出：</strong>-1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [2,-1,2], k = 3<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= 10<sup>9</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 862. 和至少为 K 的最短子数组</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这题的难度是比较大的，难点在于同时结合了 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法</a>、<a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 和 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列</a> 几个知识点，建议你先理解这三篇文章的要义，否则看不懂这题的解法。</p><p>首先，想要快速记录子数组的和，需要 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 预计算一个 <code>preSum</code> 数组，然后在这个 <code>preSum</code> 数组上施展 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法</a> 寻找一个差值大于等于 <code>k</code> 且宽度最小的「窗口」，这个窗口的大小就是题目想要的结果。</p><p>这里面还有个问题，当滑动窗口扩大时，新进入窗口的元素 <code>preSum[right]</code> 需要知道窗口中最小的那个元素是多少，和最小的那个元素相减才能得到尽可能大的子数组和。</p><p>如何快速判断窗口中的最值？这就需要单调队列结构出马了，直接看解法代码吧。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">shortestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 看题目的数据范围，前缀和数组中元素可能非常大，所以用 long 类型</span>        preSum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        preSum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 计算 nums 的前缀和数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment"># 单调队列结构辅助滑动窗口算法</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        right <span class="token operator">=</span> <span class="token number">0</span>        left <span class="token operator">=</span> <span class="token number">0</span>        length <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 开始执行滑动窗口算法框架</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 扩大窗口，元素入队</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>preSum<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 若新进入窗口的元素和窗口中的最小值之差大于等于 k，</span>            <span class="token comment"># 说明得到了符合条件的子数组，缩小窗口，使子数组长度尽可能小</span>            <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> window<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> preSum<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">-</span> window<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> k<span class="token punctuation">:</span>                <span class="token comment"># 更新答案</span>                length <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> right <span class="token operator">-</span> left<span class="token punctuation">)</span>                <span class="token comment"># 缩小窗口</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> length<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 常规队列，存储所有元素</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum">209. 长度最小的子数组 🟠</a></li><li><a href="https://leetcode.cn/problems/2VG8Kg">剑指 Offer II 008. 和大于等于 target 的最短子数组 🟠</a></li></ul><hr><h2 id="单调队列-环形数组"><a href="#单调队列-环形数组" class="headerlink" title="单调队列 + 环形数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84">单调队列 + 环形数组</a></h2><p>单调队列还可以在环形数组的场景下排上用场。之前 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈原理</a> 中讲了只要把数组的长度 <code>n</code> 加倍就可以模拟环形数组，但如果让你在环形数组中计算子数组的元素和就需要单调队列辅助了，因为你要保证子数组的长度不能超过 <code>n</code>。</p><hr><h2 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_maximum-sum-circular-subarray">918. 环形子数组的最大和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">918. 环形子数组的最大和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个长度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>的<strong style="font-weight: 600;">环形整数数组</strong>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;，返回<em>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;的非空<span>&nbsp;</span><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>的最大可能和&nbsp;</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">环形数组</strong><em>&nbsp;</em>意味着数组的末端将会与开头相连呈环状。形式上，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code><span>&nbsp;</span>的下一个元素是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[(i + 1) % n]</code><span>&nbsp;</span>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code>&nbsp;的前一个元素是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[(i - 1 + n) % n]</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>最多只能包含固定缓冲区&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;中的每个元素一次。形式上，对于子数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i], nums[i + 1], ..., nums[j]</code>&nbsp;，不存在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt;= k1, k2 &lt;= j</code>&nbsp;其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k1 % n == k2 % n</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,-2,3,-2]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>从子数组 [3] 得到最大和 3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [5,-3,5]<strong style="font-weight: 600;">输出：</strong>10<strong style="font-weight: 600;">解释：</strong>从子数组 [5,5] 得到最大和 5 + 5 = 10</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [3,-2,2,-3]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == nums.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-3 * 10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 918. 环形子数组的最大和</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>诚然，这道题有很巧妙的方法，你可以搜索一下「Kadane 算法」来解决这道题。不过为了举一反三地运用我之前讲过的算法技巧，我就结合 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列结构</a> 和前文 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 写一个更通用的解法。</p><p>首先，这道题和 <a href="https://leetcode.cn/problems/maximum-subarray">53. 最大子序和</a> 非常类似，区别在于本题的数组是环形的，所以上一题的动态规划思路和前缀和思路都不能直接套用过来。不过前文 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈结构详解</a> 中讲过处理环形数组的方法，其实就是把原数组大小扩大一倍，这样就能模拟出环形的效果了。</p><p>那么本题也可以把 <code>nums</code> 数组扩大一倍，计算前缀和数组 <code>preSum</code>，借助一个定长为 <code>nums.length</code> 的单调队列来计算环形数组中的最大子数组和。具体实现直接看代码吧。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubarraySumCircular</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 模拟环状的 nums 数组</span>        preSum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        preSum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 计算环状 nums 的前缀和</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span>        <span class="token comment"># 记录答案</span>        maxSum <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 维护一个滑动窗口，以便根据窗口中的最小值计算最大子数组和</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        window<span class="token punctuation">.</span>push<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxSum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> window<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 维护窗口的大小为 nums 数组的大小</span>            <span class="token keyword">if</span> window<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">:</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> maxSum<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 常规队列，存储所有元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-sum-circular-subarray" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-sum-circular-subarray" src="https://labuladong.online/algo-visualize/leetcode/maximum-sum-circular-subarray/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><hr><h2 id="单调队列-动态规划（选学）"><a href="#单调队列-动态规划（选学）" class="headerlink" title="单调队列 + 动态规划（选学）"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%89%E5%AD%A6">单调队列 + 动态规划（选学）</a></h2><p>动态规划很多时候会用到嵌套 for 循环计算最值，如果是计算一个窗口中的最值，可以利用单调队列结构维护最值，从而消除一层 for 循环，降低时间复杂度。</p><hr><h2 id="1696-跳跃游戏-VI"><a href="#1696-跳跃游戏-VI" class="headerlink" title="1696. 跳跃游戏 VI"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_jump-game-vi">1696. 跳跃游戏 VI</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1696. 跳跃游戏 VI</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/jump-game-vi/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/jump-game-vi/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始的整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一开始你在下标<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>处。每一步，你最多可以往前跳<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>步，但你不能跳出数组的边界。也就是说，你可以从下标<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>跳到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[i + 1， min(n - 1, i + k)]</code><span>&nbsp;</span><strong style="font-weight: 600;">包含</strong><span>&nbsp;</span>两个端点的任意位置。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你的目标是到达数组最后一个位置（下标为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n - 1</code><span>&nbsp;</span>），你的<span>&nbsp;</span><strong style="font-weight: 600;">得分</strong><span>&nbsp;</span>为经过的所有数字之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回你能得到的<span>&nbsp;</span><strong style="font-weight: 600;">最大得分</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>nums = [<strong style="font-weight: 600;">1</strong>,<strong style="font-weight: 600;">-1</strong>,-2,<strong style="font-weight: 600;">4</strong>,-7,<strong style="font-weight: 600;">3</strong>], k = 2<b>输出：</b>7<b>解释：</b>你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [<strong style="font-weight: 600;">10</strong>,-5,-2,<strong style="font-weight: 600;">4</strong>,0,<strong style="font-weight: 600;">3</strong>], k = 3<b>输出：</b>17<b>解释：</b>你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>nums = [1,-5,-20,4,-1,3,-6,-3], k = 2<b>输出：</b>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/jump-game-vi/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1696. 跳跃游戏 VI</a>。</strong></details><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这题和 <a href="https://leetcode.cn/problems/constrained-subsequence-sum">1425. 带限制的子序列和</a> 非常像：</p><p>1425 题是让你求最大子序列和，子序列中每两个元素之间的间隔不能超过 <code>k</code>；这道题其实也是让你求元素间隔不超过 <code>k</code> 的最大子序列和，只不过又多了些限制，即子序列的第一个元素必须是 <code>nums[0]</code>，最后一个元素必须是 <code>nums[-1]</code>。</p><p>你可以想办法复用第 1425 题的解法，不过我这里按照标准的 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划解题框架</a> 来逐步优化，最后通过 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列结构</a> 中给出的单调队列通用实现来优化动态规划解法的效率。</p><p>需要注意的是，本题使用标准的动态规划解法也会超时，这并不是动态规划的锅，而是本题给的数据规模太大，需要更先进的数据结构（单调队列）来优化状态转移的效率。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 第一步，暴力递归解法（超时）</span><span class="token keyword">class</span> <span class="token class-name">Solution1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>    <span class="token comment"># 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span>    <span class="token comment"># 能跳到 nums[p]，必然是从 nums[p-k..p-1] 中的某个位置跳来的</span>    <span class="token comment"># 故状态转移方程为：dp[p] = max(nums[p-k..p-1]) + nums[p]</span>    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> p <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 实现状态转移方程</span>        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">-</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">+=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span class="token comment"># 第二步，带备忘录的递归解法（超时）</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token comment"># 备忘录</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># 备忘录初始化为最小值</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>    <span class="token comment"># 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span>    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> p <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 查备忘录，避免冗余计算</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token comment"># 实现状态转移方程，结果存入备忘录</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">-</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token comment"># 第三步，自顶向下的递归改为自底向上的迭代解法（超时）</span><span class="token keyword">class</span> <span class="token class-name">Solution3</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 定义：到达 nums[p] 的最大分数为 dp[p]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># dp 数组初始化为最小值</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 状态转移</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p <span class="token operator">-</span> i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>p <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 第四步，利用单调队列结构消除内层循环（通过）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 定义：到达 nums[p] 的最大分数为 dp[p]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># dp 数组初始化为最小值</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 状态转移</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>            <span class="token comment"># 维护窗口装着 dp[p-1..p-k]</span>            <span class="token keyword">if</span> window<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 常规队列，存储所有元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_jump-game-vi" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_jump-game-vi" src="https://labuladong.online/algo-visualize/leetcode/jump-game-vi/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1425-带限制的子序列和"><a href="#1425-带限制的子序列和" class="headerlink" title="1425. 带限制的子序列和"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_constrained-subsequence-sum">1425. 带限制的子序列和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1425. 带限制的子序列和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/constrained-subsequence-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/constrained-subsequence-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;和一个整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code>&nbsp;，请你返回<span>&nbsp;</span><strong style="font-weight: 600;">非空</strong>&nbsp;子序列元素和的最大值，子序列需要满足：子序列中每两个<span>&nbsp;</span><strong style="font-weight: 600;">相邻</strong>&nbsp;的整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[j]</code>&nbsp;，它们在原数组中的下标&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;满足&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt; j</code>&nbsp;且<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j - i &lt;= k</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [10,2,-10,5,20], k = 2<strong style="font-weight: 600;">输出：</strong>37<strong style="font-weight: 600;">解释：</strong>子序列为 [10, 2, 5, 20] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [-1,-2,-3], k = 1<strong style="font-weight: 600;">输出：</strong>-1<strong style="font-weight: 600;">解释：</strong>子序列必须是非空的，所以我们选择最大的数字。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [10,-2,-10,-5,20], k = 2<strong style="font-weight: 600;">输出：</strong>23<strong style="font-weight: 600;">解释：</strong>子序列为 [10, -2, -5, 20] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10^4&nbsp;&lt;= nums[i] &lt;= 10^4</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/constrained-subsequence-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1425. 带限制的子序列和</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>如果你看过后文 <a href="https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/">最长递增子序列问题详解</a>，那么这道题的思路应该是很简单的：</p><p><strong>设计一个 <code>dp</code> 数组，<code>dp[i]</code> 表示以 <code>nums[i]</code> 为结尾的最大子序列之和，然后题目要求的答案就是 <code>max(dp[..])</code></strong>。</p><p>由于题目说两个序列之间的间隔不能超过 <code>k</code>，所以 <code>dp[i]</code> 的值就可以根据 <code>dp[i-k..i-1]</code> 的值推导出来，那么状态转移逻辑就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        maxVal <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxVal <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想到这一步其实已经可以写出动态规划解法代码了，但由于测试数据的规模较大，这个 <code>O(KN)</code> 的算法会超时。</p><p>我们注意到内层的 for 循环实际上就是在计算 <code>dp[i-k..i-1]</code> 的最大值，随着 <code>i</code> 的增加，<code>dp[i-k..i-1]</code> 就像一个滑动前进的窗口，这个场景不需要傻乎乎用 for 循环遍历求最值，前文讲到的 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列</a> 可以高效实现这个过程，将整个算法的复杂度降低到 <code>O(N)</code>。</p><p>我将给出经过单调队列优化的解法代码和未经优化的解法代码，注意单调队列在其中起到的作用。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 经过单调队列优化的动态规划解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constrainedSubsetSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 定义：dp[i] 表示以 nums[i] 结尾的子序列的最大和</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 单调队列辅助计算 dp[i-k..i-1] 的最大值</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 状态转移方程</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 维护滑动窗口的大小为 k</span>            <span class="token keyword">if</span> window<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment"># dp 数组中的最大值就是结果</span>        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 常规队列，存储所有元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span class="token comment"># 未经优化的动态规划解法，超时</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constrainedSubsetSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 定义：dp[i] 表示以 nums[i] 结尾的子序列的最大和</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># base case，以 nums[0] 结尾的子序列只有它本身</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 状态转移方程</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            maxVal <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                maxVal <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># dp[i] 的值可以根据 dp[i-k..i-1] 的最大值推导出来</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxVal <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># dp 数组中的最大值就是结果</span>        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列结构解决滑动窗口问题</title>
      <link href="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/"/>
      <url>/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列结构解决滑动窗口问题"><a href="#单调队列结构解决滑动窗口问题" class="headerlink" title="单调队列结构解决滑动窗口问题"></a>单调队列结构解决滑动窗口问题</h1><p>前文用 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈解决三道算法问题</a> 介绍了单调栈这种特殊数据结构，本文写一个类似的数据结构「单调队列」。</p><p>也许这种数据结构的名字你没听过，其实没啥难的，就是一个「队列」，只是使用了一点巧妙的方法，使得队列中的元素全都是单调递增（或递减）的。</p><p>为啥要发明「单调队列」这种结构呢，主要是为了解决下面这个场景：</p><p><strong>给你一个数组 <code>window</code>，已知其最值为 <code>A</code>，如果给 <code>window</code> 中添加一个数 <code>B</code>，那么比较一下 <code>A</code> 和 <code>B</code> 就可以立即算出新的最值；但如果要从 <code>window</code> 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 <code>A</code>，就需要遍历 <code>window</code> 中的所有元素重新寻找新的最值</strong>。</p><p>这个场景很常见，但不用单调队列似乎也可以，比如 <a href="https://labuladong.online/algo/data-structure-basic/binary-heap-basic/">优先级队列（二叉堆）</a> 就是专门用来动态寻找最值的，我创建一个大（小）顶堆，不就可以很快拿到最大（小）值了吗？</p><p>如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的<strong>时间顺序</strong>，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。</p><p>所以，现在需要一种新的队列结构，既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，这就是「单调队列」结构。</p><p>「单调队列」这个数据结构主要用来辅助解决滑动窗口相关的问题，前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口核心框架</a> 把滑动窗口算法作为双指针技巧的一部分进行了讲解，但有些稍微复杂的滑动窗口问题不能只靠两个指针来解决，需要上更先进的数据结构。</p><p>比方说，你注意看前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口核心框架</a> 讲的几道题目，每当窗口扩大（<code>right++</code>）和窗口缩小（<code>left++</code>）时，你单凭移出和移入窗口的元素即可决定是否更新答案。</p><p>但本文开头说的那个判断一个窗口中最值的例子，你无法单凭移出窗口的那个元素更新窗口的最值，除非重新遍历所有元素，但这样的话时间复杂度就上来了，这是我们不希望看到的。</p><p>我们来看看力扣第 239 题「<a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a>」，就是一道标准的滑动窗口问题：</p><p>给你输入一个数组 <code>nums</code> 和一个正整数 <code>k</code>，有一个大小为 <code>k</code> 的窗口在 <code>nums</code> 上从左至右滑动，请你输出每次窗口中 <code>k</code> 个元素的最大值。</p><p>函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如说力扣给出的一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>解释：滑动窗口的位置                最大值<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>               <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">3</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">3</span> <span class="token number">1</span>  <span class="token number">3</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span><span class="token punctuation">]</span> <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">5</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span>  <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">5</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span><span class="token punctuation">]</span> <span class="token number">7</span>       <span class="token number">6</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span> <span class="token punctuation">[</span><span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span><span class="token punctuation">]</span>      <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们就借助单调队列结构，用 O(1)<em>O</em>(1) 时间算出每个滑动窗口中的最大值，使得整个算法在线性时间完成。</p><h3 id="一、搭建解题框架"><a href="#一、搭建解题框架" class="headerlink" title="一、搭建解题框架"></a><a href="https://labuladong.online/algo/data-structure/monotonic-queue/#%E4%B8%80%E3%80%81%E6%90%AD%E5%BB%BA%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6">一、搭建解题框架</a></h3><p>在介绍「单调队列」这种数据结构的 API 之前，先来对比一下 <a href="https://labuladong.online/algo/data-structure-basic/queue-stack-basic/">普通的队列</a> 的标准 API 和单调队列实现的 API：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 普通队列的 API</span><span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">:</span>    <span class="token comment"># enqueue 操作，在队尾加入元素 n</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># dequeue 操作，删除队头元素</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token comment"># 单调队列的 API</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 在队尾添加元素 n</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 返回当前队列中的最大值</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 队头元素如果是 n，删除它</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，单调队列这几个 API 的实现方法肯定跟一般的 Queue 不一样，不过我们暂且不管，而且认为这几个操作的时间复杂度都是 O(1)，先把这道「滑动窗口」问题的解答框架搭出来：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 先将窗口前 k - 1 填满</span>            window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 窗口开始向前滑动</span>            <span class="token comment"># 移入新元素</span>            window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 将当前窗口中的最大元素记入结果</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 移出最后的元素</span>            window<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 将 List 类型转化成 int[] 数组作为返回值</span>    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/1-1749878196844-7.png" alt="img"></p><p>这个思路很简单吧，下面我们开始重头戏，单调队列的实现。</p><h3 id="二、实现单调队列数据结构"><a href="#二、实现单调队列数据结构" class="headerlink" title="二、实现单调队列数据结构"></a><a href="https://labuladong.online/algo/data-structure/monotonic-queue/#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">二、实现单调队列数据结构</a></h3><p>观察滑动窗口的过程就能发现，实现「单调队列」必须使用一种数据结构支持在头部和尾部进行插入和删除，很明显 <a href="https://labuladong.online/algo/data-structure-basic/linkedlist-basic/">双链表</a> 是满足这个条件的。</p><p>「单调队列」的核心思路和「单调栈」类似，<code>push</code> 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用双端队列，支持头部和尾部增删元素</span>        <span class="token comment"># 维护其中的元素自尾部到头部单调递增</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 在尾部添加一个元素 n，维护 maxq 的单调性质</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 将前面小于自己的元素都删除</span>        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxq<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以想象，加入数字的大小代表人的体重，体重大的会把前面体重不足的压扁，直到遇到更大的量级才停住。</p><p><img src="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/3-1749878196844-9.png" alt="img"></p><p>如果每个元素被加入时都这样操作，最终单调队列中的元素大小就会保持一个<strong>单调递减</strong>的顺序，因此我们的 <code>max</code> 方法就很好写了，只要把队头元素返回即可；<code>pop</code> 方法也是操作队头，如果队头元素是待删除元素 <code>n</code>，那么就删除它：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 为了节约篇幅，省略上文给出的代码部分...</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 队头的元素肯定是最大的</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pop</code> 方法之所以要判断 <code>n == maxq.getFirst()</code>，是因为我们想删除的队头元素 <code>n</code> 可能已经在 <code>push</code> 的过程中被「压扁」了，可能已经不存在了，这种情况就不用删除了：</p><p><img src="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/2-1749878196844-11.png" alt="img"></p><p>至此，单调队列设计完毕，看下完整的解题代码：</p><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class MonotonicQueue:    def __init__(self):        self.maxq &#x3D; []        def push(self, n):        # 将小于 n 的元素全部删除        while self.maxq and self.maxq[-1] &lt; n:             self.maxq.pop()        # 然后将 n 加入尾部        self.maxq.append(n)        def max(self):        return self.maxq[0]        def pop(self, n):        if n &#x3D;&#x3D; self.maxq[0]:            self.maxq.pop(0)class Solution(object):    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        window &#x3D; MonotonicQueue()        res &#x3D; []                for i in range(len(nums)):            if i &lt; k - 1:                # 先填满窗口的前 k - 1                window.push(nums[i])            else:                 # 窗口向前滑动，加入新数字                window.push(nums[i])                # 记录当前窗口的最大值                res.append(window.max())                # 移出旧数字                window.pop(nums[i - k + 1])        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一点细节问题不要忽略，在实现 <code>MonotonicQueue</code> 时，我们使用了 Java 的 <code>LinkedList</code>，因为链表结构支持在头部和尾部快速增删元素；而在解法代码中的 <code>res</code> 则使用的 <code>ArrayList</code> 结构，因为后续会按照索引取元素，所以数组结构更合适。其他语言的实现也要注意这些细节。</p><p>关于单调队列 API 的时间复杂度，读者可能有疑惑：<code>push</code> 操作中含有 while 循环，最坏情况下的时间复杂度应该 O(N)<em>O</em>(<em>N</em>) 呀，再加上一层 for 循环，本算法的时间复杂度应该是 O(N2)<em>O</em>(<em>N</em>2) 才对吧？</p><p>这里就用到了 <a href="https://labuladong.online/algo/essential-technique/complexity-analysis/">算法时空复杂度分析指南</a> 中讲到的摊还分析：</p><p>单独看 <code>push</code> 操作，最坏时间复杂度确实是 O(N)<em>O</em>(<em>N</em>)，但是平均时间复杂度是 O(1)<em>O</em>(1)。我们一般用平均复杂度而不是最坏时间复杂度来衡量 API 接口，所以这个算法整体的时间复杂度是 O(N)<em>O</em>(<em>N</em>)，而不是 O(N2)<em>O</em>(<em>N</em>2)。</p><p>也可以这样从整体上分析：整个算法做的事情就是把 <code>nums</code> 中的每个元素加入和移出 <code>window</code> <strong>至多一次</strong>，不可能把同一个元素多次移入移出 <code>window</code>，所以整体的时间复杂度是 O(N)<em>O</em>(<em>N</em>)。</p><p>空间复杂度很容易分析，就是窗口的大小 O(k)<em>O</em>(<em>k</em>)。</p><h3 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="拓展延伸"></a><a href="https://labuladong.online/algo/data-structure/monotonic-queue/#%E6%8B%93%E5%B1%95%E5%BB%B6%E4%BC%B8">拓展延伸</a></h3><p>最后，我提出几个问题请大家思考：</p><p>1、本文给出的 <code>MonotonicQueue</code> 类只实现了 <code>max</code> 方法，你是否能够再额外添加一个 <code>min</code> 方法，在 O(1)<em>O</em>(1) 的时间返回队列中所有元素的最小值？</p><p>2、本文给出的 <code>MonotonicQueue</code> 类的 <code>pop</code> 方法还需要接收一个参数，这不那么优雅，而且有悖于标准队列的 API，请你修复这个缺陷。</p><p>3、请你实现 <code>MonotonicQueue</code> 类的 <code>size</code> 方法，返回单调队列中元素的个数（注意，由于每次 <code>push</code> 方法都可能从底层的 <code>q</code> 列表中删除元素，所以 <code>q</code> 中的元素个数并不是单调队列的元素个数）。</p><p>也就是说，你是否能够实现单调队列的通用实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 单调队列的通用实现，可以高效维护最大值和最小值</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token string">'Comparable'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 标准队列 API，从队头弹出元素，符合先进先出的顺序</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Comparable'</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 标准队列 API，返回队列中的元素个数</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 单调队列特有 API，O(1) 时间计算队列中元素的最大值</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Comparable'</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 单调队列特有 API，O(1) 时间计算队列中元素的最小值</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Comparable'</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我将在 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列通用实现及应用</a> 中给出单调队列的通用实现和经典习题。更多数据结构设计类题目参见 <a href="https://labuladong.online/algo/problem-set/ds-design/">数据结构设计经典习题</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】单调栈的几种变体及经典习题</title>
      <link href="/2025/06/14/lian-xi-dan-diao-zhan-de-ji-chong-bian-ti-ji-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-dan-diao-zhan-de-ji-chong-bian-ti-ji-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈模板的变体"><a href="#单调栈模板的变体" class="headerlink" title="单调栈模板的变体"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%98%E4%BD%93">单调栈模板的变体</a></h2><h3 id="下一个更大的元素"><a href="#下一个更大的元素" class="headerlink" title="下一个更大的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0">下一个更大的元素</a></h3><p>上篇文章 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈的实现</a> 带你使用单调栈解决了「下一个更大元素」的问题，比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们实现了这样一个函数解决这个问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更大元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 存放答案的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 因为是求 nums[i] 后面的元素，所以倒着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 后面较小的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的更大元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个更大或相等的元素"><a href="#下一个更大或相等的元素" class="headerlink" title="下一个更大或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">下一个更大或相等的元素</a></h3><p>本文给出这个问题的一些变体，比如说让你计算 <code>nums[i]</code> 的下一个大于等于 <code>nums[i]</code> 的元素怎么算？比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实很简单，把上面这段代码中 while 循环的 <code>&lt;=</code> 号改成 <code>&lt;</code> 号即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更大或相等的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把这里改成 &lt; 号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的大于等于 nums[i] 的元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个更小的元素"><a href="#下一个更小的元素" class="headerlink" title="下一个更小的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">下一个更小的元素</a></h3><p>再变一变，如果让你计算 <code>nums[i]</code> 的下一个小于 <code>nums[i]</code> 的元素，怎么算？比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也很简单，把之前实现的 <code>nextGreaterElement</code> 中 while 循环的 <code>&lt;=</code> 条件改成 <code>&gt;=</code> 条件即可得出下一个更小的元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更小的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLessElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 存放答案的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 倒着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 后面较大的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的更小元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个更小或相等的元素"><a href="#下一个更小或相等的元素" class="headerlink" title="下一个更小或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">下一个更小或相等的元素</a></h3><p>如果让你计算 <code>nums[i]</code> 的下一个小于或等于 <code>nums[i]</code> 的元素，怎么算？比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类似的，把 <code>nextLessElement</code> 函数的 while 循环中的 <code>&gt;=</code> 改成 <code>&gt;</code> 即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更小或相等的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLessOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 存放答案的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 倒着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 后面较大的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的更小或相等元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上一个更大元素"><a href="#上一个更大元素" class="headerlink" title="上一个更大元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0">上一个更大元素</a></h3><p>之前的 4 个例子都是计算 <code>nums[i]</code> 的下一个更大&#x2F;更小元素，现在请你计算 <code>nums[i]</code> 的上一个更大元素，你会不会？比如这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意之前我们的 for 循环都是从数组的尾部开始往栈里添加元素，这样栈顶元素就是 <code>nums[i]</code> 之后的元素。所以只要我们从数组的头部开始往栈里添加元素，栈顶的元素就是 <code>nums[i]</code> 之前的元素，即可计算 <code>nums[i]</code> 的上一个更大元素。</p><p>代码实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更大元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 因为是求 nums[i] 前面的元素，所以正着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 前面较小的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更大元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似之前的几种实现，基于这个函数还可以求出 <code>nums[i]</code> 的上一个更大或相等的元素、上一个更小的元素、上一个更小或相等的元素，只要改一改 while 循环的符号即可，下面一一列出具体实现。</p><h3 id="上一个更大或相等的元素"><a href="#上一个更大或相等的元素" class="headerlink" title="上一个更大或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">上一个更大或相等的元素</a></h3><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更大或相等元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevGreaterOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 注意不等号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更大或相等元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上一个更小的元素"><a href="#上一个更小的元素" class="headerlink" title="上一个更小的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">上一个更小的元素</a></h3><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更小的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevLessElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把 nums[i] 之前的较大元素删除</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更小元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上一个更小或相等的元素"><a href="#上一个更小或相等的元素" class="headerlink" title="上一个更小或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">上一个更小或相等的元素</a></h3><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更小或相等元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevLessOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 注意不等号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更小或相等元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>至此，单调栈的几种标准模板就列举完了，他们之间有很多共性，理解性记忆就好，不用死记硬背。在实际算法题中不会直接考察你这些标准场景，但是稍加思考就可以抽象成这些标准场景</strong>。</p><p>下面带大家做几道习题练习一下单调栈模板的使用。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B9%A0%E9%A2%98">习题</a></h2><h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_next-greater-node-in-linked-list">1019. 链表中的下一个更大节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1019. 链表中的下一个更大节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个长度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;的链表&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code></p><p style="line-height: 1.6; overflow-wrap: break-word;">对于列表中的每个节点，查找下一个<span>&nbsp;</span><strong style="font-weight: 600;">更大节点</strong><span>&nbsp;</span>的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值<span>&nbsp;</span><strong style="font-weight: 600;">严格大于</strong><span>&nbsp;</span>它的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer</code><span>&nbsp;</span>，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer[i]</code><span>&nbsp;</span>是第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>个节点(<span>&nbsp;</span><strong style="font-weight: 600;">从1开始</strong><span>&nbsp;</span>)的下一个更大的节点的值。如果第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>个节点没有下一个更大的节点，设置&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer[i] = 0</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/05/linkedlistnext1.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [2,1,5]<strong style="font-weight: 600;">输出：</strong>[5,5,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/05/linkedlistnext2.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [2,7,4,3,5]<strong style="font-weight: 600;">输出：</strong>[7,0,5,5,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>链表中节点数为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1019. 链表中的下一个更大节点</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这道题输入的是一条单链表，我们把它转化成数组，方便用索引访问即可直接套用 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈模板</a> 中的 <code>nextGreaterElement</code> 函数逻辑。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def nextLargerNodes(self, head: ListNode) -&gt; List[int]:        # 把单链表转化成数组，方便通过索引访问        nums &#x3D; []        p &#x3D; head        while p:            nums.append(p.val)            p &#x3D; p.next                # 存放答案的数组        res &#x3D; [0] * len(nums)        stk &#x3D; []                # 单调栈模板，求下一个更大元素，从后往前遍历        for i in range(len(nums) - 1, -1, -1):            while stk and stk[-1] &lt;&#x3D; nums[i]:                stk.pop()            # 本题要求没有下一个更大元素时返回 0            res[i] &#x3D; 0 if not stk else stk[-1]            stk.append(nums[i])                return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_next-greater-node-in-linked-list" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_next-greater-node-in-linked-list" src="https://labuladong.online/algo-visualize/leetcode/next-greater-node-in-linked-list/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1944-队列中可以看到的人数"><a href="#1944-队列中可以看到的人数" class="headerlink" title="1944. 队列中可以看到的人数"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_number-of-visible-people-in-a-queue">1944. 队列中可以看到的人数</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1944. 队列中可以看到的人数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/number-of-visible-people-in-a-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;个人排成一个队列，<strong style="font-weight: 600;">从左到右</strong>&nbsp;编号为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n - 1</code>&nbsp;。给你以一个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">heights</code>&nbsp;，每个整数<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">heights[i]</code>&nbsp;表示第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个人的高度。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一个人能<span>&nbsp;</span><strong style="font-weight: 600;">看到</strong><span>&nbsp;</span>他右边另一个人的条件是这两人之间的所有人都比他们两人<span>&nbsp;</span><strong style="font-weight: 600;">矮</strong>&nbsp;。更正式的，第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个人能看到第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;个人的条件是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt; j</code>&nbsp;且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回一个长度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;的数组<em>&nbsp;</em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer[i]</code><em>&nbsp;</em>是第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个人在他右侧队列中能&nbsp;<strong style="font-weight: 600;">看到</strong>&nbsp;的&nbsp;<strong style="font-weight: 600;">人数</strong>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/05/29/queue-plane.jpg" style="max-width: 100%; width: 600px; height: 247px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>heights = [10,6,8,5,11,9]<b>输出：</b>[3,1,2,1,1,0]<strong style="font-weight: 600;">解释：</strong>第 0 个人能看到编号为 1 ，2 和 4 的人。第 1 个人能看到编号为 2 的人。第 2 个人能看到编号为 3 和 4 的人。第 3 个人能看到编号为 4 的人。第 4 个人能看到编号为 5 的人。第 5 个人谁也看不到因为他右边没人。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>heights = [5,1,2,3,10]<b>输出：</b>[4,1,1,1,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == heights.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">heights</code>&nbsp;中所有数<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1944. 队列中可以看到的人数</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这道题显然要用到 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈技巧</a>：靠左的高个子可以把靠右相邻的矮个子都「挤掉」，相当于计算下一个更大元素，即 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种模板实现</a> 中的 <code>nextGreaterElement</code> 函数。</p><p>只不过这道题不是问你下一个更大元素是多少，而是问你当前元素和下一个更大元素之间的元素个数，直接看解法代码吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canSeePersonsCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># int[] 记录 &#123;身高，小于等于该身高的人数&#125; 二元组</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 记录右侧比自己矮的人</span>            count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 单调栈模板，计算下一个更大或相等元素（身高）</span>            <span class="token keyword">while</span> stk <span class="token keyword">and</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 不仅可以看到比自己矮的人，如果后面存在更高的的人，也可以看到这个高人</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count <span class="token keyword">if</span> <span class="token keyword">not</span> stk <span class="token keyword">else</span> count <span class="token operator">+</span> <span class="token number">1</span>            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_number-of-visible-people-in-a-queue" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_number-of-visible-people-in-a-queue" src="https://labuladong.online/algo-visualize/leetcode/number-of-visible-people-in-a-queue/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1475-商品折扣后的最终价格"><a href="#1475-商品折扣后的最终价格" class="headerlink" title="1475. 商品折扣后的最终价格"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_final-prices-with-a-special-discount-in-a-shop">1475. 商品折扣后的最终价格</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1475. 商品折扣后的最终价格</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices</code>&nbsp;，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices[i]</code>&nbsp;是商店里第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;件商品的价格。</p><p style="line-height: 1.6; overflow-wrap: break-word;">商店里正在进行促销活动，如果你要买第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;件商品，那么你可以得到与<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices[j]</code><span>&nbsp;</span>相等的折扣，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;是满足&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j &gt; i</code>&nbsp;且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices[j] &lt;= prices[i]</code>&nbsp;的&nbsp;<strong style="font-weight: 600;">最小下标</strong>&nbsp;，如果没有满足条件的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;，你将没有任何折扣。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回一个数组，数组中第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个元素是折扣后你购买商品<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;最终需要支付的价格。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>prices = [8,4,6,2,3]<strong style="font-weight: 600;">输出：</strong>[4,2,4,2,3]<strong style="font-weight: 600;">解释：</strong>商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。商品 3 和 4 都没有折扣。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>prices = [1,2,3,4,5]<strong style="font-weight: 600;">输出：</strong>[1,2,3,4,5]<strong style="font-weight: 600;">解释：</strong>在这个例子中，所有商品都没有折扣。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>prices = [10,1,1,6]<strong style="font-weight: 600;">输出：</strong>[9,0,1,6]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= prices.length &lt;= 500</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= prices[i] &lt;= 10^3</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1475. 商品折扣后的最终价格</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这道题就用到了 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种模板实现</a> 中讲到的一个单调栈模板：计算下一个更小或相等的元素。我是为了运用模板，所以把解法分成了两个函数，效率可能会降低一些，你完全可以优化这个解法的形式，使之更高效。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def finalPrices(self, prices: List[int]) -&gt; List[int]:        n &#x3D; len(prices)        res &#x3D; [0] * n        # 下一个小于等于 price[i] 的价格就是优惠券折扣        next_element &#x3D; self.nextLessOrEqualElement(prices)        for i in range(len(prices)):            # 如果存在优惠券，则减少相应的价格            if next_element[i] !&#x3D; -1:                res[i] &#x3D; prices[i] - next_element[i]            else:                res[i] &#x3D; prices[i]        return res    # 单调栈模板：计算 nums 中每个元素的下一个更小或相等的元素    def nextLessOrEqualElement(self, nums: List[int]) -&gt; List[int]:        n &#x3D; len(nums)        # 存放答案的数组        res &#x3D; [-1] * n        s &#x3D; []        # 倒着往栈里放        for i in range(n - 1, -1, -1):            # 删掉 nums[i] 后面较大的元素            while s and s[-1] &gt; nums[i]:                s.pop()            # 现在栈顶就是 nums[i] 身后的更小或相等元素            res[i] &#x3D; s[-1] if s else -1            s.append(nums[i])        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_final-prices-with-a-special-discount-in-a-shop" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_final-prices-with-a-special-discount-in-a-shop" src="https://labuladong.online/algo-visualize/leetcode/final-prices-with-a-special-discount-in-a-shop/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_online-stock-span">901. 股票价格跨度</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">901. 股票价格跨度</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/online-stock-span/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/online-stock-span/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个算法收集某些股票的每日报价，并返回该股票当日价格的<span>&nbsp;</span><strong style="font-weight: 600;">跨度</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">当日股票价格的<span>&nbsp;</span><strong style="font-weight: 600;">跨度</strong><span>&nbsp;</span>被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;">例如，如果未来 7 天股票的价格是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[100,80,60,70,60,75,85]</code>，那么股票跨度将是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1,1,1,2,1,4,6]</code><span>&nbsp;</span>。</p></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">StockSpanner</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">StockSpanner()</code><span>&nbsp;</span>初始化类对象。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int next(int price)</code><span>&nbsp;</span>给出今天的股价<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">price</code><span>&nbsp;</span>，返回该股票当日价格的<span>&nbsp;</span><strong style="font-weight: 600;">跨度</strong><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>：["StockSpanner", "next", "next", "next", "next", "next", "next", "next"][[], [100], [80], [60], [70], [60], [75], [85]]<strong style="font-weight: 600;">输出</strong>：[null, 1, 1, 1, 2, 1, 4, 6]<p><strong style="font-weight: 600;">解释：</strong><br>StockSpanner stockSpanner &#x3D; new StockSpanner();<br>stockSpanner.next(100); &#x2F;&#x2F; 返回 1<br>stockSpanner.next(80);  &#x2F;&#x2F; 返回 1<br>stockSpanner.next(60);  &#x2F;&#x2F; 返回 1<br>stockSpanner.next(70);  &#x2F;&#x2F; 返回 2<br>stockSpanner.next(60);  &#x2F;&#x2F; 返回 1<br>stockSpanner.next(75);  &#x2F;&#x2F; 返回 4 ，因为截至今天的最后 4 个股价 (包括今天的股价 75) 都小于或等于今天的股价。<br>stockSpanner.next(85);  &#x2F;&#x2F; 返回 6<br></pre>&nbsp;<p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= price &lt;= 10<sup>5</sup></code></li><li>最多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next</code><span>&nbsp;</span>方法<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code><span>&nbsp;</span>次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/online-stock-span/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 901. 股票价格跨度</a>。</strong></details></p><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这道题显然要用到 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈技巧</a>：当加入 <code>price</code> 时，把所有小于等于 <code>price</code> 的价格都「挤掉」，相当于计算前一个更大元素，即 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种模板实现</a> 中的 <code>prevGreaterElement</code> 函数。</p><p>比如已经入栈的价格序列是 <code>[40, 30, 20, 10]</code>，那么如果执行 <code>next(25)</code>，价格序列变成 <code>[40, 30, 25]</code>，20 和 10 都会被「挤掉」，算上 25 本身，函数返回 2 + 1 &#x3D; 3。</p><p><strong>但还有个问题，这个 3 应该作为「权重」和 25 一同存储在栈中</strong>。因为之后 25 还可能被挤掉，比如说执行 <code>next(26)</code>，价格序列就变成了 <code>[40, 30, 26]</code>，但这种情况下之前的 20 和 10 显然也应该被挤掉，函数应该返回 3 + 1 &#x3D; 4。具体解法看代码吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class StockSpanner:    # int[] 记录 &#123;价格，小于等于该价格的天数&#125; 二元组    def __init__(self):        self.stk &#x3D; []    def next(self, price: int) -&gt; int:        # 算上当天        count &#x3D; 1        # 单调栈模板        while self.stk and price &gt;&#x3D; self.stk[-1][0]:            # 挤掉价格低于 price 的记录            prev &#x3D; self.stk.pop()            # 计算小于等于 price 的天数            count +&#x3D; prev[1]        self.stk.append([price, count])        return count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_remove-k-digits">402. 移掉 K 位数字</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">402. 移掉 K 位数字</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/remove-k-digits/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/remove-k-digits/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个以字符串表示的非负整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">num</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>，移除这个数中的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><em><span>&nbsp;</span></em>位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>num = "1432219", k = 3<strong style="font-weight: 600;">输出：</strong>"1219"<strong style="font-weight: 600;">解释：</strong>移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>num = "10200", k = 1<strong style="font-weight: 600;">输出：</strong>"200"<strong style="font-weight: 600;">解释：</strong>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>num = "10", k = 2<strong style="font-weight: 600;">输出：</strong>"0"<strong style="font-weight: 600;">解释：</strong>从原数字移除所有的数字，剩余为空就是 0 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= num.length &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">num</code><span>&nbsp;</span>仅由若干位数字（0 - 9）组成</li><li>除了<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>本身之外，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">num</code><span>&nbsp;</span>不含任何前导零</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/remove-k-digits/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 402. 移掉 K 位数字</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>如果想让结果尽可能小，那么清除数字分两步：</p><p>1、先删除 <code>num</code> 中的若干数字，使得 <code>num</code> 从左到右每一位都单调递增。比如 <code>14329</code> 转化成 <code>129</code>，这需要使用到 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈技巧</a>。</p><p>2、<code>num</code> 中的每一位变成单调递增的之后，如果 <code>k</code> 还大于 0（还可以继续删除）的话，则删除尾部的数字，比如 <code>129</code> 删除成 <code>12</code>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def removeKdigits(self, num: str, k: int) -&gt; str:        stk &#x3D; []        for c in num:            # 单调栈代码模板            while stk and k &gt; 0 and c &lt; stk[-1]:                stk.pop()                k -&#x3D; 1            # 防止 0 作为数字的开头            if not stk and c &#x3D;&#x3D; &#39;0&#39;:                continue            stk.append(c)        # 此时栈中元素单调递增，若 k 还没用完的话删掉栈顶元素        final_stack &#x3D; stk[:-k] if k else stk        # 将栈中字符转化成字符串        # 出栈顺序和字符串顺序是反的        result &#x3D; &#39;&#39;.join(final_stack).lstrip(&#39;0&#39;)        # 若最后没剩下数字，就是 0        return result if result else &#39;0&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_remove-k-digits" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_remove-k-digits" src="https://labuladong.online/algo-visualize/leetcode/remove-k-digits/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="853-车队"><a href="#853-车队" class="headerlink" title="853. 车队"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_car-fleet">853. 车队</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">853. 车队</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/car-fleet/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/car-fleet/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在一条单行道上，有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>辆车开往同一目的地。目的地是几英里以外的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给定两个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">position</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">speed</code>&nbsp;，长度都是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">position[i]</code>&nbsp;是第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>辆车的位置，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">speed[i]</code>&nbsp;是第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>辆车的速度(单位是英里/小时)。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一辆车永远不会超过前面的另一辆车，但它可以追上去，并以较慢车的速度在另一辆车旁边行驶。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">车队<span>&nbsp;</span></strong>是指并排行驶的一辆或几辆汽车。车队的速度是车队中<span>&nbsp;</span><strong style="font-weight: 600;">最慢</strong><span>&nbsp;</span>的车的速度。</p><p style="line-height: 1.6; overflow-wrap: break-word;">即便一辆车在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code><span>&nbsp;</span>才赶上了一个车队，它们仍然会被视作是同一个车队。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回到达目的地的车队数量 。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><div class="example-block"><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输入：</b>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输出：</b>3</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">解释：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>从 10（速度为 2）和 8（速度为 4）开始的车会组成一个车队，它们在 12 相遇。车队在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;形成。</li><li>从 0（速度为 1）开始的车不会追上其它任何车，所以它自己是一个车队。</li><li>从 5（速度为 1） 和 3（速度为 3）开始的车组成一个车队，在 6 相遇。车队以速度 1 移动直到它到达&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>。</li></ul></div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><div class="example-block"><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输入：</b></span><span class="example-io">target = 10, position = [3], speed = [3]</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输出：</b></span><span class="example-io">1</span></p><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">解释：</strong></p>只有一辆车，因此只有一个车队。</div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><div class="example-block"><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输入：</b></span><span class="example-io">target = 100, position = [0,2,4], speed = [4,2,1]</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输出：</b></span><span class="example-io">1</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">解释：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>从 0（速度为 4） 和 2（速度为 2）开始的车组成一个车队，在 4&nbsp;相遇。从 4 开始的车（速度为 1）移动到了 5。</li><li>然后，在 4（速度为 2）的车队和在 5（速度为 1）的车成为一个车队，在 6 相遇。车队以速度 1 移动直到它到达&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>。</li></ul></div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == position.length == speed.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt; target &lt;= 10<sup>6</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= position[i] &lt; target</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">position</code>&nbsp;中每个值都<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/car-fleet/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 853. 车队</a>。</strong></details><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>这题考察「单调栈」结构的使用。是否能够形成车队，取决于下述规律：</p><p><strong>如果车 <code>x</code> 排在 车 <code>y</code> 后面，且 <code>x</code> 到达终点所需时间比 <code>y</code> 少，则 <code>x</code> 必然会被 <code>y</code> 卡住，形成车队</strong>。</p><p>所以本题的思路是先根据每辆车的起始位置 <code>position</code> 排序，然后计算出时间数组 <code>time</code>。</p><p>假设计算出的 <code>time</code> 数组为 <code>[12, 3, 7, 1, 2]</code>，那么观察数组的单调性变化，最后肯定会形成三个车队，他们到达终点的时间分别是 12, 7, 2。</p><p>可以利用单调栈结构模拟得出结果，不过效率稍微低一些。也可以倒序遍历数组得出递增子序列，子序列的长度即答案。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def carFleet(self, target: int, position: List[int], speed: List[int]) -&gt; int:        n &#x3D; len(position)        cars &#x3D; []        for i in range(n):            cars.append([position[i], speed[i]])        # 按照初始位置，从小到大排序        cars.sort(key&#x3D;lambda x: x[0])        # 计算每辆车到达终点的时间        time &#x3D; []        for i in range(n):            car &#x3D; cars[i]            time.append((target - car[0]) &#x2F; car[1])                # 使用单调栈计算车队的数量        # (This part is commented out in the original Java code, so it&#39;s also commented out here)        # stk &#x3D; []        # for t in time:        #     while stk and t &gt;&#x3D; stk[-1]:        #         stk.pop()        #     stk.append(t)        # return len(stk)        # 避免使用栈模拟，倒序遍历取递增序列就是答案        res &#x3D; 0        max_time &#x3D; 0        for i in range(n - 1, -1, -1):            if time[i] &gt; max_time:                max_time &#x3D; time[i]                res +&#x3D; 1        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-4"><a href="#可视化-4" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_car-fleet" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_car-fleet" src="https://labuladong.online/algo-visualize/leetcode/car-fleet/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_shortest-unsorted-continuous-subarray">581. 最短无序连续子数组</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">581. 最短无序连续子数组</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>，你需要找出一个<span>&nbsp;</span><strong style="font-weight: 600;">连续子数组</strong><span>&nbsp;</span>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你找出符合题意的<span>&nbsp;</span><strong style="font-weight: 600;">最短</strong><span>&nbsp;</span>子数组，并输出它的长度。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [2,6,4,8,10,9,15]<strong style="font-weight: 600;">输出：</strong>5<strong style="font-weight: 600;">解释：</strong>你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,2,3,4]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你可以设计一个时间复杂度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(n)</code><span>&nbsp;</span>的解决方案吗？</p></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 581. 最短无序连续子数组</a>。</strong></details><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>最简单的解法是排序，排序之后很容易看出来哪一部分子数组乱序了。这里主要介绍一下单调栈的解法。</p><p>单调递增栈会筛选出递增的元素序列，换句话说，每加入一个新元素 <code>x</code>，就会弹出栈顶大于 <code>x</code> 的其他元素，直到栈顶元素小于 <code>x</code> 为止。</p><p>反过来，单调递减栈会筛选出递减的元素序列，换句话说，每加入一个新元素 <code>x</code>，就会弹出栈顶小于 <code>x</code> 的其他元素，直到栈顶元素大于 <code>x</code> 为止。</p><p>综上，如果正序遍历 <code>nums</code>，维护一个递增栈，那么弹出的元素就是乱序的元素；如果反向遍历 <code>nums</code>，维护一个递减栈，那么弹出的元素就是乱序的元素。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON"># 排序解法class Solution:    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:        temp &#x3D; sorted(nums)        left &#x3D; float(&#39;inf&#39;)        right &#x3D; float(&#39;-inf&#39;)        for i in range(len(nums)):            if temp[i] !&#x3D; nums[i]:                left &#x3D; i                break        for i in range(len(nums) - 1, -1, -1):            if temp[i] !&#x3D; nums[i]:                right &#x3D; i                break        if left &#x3D;&#x3D; float(&#39;inf&#39;) and right &#x3D;&#x3D; float(&#39;-inf&#39;):            # nums 本来就是有序的            return 0        return right - left + 1# 单调栈解法class Solution2:    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:        n &#x3D; len(nums)        left &#x3D; float(&#39;inf&#39;)        right &#x3D; float(&#39;-inf&#39;)        # 递增栈，存储元素索引        incr_stk &#x3D; []        for i in range(n):            while incr_stk and nums[incr_stk[-1]] &gt; nums[i]:                # 弹出的元素都是乱序元素，其中最小的索引就是乱序子数组的左边界                left &#x3D; min(left, incr_stk.pop())            incr_stk.append(i)        # 递减栈，存储元素索引        decr_stk &#x3D; []        for i in range(n - 1, -1, -1):            while decr_stk and nums[decr_stk[-1]] &lt; nums[i]:                # 弹出的元素都是乱序元素，其中最大的索引就是乱序子数组的右边界                right &#x3D; max(right, decr_stk.pop())            decr_stk.append(i)        if left &#x3D;&#x3D; float(&#39;inf&#39;) and right &#x3D;&#x3D; float(&#39;-inf&#39;):            # 说明单调栈没有弹出任何元素，即 nums 本来就是有序的            return 0        return right - left + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈算法模板解决三道例题</title>
      <link href="/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/"/>
      <url>/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="单调栈算法模板解决三道例题"><a href="#单调栈算法模板解决三道例题" class="headerlink" title="单调栈算法模板解决三道例题"></a>单调栈算法模板解决三道例题</h1><blockquote><p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」等。本文讲解单调栈的算法模版解决「下一个更大元素」相关问题，并且探讨处理「循环数组」的策略。</p></blockquote><h2 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF">单调栈模板</a></h2><p>现在给你出这么一道题：输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calculateGreaterElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如说，输入一个数组 <code>nums = [2,1,2,4,3]</code>，你返回数组 <code>[4,2,4,-1,-1]</code>。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p><p>这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 O(n2)<em>O</em>(<em>n</em>2)。</p><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的下一个更大元素呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><p><img src="/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/1.jpeg" alt="img"></p><p>这个情景很好理解吧？带着这个抽象的情景，先来看下代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calculateGreaterElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># 存放答案的数组</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n    s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 倒着往栈里放</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 判定个子高矮</span>        <span class="token keyword">while</span> s <span class="token keyword">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 矮个起开，反正也被挡着了。。。</span>            s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># nums[i] 身后的更大元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s <span class="token keyword">else</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是单调栈解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。</p><p>这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n2)<em>O</em>(<em>n</em>2)，但是实际上这个算法的复杂度只有 O(n)<em>O</em>(<em>n</em>)。</p><p>分析它的时间复杂度，要从整体来看：总共有 <code>n</code> 个元素，每个元素都被 <code>push</code> 入栈了一次，而最多会被 <code>pop</code> 一次，没有任何冗余操作。所以总的计算规模是和元素规模 <code>n</code> 成正比的，也就是 O(n)<em>O</em>(<em>n</em>) 的复杂度。</p><h2 id="问题变形"><a href="#问题变形" class="headerlink" title="问题变形"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#%E9%97%AE%E9%A2%98%E5%8F%98%E5%BD%A2">问题变形</a></h2><p>单调栈的代码实现比较简单，下面来看一些具体题目。</p><h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#_496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i">496. 下一个更大元素 I</a></h3><p>首先来一个简单的变形，力扣第 496 题「<a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">496. 下一个更大元素 I</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/next-greater-element-i/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/next-greater-element-i/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;"><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code>&nbsp;中数字&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code>&nbsp;的<span>&nbsp;</span><strong style="font-weight: 600;">下一个更大元素</strong><span>&nbsp;</span>是指&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code>&nbsp;在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>中对应位置<span>&nbsp;</span><strong style="font-weight: 600;">右侧</strong><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">第一个</strong><span>&nbsp;</span>比&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><strong style="font-weight: 600;">&nbsp;</strong>大的元素。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你两个<strong style="font-weight: 600;"><span>&nbsp;</span>没有重复元素</strong><span>&nbsp;</span>的数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>，下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始计数，其中<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code>&nbsp;是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code>&nbsp;的子集。</p><p style="line-height: 1.6; overflow-wrap: break-word;">对于每个<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= i &lt; nums1.length</code><span>&nbsp;</span>，找出满足<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1[i] == nums2[j]</code><span>&nbsp;</span>的下标<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code><span>&nbsp;</span>，并且在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>确定<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2[j]</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">下一个更大元素</strong><span>&nbsp;</span>。如果不存在下一个更大元素，那么本次查询的答案是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回一个长度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1.length</code><span>&nbsp;</span>的数组<em><span>&nbsp;</span></em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ans</code><em><span>&nbsp;</span></em>作为答案，满足<em><span>&nbsp;</span></em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ans[i]</code><em><span>&nbsp;</span></em>是如上所述的<span>&nbsp;</span><strong style="font-weight: 600;">下一个更大元素</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums1 = [4,1,2], nums2 = [1,3,4,2].<strong style="font-weight: 600;">输出：</strong>[-1,3,-1]<strong style="font-weight: 600;">解释：</strong>nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 = [1,3,<strong style="font-weight: 600;">4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 = [<em><strong style="font-weight: 600;">1</strong></em>,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 = [1,3,4,<em><strong style="font-weight: 600;">2</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums1 = [2,4], nums2 = [1,2,3,4].<strong style="font-weight: 600;">输出：</strong>[3,-1]<strong style="font-weight: 600;">解释：</strong>nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 = [1,<em><strong style="font-weight: 600;">2</strong></em>,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 = [1,2,3,<em><strong style="font-weight: 600;">4</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code>和<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code>中所有整数<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code><span>&nbsp;</span>中的所有整数同样出现在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>中</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你可以设计一个时间复杂度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(nums1.length + nums2.length)</code><span>&nbsp;</span>的解决方案吗？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 496. 下一个更大元素 I</a>。</strong></details><p>这道题给你输入两个数组 <code>nums1</code> 和 <code>nums2</code>，让你求 <code>nums1</code> 中的元素在 <code>nums2</code> 中的下一个更大元素，函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其实和把我们刚才的代码改一改就可以解决这道题了，因为题目说 <code>nums1</code> 是 <code>nums2</code> 的子集，那么我们先把 <code>nums2</code> 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 <code>nums1</code> 中的元素去查表即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 nums2 中每个元素的下一个更大元素</span>        greater <span class="token operator">=</span> self<span class="token punctuation">.</span>calculateGreaterElement<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        <span class="token comment"># 转化成映射：元素 x -> x 的下一个最大元素</span>        greaterMap <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            greaterMap<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> greater<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> greaterMap<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">calculateGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 见上文</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_next-greater-element-i" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_next-greater-element-i" src="https://labuladong.online/algo-visualize/leetcode/next-greater-element-i/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#_739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6">739. 每日温度</a></h3><p>再看看力扣第 739 题「<a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a>」：</p><p>给你一个数组 <code>temperatures</code>，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0。函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>temperatures<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如说给你输入 <code>temperatures = [73,74,75,71,69,76]</code>，你返回 <code>[1,1,3,2,1,0]</code>。因为第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温，后面的同理。</p><p>这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。</p><p>相同的思路，直接调用单调栈的算法模板，稍作改动就可以，直接上代码吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> temperatures<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temperatures<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n        <span class="token comment"># 这里放元素索引，而不是元素</span>        s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 单调栈模板</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s <span class="token keyword">and</span> temperatures<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 得到索引间距</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s <span class="token keyword">else</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> i            <span class="token comment"># 将索引入栈，而不是元素</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单调栈讲解完毕，下面开始另一个重点：如何处理「循环数组」。</p><h2 id="如何处理环形数组"><a href="#如何处理环形数组" class="headerlink" title="如何处理环形数组"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84">如何处理环形数组</a></h2><p>同样是求下一个更大元素，现在假设给你的数组是个环形的，如何处理？力扣第 503 题「<a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a>」就是这个问题：输入一个「环形数组」，请你计算其中每个元素的下一个更大元素。</p><p>比如输入 <code>[2,1,2,4,3]</code>，你应该返回 <code>[4,2,4,-1,4]</code>，因为拥有了环形属性，<strong>最后一个元素 3 绕了一圈后找到了比自己大的元素 4</strong>。</p><p>如果你看过基础知识章节的 <a href="https://labuladong.online/algo/data-structure-basic/cycle-array/">环形数组技巧</a> 应该比较熟悉，我们一般是通过 % 运算符求模（余数），来模拟环形特效：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># 在环形数组中转圈</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span>    index <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 <code>[2,1,2,4,3]</code>，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。</p><p><strong>对于这种需求，常用套路就是将数组长度翻倍</strong>：</p><p><img src="/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/2.jpeg" alt="img"></p><p>这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。</p><p>有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，<strong>我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果</strong>。直接看代码吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># 用数组模拟栈</span>        s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 数组长度加倍模拟环形数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 索引 i 要求模，其他的和模板一样</span>            <span class="token keyword">while</span> s <span class="token keyword">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s <span class="token keyword">else</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_next-greater-element-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_next-greater-element-ii" src="https://labuladong.online/algo-visualize/leetcode/next-greater-element-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，就可以巧妙解决环形数组的问题，时间复杂度 O(N)<em>O</em>(<em>N</em>)。</p><p>最后提出一些问题吧，本文提供的单调栈模板是 <code>nextGreaterElement</code> 函数，可以计算每个元素的下一个更大元素，但如果题目让你计算上一个更大元素，或者计算上一个更大或相等的元素，应该如何修改对应的模板呢？而且在实际应用中，题目不会直接让你计算下一个（上一个）更大（小）的元素，你如何把问题转化成单调栈相关的问题呢？</p><p>我会在 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种变体及习题</a> 对比单调栈的几种其他形式，并在 给出单调栈的经典例题。更多数据结构设计类题目参见 <a href="https://labuladong.online/algo/problem-set/ds-design/">数据结构设计经典习题</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】队列的经典习题</title>
      <link href="/2025/06/14/lian-xi-dui-lie-de-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-dui-lie-de-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】队列的经典习题"><a href="#【练习】队列的经典习题" class="headerlink" title="【练习】队列的经典习题"></a>【练习】队列的经典习题</h1><h2 id="考察先进先出性质"><a href="#考察先进先出性质" class="headerlink" title="考察先进先出性质"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%80%83%E5%AF%9F%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E6%80%A7%E8%B4%A8">考察先进先出性质</a></h2><p>队列常见考点主要是元素「先进先出」的顺序特性，比如维护队列内的元素在「时序上」的某些性质，下面是几道例题，队列充当「滑动窗口」的作用。</p><h2 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_number-of-recent-calls">933. 最近的请求次数</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">933. 最近的请求次数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/number-of-recent-calls/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/number-of-recent-calls/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">写一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">RecentCounter</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">RecentCounter()</code><span>&nbsp;</span>初始化计数器，请求数为 0 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int ping(int t)</code><span>&nbsp;</span>在时间<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>添加一个新请求，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>表示以毫秒为单位的某个时间，并返回过去<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">3000</code><span>&nbsp;</span>毫秒内发生的所有请求数（包括新请求）。确切地说，返回在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[t-3000, t]</code><span>&nbsp;</span>内发生的请求数。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>每次对<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ping</code><span>&nbsp;</span>的调用都使用比之前更大的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["RecentCounter", "ping", "ping", "ping", "ping"][[], [1], [100], [3001], [3002]]<strong style="font-weight: 600;">输出：</strong>[null, 1, 2, 3, 3]<p><strong style="font-weight: 600;">解释：</strong><br>RecentCounter recentCounter &#x3D; new RecentCounter();<br>recentCounter.ping(1);     &#x2F;&#x2F; requests &#x3D; [<strong style="font-weight: 600;">1</strong>]，范围是 [-2999,1]，返回 1<br>recentCounter.ping(100);   &#x2F;&#x2F; requests &#x3D; [<strong style="font-weight: 600;">1</strong>, <strong style="font-weight: 600;">100</strong>]，范围是 [-2900,100]，返回 2<br>recentCounter.ping(3001);  &#x2F;&#x2F; requests &#x3D; [<strong style="font-weight: 600;">1</strong>, <strong style="font-weight: 600;">100</strong>, <strong style="font-weight: 600;">3001</strong>]，范围是 [1,3001]，返回 3<br>recentCounter.ping(3002);  &#x2F;&#x2F; requests &#x3D; [1, <strong style="font-weight: 600;">100</strong>, <strong style="font-weight: 600;">3001</strong>, <strong style="font-weight: 600;">3002</strong>]，范围是 [2,3002]，返回 3<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= t &lt;= 10<sup>9</sup></code></li><li>保证每次对<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ping</code><span>&nbsp;</span>调用所使用的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>值都<span>&nbsp;</span><strong style="font-weight: 600;">严格递增</strong></li><li>至多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ping</code><span>&nbsp;</span>方法<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code><span>&nbsp;</span>次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/number-of-recent-calls/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 933. 最近的请求次数</a>。</strong></details></p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这题很简单，和 <a href="https://leetcode.cn/problems/moving-average-from-data-stream">346. 数据流中的移动平均值</a> 有点类似，要求动态维护队列中的元素。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">class</span> <span class="token class-name">RecentCounter</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> t <span class="token operator">-</span> <span class="token number">3000</span><span class="token punctuation">:</span>            <span class="token comment"># t 是递增的，所以可以从队头删除 3000 毫秒之前的请求</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/design-hit-counter">362. 敲击计数器 🟠</a></li><li><a href="https://leetcode.cn/problems/H8086Q">剑指 Offer II 042. 最近请求次数 🟢</a></li></ul><h2 id="队列相关的设计题"><a href="#队列相关的设计题" class="headerlink" title="队列相关的设计题"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98">队列相关的设计题</a></h2><p>队列相关的设计题也是一大重点，但不算很难，下面是几道例题。</p><h2 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_design-circular-queue">622. 设计循环队列</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">622. 设计循环队列</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/design-circular-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/design-circular-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p style="line-height: 1.6; overflow-wrap: break-word;">循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你的实现应该支持如下操作：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isEmpty()</code>: 检查循环队列是否为空。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isFull()</code>: 检查循环队列是否已满。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); &nbsp;// 返回 truecircularQueue.enQueue(2); &nbsp;// 返回 truecircularQueue.enQueue(3); &nbsp;// 返回 truecircularQueue.enQueue(4); &nbsp;// 返回 false，队列已满circularQueue.Rear(); &nbsp;// 返回 3circularQueue.isFull(); &nbsp;// 返回 truecircularQueue.deQueue(); &nbsp;// 返回 truecircularQueue.enQueue(4); &nbsp;// 返回 truecircularQueue.Rear(); &nbsp;// 返回 4</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>所有的值都在 0&nbsp;至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/design-circular-queue/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 622. 设计循环队列</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这道题考察的是普通队列的实现，底层可以用链表或数组实现，用链表实现比较简单，用数组的话要用到环形数组的技巧。具体可以参见 <a href="https://labuladong.online/algo/data-structure-basic/linked-queue-stack/">用链表实现队列&#x2F;栈</a> 和 <a href="https://labuladong.online/algo/data-structure-basic/array-queue-stack/">用数组实现环形队列</a> 两篇文章。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token comment"># 底层用数组实现队列</span><span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">:</span>    INIT_CAP <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_cap<span class="token operator">=</span>INIT_CAP<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> init_cap        self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 不传参数，默认大小为 INIT_CAP</span>    <span class="token comment"># Initializer with default capacity</span>    <span class="token comment"># 增</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> e        self<span class="token punctuation">.</span>last <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 删</span>    <span class="token keyword">def</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Queue underflow'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>        old_val <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>first <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> old_val    <span class="token keyword">def</span> <span class="token function">resize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_cap<span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> new_cap        <span class="token comment"># first ----- last</span>        <span class="token comment"># --- last    first ---</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>first <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>last <span class="token operator">=</span> self<span class="token punctuation">.</span>size        self<span class="token punctuation">.</span>data <span class="token operator">=</span> temp    <span class="token comment"># 查</span>    <span class="token keyword">def</span> <span class="token function">peek_first</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Queue underflow'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">peek_last</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Queue underflow'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token keyword">class</span> <span class="token class-name">MyCircularQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> ArrayQueue<span class="token punctuation">(</span>k<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>max_cap <span class="token operator">=</span> k    <span class="token keyword">def</span> <span class="token function">enQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>max_cap<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>enqueue<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">deQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>dequeue<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">Front</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>peek_first<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">Rear</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>peek_last<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isFull</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>max_cap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_design-circular-deque">641. 设计循环双端队列</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">641. 设计循环双端队列</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/design-circular-deque/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/design-circular-deque/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计实现双端队列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyCircularDeque</code><span>&nbsp;</span>类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyCircularDeque(int k)</code>&nbsp;：构造函数,双端队列最大为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean insertLast()</code>&nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean deleteFront()</code>&nbsp;：从双端队列头部删除一个元素。 如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean deleteLast()</code>&nbsp;：从双端队列尾部删除一个元素。如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int getFront()</code>&nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code>&nbsp;。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int getRear()</code>&nbsp;：获得双端队列的最后一个元素。&nbsp;如果双端队列为空，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean isEmpty()</code>&nbsp;：若双端队列为空，则返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>&nbsp;。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean isFull()</code>&nbsp;：若双端队列满了，则返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"][[3], [1], [2], [3], [4], [], [], [], [4], []]<strong style="font-weight: 600;">输出</strong>[null, true, true, true, false, 2, true, true, true, 4]<p><strong style="font-weight: 600;">解释</strong><br>MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3<br>circularDeque.insertLast(1);        &#x2F;&#x2F; 返回 true<br>circularDeque.insertLast(2);        &#x2F;&#x2F; 返回 true<br>circularDeque.insertFront(3);        &#x2F;&#x2F; 返回 true<br>circularDeque.insertFront(4);        &#x2F;&#x2F; 已经满了，返回 false<br>circularDeque.getRear();  &#x2F;&#x2F; 返回 2<br>circularDeque.isFull();        &#x2F;&#x2F; 返回 true<br>circularDeque.deleteLast();        &#x2F;&#x2F; 返回 true<br>circularDeque.insertFront(4);        &#x2F;&#x2F; 返回 true<br>circularDeque.getFront();&#x2F;&#x2F; 返回 4<br>&nbsp;</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= value &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">insertFront</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">insertLast</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">deleteFront</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">deleteLast</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getFront</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getRear</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isEmpty</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isFull</code>&nbsp; 调用次数不大于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2000</code>&nbsp;次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/design-circular-deque/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 641. 设计循环双端队列</a>。</strong></details></p><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这道题考察的是双端队列的实现，底层可以用链表或数组实现，用链表实现比较简单，用数组的话要用到 <a href="https://labuladong.online/algo/data-structure-basic/cycle-array/">环形数组</a> 的技巧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyArrayDeque</span><span class="token punctuation">:</span>    INIT_CAP <span class="token operator">=</span> <span class="token number">2</span>    <span class="token comment"># 不传参数，默认大小为 INIT_CAP</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_cap<span class="token operator">=</span>INIT_CAP<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> init_cap        <span class="token comment"># last 是下一次应该添加元素的索引</span>        <span class="token comment"># first----last, [first, last)</span>        <span class="token comment"># 比如 first = 1，last = 3，size = 2</span>        self<span class="token punctuation">.</span>first <span class="token operator">=</span> self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 从头部获取元素</span>    <span class="token keyword">def</span> <span class="token function">getFirst</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"getFirst from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>    <span class="token comment"># 从尾部获取元素</span>    <span class="token keyword">def</span> <span class="token function">getLast</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"getLast from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># 从头部插入元素</span>    <span class="token keyword">def</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 情况一：first----last</span>        <span class="token comment"># 情况二：---last  first---</span>        <span class="token comment"># 左移 first，所以 first == 0 是一种特殊情况</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 插入元素</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> e        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 从尾部插入元素</span>    <span class="token keyword">def</span> <span class="token function">addLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 插入元素</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> e        self<span class="token punctuation">.</span>last <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 从头部删除元素</span>    <span class="token keyword">def</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"removeFirst from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>        old_val <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>first <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> old_val    <span class="token comment"># 从尾部删除元素</span>    <span class="token keyword">def</span> <span class="token function">removeLast</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"removeLast from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 情况一：first----last</span>        <span class="token comment"># 情况二：---last  first---</span>        <span class="token comment"># 左移 last，当 last == 0 的时候是特殊情况</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">-=</span> <span class="token number">1</span>        old_val <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span>        <span class="token comment"># 删除元素</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> old_val    <span class="token keyword">def</span> <span class="token function">getSize</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">resize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_cap<span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> new_cap        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>first <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>last <span class="token operator">=</span> self<span class="token punctuation">.</span>size        self<span class="token punctuation">.</span>data <span class="token operator">=</span> temp<span class="token keyword">class</span> <span class="token class-name">MyCircularDeque</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cap <span class="token operator">=</span> k        self<span class="token punctuation">.</span><span class="token builtin">list</span> <span class="token operator">=</span> MyArrayDeque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Adds an item at the front of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">insertFront</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getSize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>addFirst<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Adds an item at the rear of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">insertLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getSize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>addLast<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Deletes an item from the front of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">deleteFront</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>removeFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Deletes an item from the rear of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>removeLast<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Get the front item from the deque.</span>    <span class="token keyword">def</span> <span class="token function">getFront</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Get the last item from the deque.</span>    <span class="token keyword">def</span> <span class="token function">getRear</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getLast<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Checks whether the circular deque is empty or not.</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Checks whether the circular deque is full or not.</span>    <span class="token keyword">def</span> <span class="token function">isFull</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getSize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1670-设计前中后队列"><a href="#1670-设计前中后队列" class="headerlink" title="1670. 设计前中后队列"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_design-front-middle-back-queue">1670. 设计前中后队列</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1670. 设计前中后队列</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/design-front-middle-back-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/design-front-middle-back-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">请你设计一个队列，支持在前，中，后三个位置的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>操作。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你完成<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FrontMiddleBack</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FrontMiddleBack()</code><span>&nbsp;</span>初始化队列。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pushFront(int val)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>添加到队列的<span>&nbsp;</span><strong style="font-weight: 600;">最前面</strong><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pushMiddle(int val)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>添加到队列的<span>&nbsp;</span><strong style="font-weight: 600;">正中间</strong><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pushBack(int val)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>添加到队里的<span>&nbsp;</span><strong style="font-weight: 600;">最后面</strong><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int popFront()</code><span>&nbsp;</span>将<span>&nbsp;</span><strong style="font-weight: 600;">最前面</strong><span>&nbsp;</span>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int popMiddle()</code><span>&nbsp;</span>将<span>&nbsp;</span><b>正中间</b><span>&nbsp;</span>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int popBack()</code><span>&nbsp;</span>将<span>&nbsp;</span><strong style="font-weight: 600;">最后面</strong><span>&nbsp;</span>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">请注意当有<span>&nbsp;</span><strong style="font-weight: 600;">两个</strong><span>&nbsp;</span>中间位置的时候，选择靠前面的位置进行操作。比方说：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">6</code><span>&nbsp;</span>添加到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2, 3, 4, 5]</code><span>&nbsp;</span>的中间位置，结果数组为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2,<span>&nbsp;</span><strong style="font-weight: 600;">6</strong>, 3, 4, 5]</code><span>&nbsp;</span>。</li><li>从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2,<span>&nbsp;</span><strong style="font-weight: 600;">3</strong>, 4, 5, 6]</code><span>&nbsp;</span>的中间位置弹出元素，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">3</code><span>&nbsp;</span>，数组变为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2, 4, 5, 6]</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"][[], [1], [2], [3], [4], [], [], [], [], []]<strong style="font-weight: 600;">输出：</strong>[null, null, null, null, null, 1, 3, 4, 2, -1]<p><strong style="font-weight: 600;">解释：</strong><br>FrontMiddleBackQueue q &#x3D; new FrontMiddleBackQueue();<br>q.pushFront(1);   &#x2F;&#x2F; [<strong style="font-weight: 600;">1</strong>]<br>q.pushBack(2);    &#x2F;&#x2F; [1, <strong style="font-weight: 600;">2</strong>]<br>q.pushMiddle(3);  &#x2F;&#x2F; [1, <strong style="font-weight: 600;">3</strong>, 2]<br>q.pushMiddle(4);  &#x2F;&#x2F; [1, <strong style="font-weight: 600;">4</strong>, 3, 2]<br>q.popFront();     &#x2F;&#x2F; 返回 1 -&gt; [4, 3, 2]<br>q.popMiddle();    &#x2F;&#x2F; 返回 3 -&gt; [4, 2]<br>q.popMiddle();    &#x2F;&#x2F; 返回 4 -&gt; [2]<br>q.popBack();      &#x2F;&#x2F; 返回 2 -&gt; []<br>q.popFront();     &#x2F;&#x2F; 返回 -1 -&gt; [] （队列为空）<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= val &lt;= 10<sup>9</sup></code></li><li>最多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code><span>&nbsp;</span>次<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pushFront</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pushMiddle</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pushBack</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">popFront</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">popMiddle</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">popBack</code><span>&nbsp;</span>。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/design-front-middle-back-queue/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1670. 设计前中后队列</a>。</strong></details></p><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这题有点难度，主要是细节不好把控。常规的队列只能在首尾进行操作，想在中间操作队列，需要在底层把队列切分成 <code>left, right</code> 两个列表，但这里的细节问题就是元素为奇数时两个链表中元素的分配问题。</p><p>直接看代码吧，注释很详细。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/ds-design/">【练习】更多经典设计习题</a></li><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">FrontMiddleBackQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 用两个列表表示队列的左右两部分，一遍从中间操作元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>left <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>right <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 维护左边少右边多的状态，每次增删元素之后都要执行一次</span>    <span class="token keyword">def</span> <span class="token function">balance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 右边最多比左边多一个元素</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 右边多，匀一个给左边</span>            self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 左边多，匀一个给右边</span>            self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pushFront</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pushMiddle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 如果有偶数个元素时，pushMiddle 优先向右边添加</span>            self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pushBack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">popFront</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 如果只有 1 个元素，popFront 的时候，要去右边删除</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        e <span class="token operator">=</span> self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e        <span class="token keyword">def</span> <span class="token function">popMiddle</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            e <span class="token operator">=</span> self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果有奇数个元素时，popMiddle 优先从右边删除</span>            e <span class="token operator">=</span> self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e        <span class="token keyword">def</span> <span class="token function">popBack</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        e <span class="token operator">=</span> self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e        <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2073-买票需要的时间"><a href="#2073-买票需要的时间" class="headerlink" title="2073. 买票需要的时间"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_time-needed-to-buy-tickets">2073. 买票需要的时间</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">2073. 买票需要的时间</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/time-needed-to-buy-tickets/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个人前来排队买票，其中第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>人站在队伍<span>&nbsp;</span><strong style="font-weight: 600;">最前方</strong><span>&nbsp;</span>，第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(n - 1)</code><span>&nbsp;</span>人站在队伍<span>&nbsp;</span><strong style="font-weight: 600;">最后方</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始的整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tickets</code><span>&nbsp;</span>，数组长度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，其中第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>人想要购买的票数为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tickets[i]</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">每个人买票都需要用掉<span>&nbsp;</span><strong style="font-weight: 600;">恰好 1 秒</strong><span>&nbsp;</span>。一个人<span>&nbsp;</span><strong style="font-weight: 600;">一次只能买一张票</strong><span>&nbsp;</span>，如果需要购买更多票，他必须走到&nbsp;<span>&nbsp;</span><strong style="font-weight: 600;">队尾</strong><span>&nbsp;</span>重新排队（<strong style="font-weight: 600;">瞬间<span>&nbsp;</span></strong>发生，不计时间）。如果一个人没有剩下需要买的票，那他将会<span>&nbsp;</span><strong style="font-weight: 600;">离开</strong><span>&nbsp;</span>队伍。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回位于位置<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code>（下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始）的人完成买票需要的时间（以秒为单位）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tickets = [2,3,2], k = 2<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong> - 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tickets = [5,1,1,1], k = 0<strong style="font-weight: 600;">输出：</strong>8<strong style="font-weight: 600;">解释：</strong>- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。- 接下来的 4 轮，只有位置 0 的人在买票。位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == tickets.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= tickets[i] &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= k &lt; n</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 2073. 买票需要的时间</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>既然是排队问题，你用一个队列模拟整个买票过程，然后数一数过了多少秒就行了，不过时间空间复杂度就高了。</p><p>稍微思考一下可以想到更高效的方式：</p><p>首先，第 <code>k</code> 个人离开的时间，其实就是从开始到这个人买完票之后，卖出的总票数。</p><p>那么第 <code>k</code> 个人买完票之后，总共卖了多少票呢？</p><p>排在 <code>k</code> 之前的人最多买了 <code>tickets[k]</code> 张票；而排在 <code>k</code> 之后的人最多买了 <code>tickets[k] - 1</code> 张票。为什么说「最多」呢，因为有的人可能需要的票比较少，买完就直接走了。</p><p>综上，思路就出来了，看代码理解吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">timeRequiredToBuy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tickets<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>tickets<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">:</span>                <span class="token comment"># 前面的人最多买了 tickets[k] 张票</span>                res <span class="token operator">+=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>tickets<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> tickets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 后面的人最多买了 tickets[k] - 1 张票</span>                res <span class="token operator">+=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>tickets<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tickets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】括号类问题汇总</title>
      <link href="/2025/06/14/lian-xi-gua-hao-lei-wen-ti-hui-zong/"/>
      <url>/2025/06/14/lian-xi-gua-hao-lei-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】括号类问题汇总"><a href="#【练习】括号类问题汇总" class="headerlink" title="【练习】括号类问题汇总"></a>【练习】括号类问题汇总</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://labuladong.online/algo/problem-set/parentheses/#_20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7">20. 有效的括号</a></h2><p>对括号的有效性判断多次在笔试中出现，现实中也很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 <code>[]()&#123;&#125;</code>，判断起来有一点难度。</p><p>来看一看力扣第 20 题「<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a>」，输入一个字符串，其中包含 <code>[]()&#123;&#125;</code> 六种括号，请你判断这个字符串组成的括号是否有效：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">20. 有效的括号</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个只包括<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#123;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#125;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'['</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">']'</code>&nbsp;的字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>，判断字符串是否有效。</p><p style="line-height: 1.6; overflow-wrap: break-word;">有效字符串需满足：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()[]{}"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(]"<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>仅由括号<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'()[]&#123;&#125;'</code><span>&nbsp;</span>组成</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 20. 有效的括号</a>。</strong></details><p>解决这个问题之前，我们先降低难度，思考一下，<strong>如果只有一种括号 <code>()</code></strong>，应该如何判断字符串组成的括号是否有效呢？</p><p>假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：</p><p><strong>每个右括号 <code>)</code> 的左边必须有一个左括号 <code>(</code> 和它匹配</strong>。</p><p>比如说字符串 <code>()))((</code> 中，中间的两个右括号<strong>左边</strong>就没有左括号匹配，所以这个括号组合是无效的。</p><p>那么根据这个思路，我们可以写出算法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 待匹配的左括号数量</span>    left <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 遇到右括号</span>            left <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 右括号太多</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment"># 是否所有的左括号都被匹配了</span>    <span class="token keyword">return</span> left <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 <code>left1</code>，<code>left2</code>，<code>left3</code> 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。</p><p>但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 <code>(())</code> 是有效的，但是多种括号的情况下， <code>[(])</code> 显然是无效的。</p><p>仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。</p><p>我们这道题就用一个名为 <code>left</code> 的栈代替之前思路中的 <code>left</code> 变量，<strong>遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">str</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> <span class="token string">'(&#123;['</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是左括号，入栈</span>                left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是右括号</span>                <span class="token keyword">if</span> left <span class="token keyword">and</span> self<span class="token punctuation">.</span>leftOf<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> left<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token comment"># 和最近的左括号不匹配</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 是否所有的左括号都被匹配了</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> left    <span class="token keyword">def</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#125;'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'&#123;'</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'('</span>        <span class="token keyword">return</span> <span class="token string">'['</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_valid-parentheses" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_valid-parentheses" src="https://labuladong.online/algo-visualize/leetcode/valid-parentheses/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>接下来讲另外两个常见的问题，如何通过最小的插入次数将括号变成有效的？</p><h2 id="921-使括号有效的最小添加"><a href="#921-使括号有效的最小添加" class="headerlink" title="921. 使括号有效的最小添加"></a><a href="https://labuladong.online/algo/problem-set/parentheses/#_921-%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%BB%E5%8A%A0">921. 使括号有效的最小添加</a></h2><p>先来个简单的，力扣第 921 题「<a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">使括号有效的最少添加</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">921. 使括号有效的最少添加</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">只有满足下面几点之一，括号字符串才是有效的：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>它是一个空字符串，或者</li><li>它可以被写成&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">AB</code>&nbsp;（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code>&nbsp;与&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">B</code>&nbsp;连接）, 其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">B</code>&nbsp;都是有效字符串，或者</li><li>它可以被写作&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(A)</code>，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code>&nbsp;是有效字符串。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个括号字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s = "()))"</code><span>&nbsp;</span>，你可以插入一个开始括号为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"(()))"</code><span>&nbsp;</span>或结束括号为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"())))"</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">返回<span>&nbsp;</span><em>为使结果字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>有效而必须添加的最少括号数</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "())"<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "((("<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>只包含&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>&nbsp;字符。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 921. 使括号有效的最少添加</a>。</strong></details><p>这其实和前文的判断括号有效性非常类似，我们直接看代码：</p><p>这段代码就是最终解法，<strong>核心思路是以左括号为基准，通过维护对右括号的需求数 <code>need</code>，来计算最小的插入次数</strong>。需要注意两个地方：</p><p><strong>1、当 <code>need == -1</code> 的时候意味着什么</strong>？</p><p>因为只有遇到右括号 <code>)</code> 的时候才会 <code>need--</code>，<code>need == -1</code> 意味着右括号太多了，所以需要插入左括号。</p><p>比如说 <code>s = &quot;))&quot;</code> 这种情况，需要插入 2 个左括号，使得 <code>s</code> 变成 <code>&quot;()()&quot;</code>，才是一个有效括号串。</p><p><strong>2、算法为什么返回 <code>res + need</code></strong>？</p><p>因为 <code>res</code> 记录的左括号的插入次数，<code>need</code> 记录了右括号的需求，当 for 循环结束后，若 <code>need</code> 不为 0，那么就意味着右括号还不够，需要插入。</p><p>比如说 <code>s = &quot;))(&quot;</code> 这种情况，插入 2 个左括号之后，还要再插入 1 个右括号，使得 <code>s</code> 变成 <code>&quot;()()()&quot;</code>，才是一个有效括号串。</p><p>以上就是这道题的思路，接下来我们看一道进阶题目，如果左右括号不是 1:1 配对，会出现什么问题呢？</p><h2 id="1541-平衡括号串的最少插入"><a href="#1541-平衡括号串的最少插入" class="headerlink" title="1541. 平衡括号串的最少插入"></a><a href="https://labuladong.online/algo/problem-set/parentheses/#_1541-%E5%B9%B3%E8%A1%A1%E6%8B%AC%E5%8F%B7%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5">1541. 平衡括号串的最少插入</a></h2><p>这是力扣第 1541 题「<a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">平衡括号字符串的最少插入次数</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1541. 平衡括号字符串的最少插入次数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个括号字符串&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;，它只包含字符&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>&nbsp;。一个括号字符串被称为平衡的当它满足：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>任何左括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>&nbsp;必须对应两个连续的右括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'))'</code>&nbsp;。</li><li>左括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>&nbsp;必须在对应的连续两个右括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'))'</code>&nbsp;之前。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">比方说&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"())"</code>，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"())(())))"</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"(())())))"</code>&nbsp;都是平衡的，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">")()"</code>，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"()))"</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"(()))"</code>&nbsp;都是不平衡的。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回让<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;平衡的最少插入次数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(()))"<strong style="font-weight: 600;">输出：</strong>1<strong style="font-weight: 600;">解释：</strong>第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "())"<strong style="font-weight: 600;">输出：</strong>0<strong style="font-weight: 600;">解释：</strong>字符串已经平衡了。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "))())("<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(((((("<strong style="font-weight: 600;">输出：</strong>12<strong style="font-weight: 600;">解释：</strong>添加 12 个 ')' 得到平衡字符串。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 5：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = ")))))))"<strong style="font-weight: 600;">输出：</strong>5<strong style="font-weight: 600;">解释：</strong>在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;只包含&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1541. 平衡括号字符串的最少插入次数</a>。</strong></details><p>现在假设 1 个左括号需要匹配 2 个右括号才叫做有效的括号组合，那么给你输入一个括号串 <code>s</code>，请问你如何计算使得 <code>s</code> 有效的最小插入次数呢？</p><p><strong>核心思路还是和刚才一样，通过一个 <code>need</code> 变量记录对右括号的需求数，根据 <code>need</code> 的变化来判断是否需要插入</strong>。</p><p>第一步，我们按照刚才的思路正确维护 <code>need</code> 变量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">minInsertions</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>     <span class="token comment"># need 记录需右括号的需求量</span>    res <span class="token operator">=</span> <span class="token number">0</span>     need <span class="token operator">=</span> <span class="token number">0</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 一个左括号对应两个右括号</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>             need <span class="token operator">+=</span> <span class="token number">2</span>         <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>             need <span class="token operator">-=</span> <span class="token number">1</span>     <span class="token keyword">return</span> res <span class="token operator">+</span> need<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在想一想，当 <code>need</code> 为什么值的时候，我们可以确定需要进行插入？</p><p><strong>首先，类似第一题，当 <code>need == -1</code> 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号</strong>。</p><p>比如说当 <code>s = &quot;)&quot;</code>，我们肯定需要插入一个左括号让 <code>s = &quot;()&quot;</code>，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    need<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// 说明右括号太多了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 需要插入一个左括号</span>        res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 同时，对右括号的需求变为 1</span>        need <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号</strong>。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。</p><p>所以遇到左括号时要做如下判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    need <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 插入一个右括号</span>        res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 对右括号的需求减一</span>        need<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，我们可以写出正确的代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minInsertions</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># need 记录需右括号的需求量</span>        res <span class="token operator">=</span> <span class="token number">0</span>        need <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 一个左括号对应两个右括号</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>                need <span class="token operator">+=</span> <span class="token number">2</span>                <span class="token keyword">if</span> need <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 插入一个右括号</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>                    need <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>                need <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token comment"># 说明右括号太多了</span>                <span class="token keyword">if</span> need <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 需要插入一个左括号</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token comment"># 同时，对右括号的需求变为 1</span>                    need <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res <span class="token operator">+</span> need<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/06/14/lian-xi-gua-hao-lei-wen-ti-hui-zong/5.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】栈的经典习题</title>
      <link href="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】栈的经典习题"><a href="#【练习】栈的经典习题" class="headerlink" title="【练习】栈的经典习题"></a>【练习】栈的经典习题</h1><h2 id="考察先进后出性质"><a href="#考察先进后出性质" class="headerlink" title="考察先进后出性质"></a>考察先进后出性质</h2><p>对于栈这种数据结构的考察，主要考察先进后出特点的运用，比如表达式运算、括号合法性检测等问题，下面列出几个使用栈的经典场景。</p><h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_simplify-path">71. 简化路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">71. 简化路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/simplify-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/simplify-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">path</code><span>&nbsp;</span>，表示指向某一文件或目录的 Unix 风格<span>&nbsp;</span><strong style="font-weight: 600;">绝对路径<span>&nbsp;</span></strong>（以<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>开头），请你将其转化为更加简洁的规范路径。</p><p class="MachineTrans-lang-zh-CN" style="line-height: 1.6; overflow-wrap: break-word;">在 Unix 风格的文件系统中，一个点（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">.</code>）表示当前目录本身；此外，两个点 （<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'//'</code>）都被视为单个斜杠<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>。 对于此问题，任何其他格式的点（例如，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'...'</code>）均被视为文件/目录名称。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请注意，返回的<span>&nbsp;</span><strong style="font-weight: 600;">规范路径</strong><span>&nbsp;</span>必须遵循下述格式：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>始终以斜杠<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>开头。</li><li>两个目录名之间必须只有一个斜杠<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>。</li><li>最后一个目录名（如果存在）<strong style="font-weight: 600;">不能<span>&nbsp;</span></strong>以<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'.'</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'..'</code>）。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">返回简化后得到的<span>&nbsp;</span><strong style="font-weight: 600;">规范路径</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/home/"<strong style="font-weight: 600;">输出：</strong>"/home"<strong style="font-weight: 600;">解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/../"<strong style="font-weight: 600;">输出：</strong>"/"<strong style="font-weight: 600;">解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/home//foo/"<strong style="font-weight: 600;">输出：</strong>"/home/foo"<strong style="font-weight: 600;">解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/a/./b/../../c/"<strong style="font-weight: 600;">输出：</strong>"/c"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= path.length &lt;= 3000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">path</code><span>&nbsp;</span>由英文字母，数字，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'.'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'_'</code><span>&nbsp;</span>组成。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">path</code><span>&nbsp;</span>是一个有效的 Unix 风格绝对路径。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/simplify-path/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 71. 简化路径</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这题比较简单，利用栈先进后出的特性处理上级目录 <code>..</code>，最后组装化简后的路径即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">simplifyPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        parts <span class="token operator">=</span> path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 借助栈计算最终的文件夹路径</span>        <span class="token keyword">for</span> part <span class="token keyword">in</span> parts<span class="token punctuation">:</span>            <span class="token keyword">if</span> part <span class="token operator">==</span> <span class="token string">""</span> <span class="token keyword">or</span> part <span class="token operator">==</span> <span class="token string">"."</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> part <span class="token operator">==</span> <span class="token string">".."</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> stk<span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>part<span class="token punctuation">)</span>        <span class="token comment"># 栈中存储的文件夹组成路径</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">while</span> stk<span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> res        <span class="token keyword">return</span> res <span class="token keyword">if</span> res <span class="token keyword">else</span> <span class="token string">"/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_simplify-path" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_simplify-path" src="https://labuladong.online/algo-visualize/leetcode/simplify-path/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_reorder-list">143. 重排链表</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">143. 重排链表</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/reorder-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/reorder-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个单链表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">L</code><em><span>&nbsp;</span></em>的头节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code><span>&nbsp;</span>，单链表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">L</code><span>&nbsp;</span>表示为：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">L<sub>0</sub> → L<sub>1</sub> → … → L<sub>n - 1</sub> → L<sub>n</sub></pre><p style="line-height: 1.6; overflow-wrap: break-word;">请将其重新排列后变为：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">L<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n - 1</sub> → L<sub>2</sub> → L<sub>n - 2</sub> → …</pre><p style="line-height: 1.6; overflow-wrap: break-word;">不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/1626420311-PkUiGI-image.png" style="max-width: 100%; width: 240px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [1,2,3,4]<strong style="font-weight: 600;">输出：</strong>[1,4,2,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/1626420320-YUiulT-image.png" style="max-width: 100%; width: 320px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [1,2,3,4,5]<strong style="font-weight: 600;">输出：</strong>[1,5,2,4,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>链表的长度范围为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 5 * 10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/reorder-list/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 143. 重排链表</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这题的难点在于：一个单链表只能从头部向尾部遍历节点，无法从尾部开始向头部遍历节点。</p><p>那么我们可以利用「栈」先进后出的结构特点，按从头到尾的顺序让链表节点入栈，那么出栈顺序就是反过来从尾到头了。</p><p>有了这个栈，算法的大致逻辑如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">//</span> 链表尾部的节点    ListNode lastNode <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 按题目要求拼接    ListNode <span class="token builtin">next</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> lastNode<span class="token punctuation">;</span>    lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，处理单链表时细节问题比较多，注意操作指针时的顺序，避免操作失误形成环形链表，直接看我的代码注释吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 先把所有节点装进栈里，得到倒序结果</span>        p <span class="token operator">=</span> head        <span class="token keyword">while</span> p <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>        p <span class="token operator">=</span> head        <span class="token keyword">while</span> p <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 链表尾部的节点</span>            lastNode <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token builtin">next</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token keyword">if</span> lastNode <span class="token operator">==</span> <span class="token builtin">next</span> <span class="token keyword">or</span> lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">==</span> <span class="token builtin">next</span><span class="token punctuation">:</span>                <span class="token comment"># 结束条件，链表节点数为奇数或偶数时均适用</span>                lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>                <span class="token keyword">break</span>            p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> lastNode            lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span>            p <span class="token operator">=</span> <span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_reorder-list" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_reorder-list" src="https://labuladong.online/algo-visualize/leetcode/reorder-list/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/LGjMqU">剑指 Offer II 026. 重排链表 🟠</a></li></ul><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_valid-parentheses">20. 有效的括号</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">20. 有效的括号</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个只包括<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#123;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#125;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'['</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">']'</code>&nbsp;的字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>，判断字符串是否有效。</p><p style="line-height: 1.6; overflow-wrap: break-word;">有效字符串需满足：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()[]{}"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(]"<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>仅由括号<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'()[]&#123;&#125;'</code><span>&nbsp;</span>组成</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 20. 有效的括号</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。</p><p>括号的有效性判断在笔试中和现实中都很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 <code>[]()&#123;&#125;</code>，判断起来有一点难度。</p><p>解决这个问题之前，我们先降低难度，思考一下，<strong>如果只有一种括号 <code>()</code></strong>，应该如何判断字符串组成的括号是否有效呢？</p><p>假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：</p><p><strong>每个右括号 <code>)</code> 的左边必须有一个左括号 <code>(</code> 和它匹配</strong>。</p><p>比如说字符串 <code>()))((</code> 中，中间的两个右括号<strong>左边</strong>就没有左括号匹配，所以这个括号组合是无效的。</p><p>那么根据这个思路，我们可以写出算法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 待匹配的左括号数量</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 遇到右括号</span>            left<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 右括号太多</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 是否所有的左括号都被匹配了</span>    <span class="token keyword">return</span> left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 <code>left1</code>，<code>left2</code>，<code>left3</code> 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。</p><p>但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 <code>(())</code> 是有效的，但是多种括号的情况下， <code>[(])</code> 显然是无效的。</p><p>仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。</p><p>我们这道题就用一个名为 <code>left</code> 的栈代替之前思路中的 <code>left</code> 变量，<strong>遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</strong>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">str</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> <span class="token string">'(&#123;['</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是左括号，入栈</span>                left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是右括号</span>                <span class="token keyword">if</span> left <span class="token keyword">and</span> self<span class="token punctuation">.</span>leftOf<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> left<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token comment"># 和最近的左括号不匹配</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 是否所有的左括号都被匹配了</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> left    <span class="token keyword">def</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#125;'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'&#123;'</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'('</span>        <span class="token keyword">return</span> <span class="token string">'['</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_valid-parentheses" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_valid-parentheses" src="https://labuladong.online/algo-visualize/leetcode/valid-parentheses/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_evaluate-reverse-polish-notation">150. 逆波兰表达式求值</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">150. 逆波兰表达式求值</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个字符串数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tokens</code><span>&nbsp;</span>，表示一个根据&nbsp;<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">逆波兰表示法</a><span>&nbsp;</span>表示的算术表达式。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你计算该表达式。返回一个表示表达式值的整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>有效的算符为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'+'</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'-'</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'*'</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是<span>&nbsp;</span><strong style="font-weight: 600;">向零截断</strong><span>&nbsp;</span>。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用<span>&nbsp;</span><strong style="font-weight: 600;">32 位</strong><span>&nbsp;</span>整数表示。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tokens = ["2","1","+","3","*"]<strong style="font-weight: 600;">输出：</strong>9<strong style="font-weight: 600;">解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tokens = ["4","13","5","/","+"]<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]<strong style="font-weight: 600;">输出：</strong>22<strong style="font-weight: 600;">解释：</strong>该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tokens[i]</code>&nbsp;是一个算符（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"+"</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"-"</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"*"</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"/"</code>），或是在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-200, 200]</code><span>&nbsp;</span>内的一个整数</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">逆波兰表达式：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;">逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>平常使用的算式则是一种中缀表达式，如<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">( 1 + 2 ) * ( 3 + 4 )</code><span>&nbsp;</span>。</li><li>该算式的逆波兰表达式写法为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">( ( 1 2 + ) ( 3 4 + ) * )</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">逆波兰表达式主要有以下两个优点：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>去掉括号后表达式无歧义，上式即便写成<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 2 + 3 4 + *<span>&nbsp;</span></code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 150. 逆波兰表达式求值</a>。</strong></details><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>逆波兰表达式发明出来就是为了方便计算机运用「栈」进行表达式运算的，其运算规则如下：</p><p>按顺序遍历逆波兰表达式中的字符，如果是数字，则放入栈；如果是运算符，则将栈顶的两个元素拿出来进行运算，再将结果放入栈。对于减法和除法，运算顺序别搞反了，栈顶第二个数是被除（减）数。</p><p>所以这题很简单，直接按照运算规则借助栈计算表达式结果即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> token <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>            <span class="token keyword">if</span> token <span class="token keyword">in</span> <span class="token string">"+-*/"</span><span class="token punctuation">:</span>                <span class="token comment"># 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈</span>                a <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>                <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span>                <span class="token comment"># 对于减法和除法，顺序别搞反了，第二个数是被除（减）数</span>                <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span>                <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>b <span class="token operator">/</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># Ensure the result is an integer</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 是个数字，直接入栈即可</span>                stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 最后栈中剩下一个数字，即是计算结果</span>        <span class="token keyword">return</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_evaluate-reverse-polish-notation" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_evaluate-reverse-polish-notation" src="https://labuladong.online/algo-visualize/leetcode/evaluate-reverse-polish-notation/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/8Zf90G">剑指 Offer II 036. 后缀表达式 🟠</a></li></ul><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_implement-stack-using-queues">225. 用队列实现栈</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">225. 用队列实现栈</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/implement-stack-using-queues/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/implement-stack-using-queues/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">empty</code>）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyStack</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void push(int x)</code><span>&nbsp;</span>将元素 x 压入栈顶。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int pop()</code><span>&nbsp;</span>移除并返回栈顶元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int top()</code><span>&nbsp;</span>返回栈顶元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean empty()</code><span>&nbsp;</span>如果栈是空的，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>你只能使用队列的标准操作 —— 也就是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push to back</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">peek/pop from front</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">size</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">is empty</code>&nbsp;这些操作。</li><li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["MyStack", "push", "push", "top", "pop", "empty"][[], [1], [2], [], [], []]<strong style="font-weight: 600;">输出：</strong>[null, null, null, 2, 2, false]<p><strong style="font-weight: 600;">解释：</strong><br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= x &lt;= 9</code></li><li>最多调用<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>次<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">empty</code></li><li>每次调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>都保证栈不为空</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你能否仅用一个队列来实现栈。</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/implement-stack-using-queues/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 225. 用队列实现栈</a>。</strong></details></p><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>底层用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。</p><p>底层队列只能向队尾添加元素，所以栈的 <code>pop</code> API 相当于要从队尾取元素：</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/5.jpg" alt="img"></p><p>那么最简单的思路就是，把队尾元素前面的所有元素重新塞到队尾，让队尾元素排到队头，这样就可以取出了：</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/6.jpg" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/data-structure/stack-queue/">队列实现栈以及栈实现队列</a></li><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 将元素 x 压入栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># x 是队列的队尾，是栈的栈顶</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> x    <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top_elem    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>        <span class="token comment"># 留下队尾 2 个元素</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 记录新的队尾元素</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 删除之前的队尾元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 判断栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232. 用栈实现队列 🟢</a></li><li><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">剑指 Offer 09. 用两个栈实现队列 🟢</a></li></ul><h2 id="388-文件的最长绝对路径"><a href="#388-文件的最长绝对路径" class="headerlink" title="388. 文件的最长绝对路径"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_longest-absolute-file-path">388. 文件的最长绝对路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">388. 文件的最长绝对路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/longest-absolute-file-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/longest-absolute-file-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/28/mdir.jpg" style="max-width: 100%; height: 142px; width: 300px;"></p><p style="line-height: 1.6; overflow-wrap: break-word;">这里将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">dir</code><span>&nbsp;</span>作为根目录中的唯一目录。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">dir</code><span>&nbsp;</span>包含两个子目录<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir2</code><span>&nbsp;</span>。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir1</code><span>&nbsp;</span>包含文件<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">file1.ext</code><span>&nbsp;</span>和子目录<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subsubdir1</code>；<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir2</code><span>&nbsp;</span>包含子目录<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subsubdir2</code>，该子目录下包含文件<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">file2.ext</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">在文本格式中，如下所示(⟶表示制表符)：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">dir⟶ subdir1⟶ ⟶ file1.ext⟶ ⟶ subsubdir1⟶ subdir2⟶ ⟶ subsubdir2⟶ ⟶ ⟶ file2.ext</pre><p style="line-height: 1.6; overflow-wrap: break-word;">如果是代码表示，上面的文件系统可以写为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</code><span>&nbsp;</span>。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\n'</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\t'</code><span>&nbsp;</span>分别是换行符和制表符。</p><p style="line-height: 1.6; overflow-wrap: break-word;">文件系统中的每个文件和文件夹都有一个唯一的<span>&nbsp;</span><strong style="font-weight: 600;">绝对路径</strong><span>&nbsp;</span>，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>连接。上面例子中，指向<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">file2.ext</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">绝对路径</strong><span>&nbsp;</span>是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"dir/subdir2/subsubdir2/file2.ext"</code><span>&nbsp;</span>。每个目录名由字母、数字和/或空格组成，每个文件名遵循<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">name.extension</code><span>&nbsp;</span>的格式，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">name</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">extension</code>由字母、数字和/或空格组成。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个以上述格式表示文件系统的字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">input</code><span>&nbsp;</span>，返回文件系统中&nbsp;<em>指向&nbsp;<strong style="font-weight: 600;">文件</strong>&nbsp;的<span>&nbsp;</span><strong style="font-weight: 600;">最长绝对路径</strong><span>&nbsp;</span>的长度</em>&nbsp;。 如果系统中没有文件，返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/28/dir1.jpg" style="max-width: 100%; height: 101px; width: 200px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"<strong style="font-weight: 600;">输出：</strong>20<strong style="font-weight: 600;">解释：</strong>只有一个文件，绝对路径为 "dir/subdir2/file.ext" ，路径长度 20</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/28/dir2.jpg" style="max-width: 100%; height: 151px; width: 300px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"<strong style="font-weight: 600;">输出：</strong>32<strong style="font-weight: 600;">解释：</strong>存在两个文件："dir/subdir1/file1.ext" ，路径长度 21"dir/subdir2/subsubdir2/file2.ext" ，路径长度 32返回 32 ，因为这是最长的路径</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "a"<strong style="font-weight: 600;">输出：</strong>0<strong style="font-weight: 600;">解释：</strong>不存在任何文件</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "file1.txt\nfile2.txt\nlongfile.txt"<strong style="font-weight: 600;">输出：</strong>12<strong style="font-weight: 600;">解释：</strong>根目录下有 3 个文件。因为根目录中任何东西的绝对路径只是名称本身，所以答案是 "longfile.txt" ，路径长度为 12</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= input.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">input</code><span>&nbsp;</span>可能包含小写或大写的英文字母，一个换行符<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\n'</code>，一个制表符<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\t'</code>，一个点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'.'</code>，一个空格<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">' '</code>，和数字。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/longest-absolute-file-path/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 388. 文件的最长绝对路径</a>。</strong></details><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>我觉得这道题还是比较实用的，因为在我做这道题之前，我就思考并解决过这个问题，可以在这里和大家分享下我的使用场景：</p><p>你可以看我的 <a href="https://github.com/labuladong/fucking-algorithm#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">GitHub 仓库中的文章目录</a>，是通过缩进来表示层级的，很类似本题所说的场景。然而我需要把这些目录转化成 HTML 文档，按照文件目录的形式把这些 HTML 部署到 <a href="https://labuladong.gitee.io/algo/">我的网站</a> 上。你看，这是不是就涉及到本题生成文件的绝对路径的问题？</p><p>对于这个场景，我当时其实尝试很多可行的办法。但这里我还是写一个最简单直接容易理解的解法吧，那就是用栈来辅助，对于每一个路径，都去维护正确的父路径，从而计算最长路径的长度。具体看代码注释吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthLongestPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 这个栈存储之前的父路径。实际上这里只用存父路径的长度就够了，这个优化留给你吧</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        max_len <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> part <span class="token keyword">in</span> <span class="token builtin">input</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            level <span class="token operator">=</span> part<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment"># 让栈中只保留当前目录的父路径</span>            <span class="token keyword">while</span> level <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span> <span class="token operator">-</span> level<span class="token punctuation">)</span>            <span class="token comment"># 如果是文件，就计算路径长度</span>            <span class="token keyword">if</span> <span class="token string">"."</span> <span class="token keyword">in</span> part<span class="token punctuation">:</span>                total_length <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>                <span class="token comment"># 加上父路径的分隔符</span>                max_len <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>max_len<span class="token punctuation">,</span> total_length<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的设计题"><a href="#栈的设计题" class="headerlink" title="栈的设计题"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E6%A0%88%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98">栈的设计题</a></h2><p>除了上面几道题，还有一类常考题目是让你设计具备额外功能的栈结构。</p><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_min-stack">155. 最小栈</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">155. 最小栈</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/min-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/min-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个支持<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code><span>&nbsp;</span>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>操作，并能在常数时间内检索到最小元素的栈。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MinStack</code><span>&nbsp;</span>类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MinStack()</code><span>&nbsp;</span>初始化堆栈对象。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void push(int val)</code><span>&nbsp;</span>将元素val推入堆栈。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pop()</code><span>&nbsp;</span>删除堆栈顶部的元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int top()</code><span>&nbsp;</span>获取堆栈顶部的元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int getMin()</code><span>&nbsp;</span>获取堆栈中的最小元素。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]<p><strong style="font-weight: 600;">输出：</strong><br>[null,null,null,null,-3,null,0,-2]</p><p><strong style="font-weight: 600;">解释：</strong><br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getMin</code><span>&nbsp;</span>操作总是在<span>&nbsp;</span><strong style="font-weight: 600;">非空栈</strong><span>&nbsp;</span>上调用</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code>, and&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getMin</code>最多被调用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">3 * 10<sup>4</sup></code>&nbsp;次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/min-stack/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 155. 最小栈</a>。</strong></details></p><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p><a href="https://labuladong.online/algo/data-structure-basic/queue-stack-basic/">根据我们之前亲自动手实现的栈</a>，我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 <code>getMin</code> 方法，只能老老实实把所有元素弹出来然后找最小值。<strong>想提高时间效率，那肯定要通过空间换时间的思路</strong>。</p><p>不过在具体说解法之前，我想聊一下动态集合中维护最值的问题。这类问题看似简单，但实际上是个很棘手的问题。其实本题就是如下一个场景：</p><p>假设你有若干数字，你用一个 <code>min</code> 变量维护了其中的最小值，如果现在给这些数字中添加一个新数字，那么只要比较这个新数字和 <code>min</code> 的大小就可以得出最新的最小值。但如果现在从这些数字钟删除一个数字，你还能用 <code>min</code> 变量得到最小值吗？答案是不能，因为如果这个被删除的数字恰好是最小值，那么新的 <code>min</code> 变量应该更新为第二小的元素对吧，但是我没有记录第二小的元素是多少，所以只能把所有数字重新遍历一遍。</p><p>明确了难点再回到本题，就可以对症下药了。删除栈顶元素的时候，不确定新的最小值是多少，但楼下那哥们知道啊，他当时入栈时的最小值，就是现在的最小值呗。</p><p>所以这道题的关键就是，<strong>每个元素入栈时，还要记下来当前栈中的最小值</strong>。比方说，可以用一个额外的栈 <code>minStk</code> 来记录栈中每个元素入栈时的栈中的最小元素是多少，这样每次删除元素时就能快速得到剩余栈中的最小元素了。</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/155.jpeg" alt="img"></p><p>当然，我们还可以做一些优化，减少 <code>minStk</code> 中存储的元素个数，我把原始解法和优化解法都写出来了，供参考。</p><blockquote><p>PS：这道题并不难，但我还是很细致地分析了，希望你深刻理解其中的难点。下一步可以做一下 <a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值</a>，请仔细观察和思考，队列结构是如何解决这个难点的。</p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/ds-design/">【练习】更多经典设计习题</a></li><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 原始思路</span><span class="token keyword">class</span> <span class="token class-name">MinStack1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录栈中的所有元素</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 阶段性记录栈中的最小元素</span>        self<span class="token punctuation">.</span>minStk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 维护 minStk 栈顶为全栈最小元素</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>minStk <span class="token keyword">or</span> val <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 新插入的这个元素就是全栈最小的</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 插入的这个元素比较大</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minStk 栈顶为全栈最小元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 优化版</span><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录栈中的所有元素</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 阶段性记录栈中的最小元素</span>        self<span class="token punctuation">.</span>minStk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 维护 minStk 栈顶为全栈最小元素</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>minStk <span class="token keyword">or</span> val <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 新插入的这个元素就是全栈最小的</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 注意 Java 的语言特性，比较 Integer 相等要用 equals 方法</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 弹出的元素是全栈最小的</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minStk 栈顶为全栈最小元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值 🔴</a></li><li><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">剑指 Offer 30. 包含min函数的栈 🟢</a></li><li><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">剑指 Offer 59 - I. 滑动窗口的最大值 🔴</a></li></ul><h2 id="895-最大频率栈"><a href="#895-最大频率栈" class="headerlink" title="895. 最大频率栈"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_maximum-frequency-stack">895. 最大频率栈</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">895. 最大频率栈</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-frequency-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-frequency-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong style="font-weight: 600;">出现频率</strong>最高的元素。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FreqStack</code>&nbsp;类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FreqStack()</code>&nbsp;构造一个空的堆栈。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void push(int val)</code>&nbsp;将一个整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code>&nbsp;压入栈顶。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int pop()</code>&nbsp;删除并返回堆栈中出现频率最高的元素。<ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<strong style="font-weight: 600;">输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]<strong style="font-weight: 600;">解释：</strong>FreqStack = new FreqStack();freqStack.push (5);//堆栈为 [5]freqStack.push (7);//堆栈是 [5,7]freqStack.push (5);//堆栈是 [5,7,5]freqStack.push (7);//堆栈是 [5,7,5,7]freqStack.push (4);//堆栈是 [5,7,5,7,4]freqStack.push (5);//堆栈是 [5,7,5,7,4,5]freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= val &lt;= 10<sup>9</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>&nbsp;和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>&nbsp;的操作数不大于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2 * 10<sup>4</sup></code>。</li><li>输入保证在调用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>&nbsp;之前堆栈中至少有一个元素。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-frequency-stack/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 895. 最大频率栈</a>。</strong></details><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-7">基本思路</a></h3><p><strong>这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API</strong>。</p><p>那么，我们仔细思考一下 <code>push</code> 和 <code>pop</code> 方法，难点如下：</p><p>1、每次 <code>pop</code> 时，必须要知道频率最高的元素是什么。</p><p>2、如果频率最高的元素有多个，还得知道哪个是最近 <code>push</code> 进来的元素是哪个。</p><p>为了实现上述难点，我们要做到以下几点：</p><p>1、肯定要有一个变量 <code>maxFreq</code> 记录当前栈中最高的频率是多少。</p><p>2、我们得知道一个频率 <code>freq</code> 对应的元素有哪些，且这些元素要有时间顺序。</p><p>3、随着 <code>pop</code> 的调用，每个 <code>val</code> 对应的频率会变化，所以还得维持一个映射记录每个 <code>val</code> 对应的 <code>freq</code>。</p><p>综上，我们可以先实现 <code>FreqStack</code> 所需的数据结构：</p><pre class="line-numbers language-none"><code class="language-none">class FreqStack &#123;    &#x2F;&#x2F; 记录 FreqStack 中元素的最大频率    int maxFreq &#x3D; 0;    &#x2F;&#x2F; 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表    HashMap&lt;Integer, Integer&gt; valToFreq &#x3D; new HashMap&lt;&gt;();    &#x2F;&#x2F; 记录频率 freq 对应的 val 列表，后文就称为 FV 表    HashMap&lt;Integer, Stack&lt;Integer&gt;&gt; freqToVals &#x3D; new HashMap&lt;&gt;();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这有点类似后文 <a href="https://labuladong.online/algo/frequency-interview/lfu/">手把手实现 LFU 算法</a>，注意 <code>freqToVals</code> 中 <code>val</code> 列表用一个栈实现，如果一个 <code>freq</code> 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。</p><p>具体看解法代码吧，要记住在 <code>push</code> 和 <code>pop</code> 方法中同时修改 <code>maxFreq</code>、<code>VF</code> 表、<code>FV</code> 表，否则容易出现 bug。</p><p>算法执行过程如下 GIF 所示：</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/1.gif" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/ds-design/">【练习】更多经典设计习题</a></li><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-7"><a href="#解法代码-7" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-7">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">FreqStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 FreqStack 中元素的最大频率</span>        self<span class="token punctuation">.</span>maxFreq <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表</span>        self<span class="token punctuation">.</span>valToFreq <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment"># 记录频率 freq 对应的 val 列表，后文就称为 FV 表</span>        self<span class="token punctuation">.</span>freqToVals <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 修改 VF 表：val 对应的 freq 加一</span>        freq <span class="token operator">=</span> self<span class="token punctuation">.</span>valToFreq<span class="token punctuation">.</span>get<span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>valToFreq<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> freq        <span class="token comment"># 修改 FV 表：在 freq 对应的列表加上 val</span>        <span class="token keyword">if</span> freq <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">[</span>freq<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 更新 maxFreq</span>        self<span class="token punctuation">.</span>maxFreq <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxFreq<span class="token punctuation">,</span> freq<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 修改 FV 表：pop 出一个 maxFreq 对应的元素 v</span>        vals <span class="token operator">=</span> self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">[</span>self<span class="token punctuation">.</span>maxFreq<span class="token punctuation">]</span>        v <span class="token operator">=</span> vals<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 修改 VF 表：v 对应的 freq 减一</span>        self<span class="token punctuation">.</span>valToFreq<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 更新 maxFreq</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> vals<span class="token punctuation">:</span>            <span class="token comment"># 如果 maxFreq 对应的元素空了</span>            self<span class="token punctuation">.</span>maxFreq <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列实现栈以及栈实现队列</title>
      <link href="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/"/>
      <url>/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h1><p>队列是一种先进先出的数据结构，栈是一种先进后出的数据结构，形象一点就是这样：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/1.jpg" alt="img"></p><p>这两种数据结构底层其实都是数组或者链表实现的，只是 API 限定了它们的特性</p><p>今天来看看如何使用「栈」的特性来实现一个「队列」，如何用「队列」实现一个「栈」。</p><h3 id="一、用栈实现队列"><a href="#一、用栈实现队列" class="headerlink" title="一、用栈实现队列"></a><a href="https://labuladong.online/algo/data-structure/stack-queue/#%E4%B8%80%E3%80%81%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">一、用栈实现队列</a></h3><p>力扣第 232 题「<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a>」让我们实现的 API 如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">lass MyQueue<span class="token punctuation">:</span>    <span class="token comment"># 添加元素到队尾</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 删除队头的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 返回队头元素</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 判断队列是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用两个栈 <code>s1, s2</code> 就能实现一个队列的功能（这样放置栈可能更容易理解）：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/2.jpg" alt="img"></p><p>当调用 <code>push</code> 让元素入队时，只要把元素压入 <code>s1</code> 即可，比如说 <code>push</code> 进 3 个元素分别是 1,2,3，那么底层结构就是这样：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/3.jpg" alt="img"></p><p>那么如果这时候使用 <code>peek</code> 查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在 <code>s1</code> 中 1 被压在栈底，现在就要轮到 <code>s2</code> 起到一个中转的作用了：当 <code>s2</code> 为空时，可以把 <code>s1</code> 的所有元素取出再添加进 <code>s2</code>，<strong>这时候 <code>s2</code> 中元素就是先进先出顺序了</strong>：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/4.jpg" alt="img"></p><p>当 <code>s2</code> 中存在元素时，直接调用操作 <code>s2</code> 的 <code>pop</code> 方法，弹出的就是最先插入的元素，即实现了队列的 <code>pop</code> 操作。</p><p>完整代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用两个栈s1和s2</span>        self<span class="token punctuation">.</span>s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 添加元素到队尾</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment"># 返回队头元素</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>s2<span class="token punctuation">:</span>            <span class="token comment"># 把 s1 元素压入 s2</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>s1<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>s2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>s2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># 删除队头元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 先调用 peek 保证 s2 非空</span>        self<span class="token punctuation">.</span>peek<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>s2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 判断队列是否为空</span>    <span class="token comment"># 两个栈都为空才说明队列为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>s1 <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>s2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，就用栈结构实现了一个队列，核心思想是利用两个栈互相配合。</p><p>值得一提的是，这几个操作的时间复杂度是多少呢？</p><p>有点意思的是 <code>peek</code> 操作，调用它时可能触发 <code>while</code> 循环，这样的话时间复杂度是 O(N)，但是大部分情况下 <code>while</code> 循环不会被触发，时间复杂度是 O(1)。由于 <code>pop</code> 操作调用了 <code>peek</code>，它的时间复杂度和 <code>peek</code> 相同。</p><p>像这种情况，可以说它们的<strong>最坏时间复杂度</strong>是 O(N)，因为包含 <code>while</code> 循环，<strong>可能</strong>需要从 <code>s1</code> 往 <code>s2</code> 搬移元素。</p><p>但是它们的<strong>均摊时间复杂度</strong>是 O(1)，这个要这么理解：对于一个元素，最多只可能被搬运一次，也就是说 <code>peek</code> 操作平均到每个元素的时间复杂度是 O(1)。</p><h3 id="二、用队列实现栈"><a href="#二、用队列实现栈" class="headerlink" title="二、用队列实现栈"></a><a href="https://labuladong.online/algo/data-structure/stack-queue/#%E4%BA%8C%E3%80%81%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">二、用队列实现栈</a></h3><p>如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构就能实现了。</p><p>力扣第 225 题「<a href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈</a>」让我们实现如下 API：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token comment"># 添加元素到栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 判断栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先说 <code>push</code> API，直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 <code>top</code> 查看栈顶元素的话可以直接返回：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用一个队列 q 来实现一个栈</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 栈顶元素</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 添加元素到栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># x 是队列的队尾，是栈的栈顶</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> x        <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top_elem    <span class="token comment"># 检查栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的底层数据结构是先进先出的队列，每次 <code>pop</code> 只能从队头取元素；但是栈是后进先出，也就是说 <code>pop</code> API 要从队尾取元素：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/5.jpg" alt="img"></p><p>解决方法简单粗暴，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出了：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/6.jpg" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token comment"># 为了节约篇幅，省略上文给出的代码部分...</span>    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 之前的队尾元素已经到了队头</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样实现还有一点小问题就是，原来的队尾元素被推到队头并删除了，但是 <code>top_elem</code> 变量没有更新，我们还需要一点小修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token comment"># 为了节约篇幅，省略上文给出的代码部分...</span>    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>        <span class="token comment"># 留下队尾 2 个元素</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 记录新的队尾元素</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 删除之前的队尾元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就实现完了，完整的代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 添加元素到栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> x    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top_elem    <span class="token comment"># 判断栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，用队列实现栈的话，<code>pop</code> 操作时间复杂度是 O(N)，其他操作都是 O(1)。</p><p>个人认为，用队列实现栈是没啥亮点的问题，但是用双栈实现队列是值得学习的。</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/4.jpg" alt="img"></p><p>从栈 <code>s1</code> 搬运元素到 <code>s2</code> 之后，元素在 <code>s2</code> 中就变成了队列的先进先出顺序，这个特性有点类似「负负得正」，确实不太容易想到。</p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的花式反转方法汇总</title>
      <link href="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/"/>
      <url>/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="反转整个单链表"><a href="#反转整个单链表" class="headerlink" title="反转整个单链表"></a>反转整个单链表</h2><p>在 力扣&#x2F;LeetCode 中，单链表的通用结构是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 单链表节点的结构</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单链表反转是一个比较基础的算法题，力扣第 206 题 <a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a> 就是这个问题：</p><p>下面我们来尝试用多种方法解决这个问题。</p><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>这道题的常规做法就是迭代解法，通过操作几个指针，将链表中的每个节点的指针方向反转，没什么难点，主要是指针操作的细节问题。</p><p>这里直接给出代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 反转以 head 为起点的单链表</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment"># 由于单链表的结构，至少要用三个指针才能完成迭代反转</span>        <span class="token comment"># cur 是当前遍历的节点，pre 是 cur 的前驱结点，nxt 是 cur 的后继结点</span>        pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> nxt <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token keyword">while</span> cur <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 逐个结点反转</span>            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre            <span class="token comment"># 更新指针位置</span>            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> nxt            <span class="token keyword">if</span> nxt <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                nxt <span class="token operator">=</span> nxt<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 返回反转后的头结点</span>        <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个解法的思路是：</p><ul><li>首先判断链表是否为空或只有一个结点，如果是，则直接返回原链表。</li><li>然后初始化三个指针：<code>pre</code> 是前驱指针，<code>cur</code> 是当前指针，<code>nxt</code> 是后继指针。</li><li>然后开始迭代，每次迭代都将当前结点的 <code>next</code> 指针指向 <code>pre</code>，然后更新 <code>pre</code>、<code>cur</code>、<code>nxt</code> 指针的位置。</li><li>最后返回 <code>pre</code> 指针，即为反转后的头结点。</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>上面的迭代解法操作指针虽然有些繁琐，但是思路还是比较清晰的。如果现在让你用递归来反转单链表，你有啥想法没？</p><p><strong>递归反转单链表的关键在于，这个问题本身是存在子问题结构的。</strong></p><p>比方说，现在给你输入一个以 1 为头结点单链表 1-&gt;2-&gt;3-&gt;4，那么如果我忽略这个头结点 1，只拿出 2-&gt;3-&gt;4 这个子链表，它也是个单链表对吧？</p><p>那么你这个 <code>reverseList</code> 函数，只要输入一个单链表，就能给我反转对吧？那么你能不能用这个函数先来反转 <code>2-&gt;3-&gt;4 </code>这个子链表呢，然后再想办法把 <code>1</code> 接到反转后的 <code>4-&gt;3-&gt;2 </code>的最后面，是不是就完成了整个链表的反转？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-></span><span class="token number">2</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这就是「分解问题」的思路，通过递归函数的定义，把原问题分解成若干规模更小、结构相同的子问题，最后通过子问题的答案组装原问题的解。</strong></p><p>因此，我们可以用递归函数来反转单链表，如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        last <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">)</span>         head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head         head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">return</span> last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于「分解问题」思路的递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 <code>reverseList</code> 函数定义是这样的：</p><p><strong>输入一个节点 <code>head</code>，将「以 <code>head</code> 为起点」的链表反转，并返回反转之后的头结点</strong>。</p><p>明白了函数的定义，再来看这个问题。比如说我们想反转这个链表：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/1.jpg" alt="img"></p><p>那么输入 <code>reverseList(head)</code> 后，会在这里进行递归：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode last <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/2.jpg" alt="img"></p><p>这个 <code>reverseList(head.next)</code> 执行完成后，整个链表就成了这样：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/3.jpg" alt="img"></p><p>现在再来看下面的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/4.jpg" alt="img"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">return</span> last<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/5.jpg" alt="img"></p><p>神不神奇，这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：</p><p>1、递归函数要有 base case，也就是这句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>意思是如果链表为空或者只有一个节点的时候，反转结果就是它自己，直接返回即可。</p><p>2、当链表递归反转之后，新的头结点是 <code>last</code>，而之前的 <code>head</code> 变成了最后一个节点，别忘了链表的末尾要指向 null：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，整个单链表就完成反转了。</p><blockquote><p>递归操作链表的效率不如迭代</p><p>值得一提的是，递归操作链表并不高效。</p><p>递归解法和迭代解法相比，时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。</p><p>所以递归操作链表可以用来练习递归思维，但是考虑效率的话还是使用迭代算法更好。</p></blockquote><h2 id="反转链表前-N-个节点"><a href="#反转链表前-N-个节点" class="headerlink" title="反转链表前 N 个节点"></a>反转链表前 N 个节点</h2><p>这次我们实现一个这样的函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将链表的前 n 个节点反转（n &lt;= 链表长度）</span><span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/6.jpg" alt="img"></p><h3 id="迭代解法-1"><a href="#迭代解法-1" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>迭代解法应该比较好写，在之前实现的 <code>reverseList</code> 基础上稍加修改就可以了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> head    pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> nxt <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre        pre <span class="token operator">=</span> cur        cur <span class="token operator">=</span> nxt        <span class="token keyword">if</span> nxt <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            nxt <span class="token operator">=</span> nxt<span class="token punctuation">.</span><span class="token builtin">next</span>        n <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token comment"># 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点</span>    head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur     <span class="token comment"># 此时的 pre 是反转后的头结点</span>    <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 后驱节点</span>successor <span class="token operator">=</span> <span class="token boolean">None</span><span class="token comment"># 反转以 head 为起点的 n 个节点，返回新的头结点</span><span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> successor    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment"># 记录第 n + 1 个节点</span>        successor <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token keyword">return</span> head    <span class="token comment"># 以 head.next 为起点，需要反转前 n - 1 个节点</span>    last <span class="token operator">=</span> reverseN<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head    <span class="token comment"># 让反转之后的 head 节点和后面的节点连起来</span>    head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> successor    <span class="token keyword">return</span> last <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的区别：</p><p>1、base case 变为 <code>n == 1</code>，反转一个元素，就是它本身，<strong>同时要记录后驱节点</strong>，即要记录第 <code>n + 1</code> 个节点。</p><p>2、刚才我们直接把 <code>head.next</code> 设置为 null，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 <code>n + 1</code> 个节点），反转之后将 <code>head</code> 连接上。</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/7.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 反转链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法核心</title>
      <link href="/2025/05/08/hua-dong-chuang-kou-suan-fa-he-xin/"/>
      <url>/2025/05/08/hua-dong-chuang-kou-suan-fa-he-xin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长&#x2F;最短子数组。</p></blockquote><h2 id="滑动窗口框架概览"><a href="#滑动窗口框架概览" class="headerlink" title="滑动窗口框架概览"></a>滑动窗口框架概览</h2><p>如果用暴力解的话，你需要嵌套 for 循环这样穷举所有子数组，时间复杂度是 $O(n^2)$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// nums[i, j] 是一个子数组</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>滑动窗口算法技巧的思路也不难，就是维护一个窗口，不断滑动，然后更新答案，该算法的大致逻辑如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 增大窗口</span>    window<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>window needs shrink<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 缩小窗口</span>        window<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于滑动窗口算法框架写出的代码，时间复杂度是 $O(N)$，比嵌套 <code>for</code> 循环的暴力解法效率高。</p><h2 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h2><p>先来看看力扣第 76 题<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>难度 Hard：</p><hr><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例 1</strong>：</p><p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</p><p><strong>示例 2：</strong></p><p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>解释：整个字符串 s 是最小覆盖子串。</p><p><strong>示例 3:</strong></p><p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p><hr><p>就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p><h3 id="滑动窗口算法的思路是这样："><a href="#滑动窗口算法的思路是这样：" class="headerlink" title="滑动窗口算法的思路是这样："></a>滑动窗口算法的思路是这样：</h3><p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引左闭右开区间 <code>[left, right)</code> 称为一个「窗口」。</p><p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p><p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p><blockquote><p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，就好像一条毛毛虫，一伸一缩，不断向右滑动，这就是「滑动窗口」这个名字的来历</p></blockquote><h3 id="现在开始套模板，只需要思考以下几个问题："><a href="#现在开始套模板，只需要思考以下几个问题：" class="headerlink" title="现在开始套模板，只需要思考以下几个问题："></a>现在开始套模板，只需要思考以下几个问题：</h3><p>1、什么时候应该移动 right 扩大窗口？窗口加入字符时，应该更新哪些数据？</p><p>2、什么时候窗口应该暂停扩大，开始移动 left 缩小窗口？从窗口移出字符时，应该更新哪些数据？</p><p>3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p><p>如果一个字符进入窗口，应该增加 window 计数器；如果一个字符将移出窗口的时候，应该减少 window 计数器；当 valid 满足 need 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p><p><img src="/2025/05/08/hua-dong-chuang-kou-suan-fa-he-xin/1(1).jpg" alt=" "></p><p>下面是完整代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        need<span class="token punctuation">,</span> window <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> t<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> need<span class="token punctuation">.</span>get<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token number">0</span>        valid <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># valid变量表示窗口中满足 need 条件的字符个数</span>        <span class="token comment"># 记录最小覆盖子串的起始索引及长度</span>        start <span class="token operator">=</span> <span class="token number">0</span>        length <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># c 是将移入窗口的字符</span>            c <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token comment"># 扩大窗口</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 进行窗口内数据的一系列更新</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">.</span>get<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 判断左侧窗口是否要收缩</span>            <span class="token keyword">while</span> valid <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                 <span class="token comment"># 在这里更新最小覆盖子串</span>                <span class="token keyword">if</span> right <span class="token operator">-</span> left <span class="token operator">&lt;</span> length<span class="token punctuation">:</span>                    start <span class="token operator">=</span> left                    length <span class="token operator">=</span> right <span class="token operator">-</span> left                <span class="token comment"># d 是将移出窗口的字符</span>                d <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                <span class="token comment"># 缩小窗口</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment"># 进行窗口内数据的一系列更新</span>                <span class="token keyword">if</span> d <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">==</span> need<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid <span class="token operator">-=</span> <span class="token number">1</span>                    window<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 返回最小覆盖子串</span>        <span class="token keyword">return</span> <span class="token string">""</span> <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span> start <span class="token operator">+</span> length<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2025/05/05/lian-biao-shuang-zhi-zhen/"/>
      <url>/2025/05/05/lian-biao-shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="链表的合并"><a href="#链表的合并" class="headerlink" title="链表的合并"></a>链表的合并</h1><blockquote><p>有些题目虽然不是链表的题目，但其中蕴含了合并有序链表的思想。</p></blockquote><h2 id="264-丑数-II-力扣"><a href="#264-丑数-II-力扣" class="headerlink" title="264. 丑数 II 力扣"></a>264. 丑数 II <a href="https://leetcode.cn/problems/ugly-number-ii/description/">力扣</a></h2><hr><p>给你一个整数 n ，请你找出并返回第 n 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是质因子只包含 2、3 和 5 的正整数。</p><p>示例 1：</p><p>输入：n &#x3D; 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1<br>解释：1 通常被视为丑数。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1690</p><hr><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题很精妙，你看着它好像是道数学题，实际上它却是一个合并多个有序链表的问题，同时用到了筛选素数的思路。</p><p>根据题意，每个丑数都可以由其他较小的丑数通过乘以 2 或 3 或 5 得到。<br>我们把所有丑数想象成一个从小到大排序的链表，就是这个样子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">2</span> <span class="token operator">-></span> <span class="token number">3</span> <span class="token operator">-></span> <span class="token number">4</span> <span class="token operator">-></span> <span class="token number">5</span> <span class="token operator">-></span> <span class="token number">6</span> <span class="token operator">-></span> <span class="token number">8</span> <span class="token operator">-></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数（按照题目的意思，1 算作特殊的丑数，放在开头），这三类丑数就好像三条有序链表，如下：</p><p>能被 2 整除的丑数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">3</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能被 3 整除的丑数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">3</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能被 5 整除的丑数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">3</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们其实就是想把这三条<strong>有序链表</strong>一起并<strong>去重</strong>，合并的结果就是丑数的序列。然后求合并后的这条有序链表中第 n 个元素是什么。所以这里就和合并多个有序链表一样</p><p>具体思路看注释吧</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 可以理解为三个指向有序链表头结点的指针，p2,p3,p5代表的是第几个数的 2 倍、第几个数 3 倍、第几个数 5 倍</span>        p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p5 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token comment"># 可以理解为三个有序链表的头节点的值</span>        product2<span class="token punctuation">,</span> product3<span class="token punctuation">,</span> product5 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token comment"># 可以理解为最终合并的有序链表（结果链表）</span>        ugly <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 可以理解为结果链表上的指针</span>        p <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment"># 开始合并三个有序链表</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            <span class="token comment"># 取三个链表的最小结点</span>            min_val <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>product2<span class="token punctuation">,</span> product3<span class="token punctuation">,</span> product5<span class="token punctuation">)</span>            <span class="token comment"># 接到结果链表上</span>            ugly<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> min_val            p <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 前进对应有序链表上的指针</span>            <span class="token keyword">if</span> min_val <span class="token operator">==</span> product2<span class="token punctuation">:</span>                product2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span>p2<span class="token punctuation">]</span>                p2 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> min_val <span class="token operator">==</span> product3<span class="token punctuation">:</span>                product3 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span>p3<span class="token punctuation">]</span>                p3 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> min_val <span class="token operator">==</span> product5<span class="token punctuation">:</span>                product5 <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span>p5<span class="token punctuation">]</span>                p5 <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment"># 返回第 n 个丑数</span>        <span class="token keyword">return</span> ugly<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="链表运算题"><a href="#链表运算题" class="headerlink" title="链表运算题"></a>链表运算题</h1><blockquote><p>有些题目虽然不是链表的题目，但其中蕴含了合并有序链表的思想。</p></blockquote><h2 id="445-两数相加-II-力扣"><a href="#445-两数相加-II-力扣" class="headerlink" title="445. 两数相加 II 力扣"></a>445. 两数相加 II <a href="https://leetcode.cn/problems/add-two-numbers-ii/description/">力扣</a></h2><hr><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>示例1：</p><p><img src="/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88%5C1626420025-fZfzMX-image.png"></p><p>输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,8,0,7]<br>示例2：</p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[8,0,7]<br>示例3：</p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p><p>提示：</p><p>链表的长度范围为 [1, 100]<br>0 &lt;&#x3D; node.val &lt;&#x3D; 9<br>输入数据保证链表代表的数字无前导 0</p><p>进阶：如果输入链表不能翻转该如何解决？</p><hr><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题是 两数相加 的进阶问题，我们模拟加法运算当然是从最低位开始加，这样才能正确的处理进位。但现在单链表的开头是最高位，那么最直接的想法就是先 <strong>翻转链表</strong>，这样就没什么难度。</p><p>不过本题也说了，如果不让你反转链表怎么办？其实也好办，我们可以利用栈这种先进后出的数据结构，把链表节点从头到尾放进栈中，再从栈拿出来就是从尾到头的顺序，相当于是反转链表的效果，然后再进行加法运算即可。</p><p>还有一个需要注意的是，计算结果的高位也应该放在结果链表的左侧，也就是插入到 dummy 节点的后面。具体看代码吧。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token comment"># 把链表元素转入栈中</span>        stk1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> l1<span class="token punctuation">:</span>            stk1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span><span class="token builtin">next</span>        stk2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> l2<span class="token punctuation">:</span>            stk2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 接下来基本上是复用我在第 2 题的代码逻辑</span>        <span class="token comment"># 注意新节点要直接插入到 dummy 后面</span>        <span class="token comment"># 虚拟头结点（构建新链表时的常用技巧）</span>        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 记录进位</span>        carry <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 开始执行加法，两条链表走完且没有进位时才能结束循环</span>        <span class="token keyword">while</span> stk1 <span class="token keyword">or</span> stk2 <span class="token keyword">or</span> carry <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 先加上上次的进位</span>            val <span class="token operator">=</span> carry            <span class="token keyword">if</span> stk1<span class="token punctuation">:</span>                val <span class="token operator">+=</span> stk1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> stk2<span class="token punctuation">:</span>                val <span class="token operator">+=</span> stk2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 处理进位情况</span>            carry <span class="token operator">=</span> val <span class="token operator">//</span> <span class="token number">10</span>            val <span class="token operator">=</span> val <span class="token operator">%</span> <span class="token number">10</span>            <span class="token comment"># 构建新节点，直接接在 dummy 后面</span>            newNode <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            newNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span>            dummy<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> newNode        <span class="token comment"># 返回结果链表的头结点（去除虚拟头结点）</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效寻找素数</title>
      <link href="/2025/05/05/ru-he-gao-xiao-xun-zhao-su-shu/"/>
      <url>/2025/05/05/ru-he-gao-xiao-xun-zhao-su-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>素数的定义看起来很简单，如果一个数如果只能被 <code>1</code> 和它本身整除，那么这个数就是素数</p></blockquote><ul><li>比如力扣第 204 题<a href="https://leetcode.cn/problems/count-primes/">计数质数</a></li></ul><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><p>我们可以从 2 开始，判断每个数是否是素数，如果是素数，我们就把count加1，如果不是素数，我们就跳过它。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isPrime<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> count<span class="token comment"># 判断整数 n 是否是素数</span><span class="token keyword">def</span> <span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 有其他整除因子</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这样写的话时间复杂度 $O(n^2)$，<strong>问题很大</strong>。首先你用 <code>isPrime</code> 函数来辅助的思路就不够高效；而且就算你要用 <code>isPrime</code> 函数，这样写算法也是<strong>存在计算冗余</strong>的。</p></blockquote><p><strong>优化思路</strong></p><p>先来说下如果你要判断一个数是不是素数，应该如何写算法。只需稍微修改一下上面的 isPrime 代码中的 for 循环条件：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">boolean isPrime<span class="token punctuation">(</span><span class="token builtin">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token builtin">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>换句话说，i 不需要遍历到 n，而只需要到 sqrt(n) 即可。为什么呢，我们举个例子，假设 n &#x3D; 12。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">2</span> × <span class="token number">6</span><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">3</span> × <span class="token number">4</span><span class="token number">12</span> <span class="token operator">=</span> sqrt<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> × sqrt<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">4</span> × <span class="token number">3</span><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">6</span> × <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，后两个乘积就是前面两个反过来，反转临界点就在 <code>sqrt(n)</code>。</p><p>换句话说，如果在 <code>[2,sqrt(n)]</code> 这个区间之内没有发现可整除因子，就可以直接断定 n 是素数了，因为在区间 <code>[sqrt(n),n]</code> 也一定不会发现可整除因子。</p><p>现在，<code>isPrime</code> 函数的时间复杂度降为$O(sqrt(N))$，但是我们实现 <code>countPrimes</code> 函数其实并不需要这个函数，以上只是希望读者明白 <code>sqrt(n)</code> 的含义，因为等会还会用到。</p><h2 id="高效实现-countPrimes"><a href="#高效实现-countPrimes" class="headerlink" title="高效实现 countPrimes"></a>高效实现 countPrimes</h2><p>接下来介绍的方法叫做「素数筛选法」，这个方法是古希腊一位名叫埃拉托色尼的大佬发明</p><p>素数筛选法的核心思路是和上面的常规思路反着来：</p><p>首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 &#x3D; 4, 3 × 2 &#x3D; 6, 4 × 2 &#x3D; 8… 都不可能是素数了。</p><p>然后我们发现 3 也是素数，那么 3 × 2 &#x3D; 6, 3 × 3 &#x3D; 9, 3 × 4 &#x3D; 12… 也都不可能是素数了。</p><p>Wikipedia 的这个 GIF 很形象：</p><p><img src="/2025/05/05/ru-he-gao-xiao-xun-zhao-su-shu/1.gif" alt="素数筛选法"></p><p>看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        isPrime <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                 count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。</p><p>首先，回想本文开头介绍的 <code>isPrime</code> 素数判定函数，由于因子的对称性，其中的 <code>for</code> 循环只需要遍历 <code>[2,sqrt(n)]</code> 就够了。这里也是类似的，我们外层的 <code>for</code> 循环也只需要遍历到 <code>sqrt(n)</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span>     isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样可以把 i 的整数倍都标记为 false，但是仍然存在计算冗余。</p><p>比如 n &#x3D; 25，i &#x3D; 5 时算法会标记 5 × 2 &#x3D; 10，5 × 3 &#x3D; 15 等等数字，但是这两个数字已经被 i &#x3D; 2 和 i &#x3D; 3 的 2 × 5 和 3 × 5 标记了。</p><p>我们可以稍微优化一下，让 j 从 i * i 开始遍历，而不是从 2 * i 开始：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span>     isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：</p><pre><code class="language-python">class Solution:    def countPrimes(self, n: int) -&gt; int:        isPrime = [True] * n        for i in range(2, int(n ** 0.5) + 1):            if isPrime[i]:                for j in range(i * i, n, i):                    isPrime[j] = False        count = 0        for i in range(2, n):            if isPrime[i]:                 count += 1        return count</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="/2025/05/02/tong-pai-xu/"/>
      <url>/2025/05/02/tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>桶排序算法的核心思想分三步：</p><p>1、将待排序数组中的元素使用映射函数分配到若干个「桶」中。</p><p>2、对每个桶中的元素进行排序。</p><p>3、最后将这些排好序的桶进行合并，得到排序结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/2025/05/02/ji-shu-pai-xu/"/>
      <url>/2025/05/02/ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计数排序的原理比较简单：统计每种元素出现的次数，进而推算出每个元素在排序后数组中的索引位置，最终完成排序。</p></blockquote><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>比方说，输入一个 <code>nums</code> 数组，我统计出其中有 <code>2</code> 个元素 <code>1</code>，<code>1</code> 个元素 <code>3</code>，<code>3</code> 个元素 <code>6</code>，那么只要我在数组中依次填入 <code>2</code> 个 <code>1</code>，<code>1</code> 个 <code>3</code>，<code>3</code> 个 <code>6</code>，就能得到排序结果 <code>[1, 1, 3, 6, 6, 6]</code>。</p><p>看个题目就明白了 <a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></p><hr><blockquote><ol start="75"><li>颜色分类 | 力扣 | LeetCode |  🟠<br>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li></ol><p>我们使用整数 0、 1 和 2 分别表示<font color="red">红色</font>、白色和<font color="blue">蓝色</font>。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><p>输入：nums &#x3D; [2,0,2,1,1,0]</p><p>输出：[0,0,1,1,2,2]</p><p><strong>示例 2：</strong></p><p>输入：nums &#x3D; [2,0,1]</p><p>输出：[0,1,2]</p><p><strong>提示：</strong></p><p>n &#x3D;&#x3D; nums.length</p><p>1 &lt;&#x3D; n &lt;&#x3D; 300</p><p>nums[i] 为 0、1 或 2</p><p><strong>进阶：</strong></p><p>你能想出一个仅使用常数空间的一趟扫描算法吗？</p></blockquote><hr><p>我们用计数排序的思路来解决这个问题，说白了就是让你对数组排序，且这个数组里只有 0、1、2 三种元素。</p><p>我们可以创建一个大小为 <code>3</code> 的 <code>count</code> 数组，<code>count[0]</code>, <code>count[1]</code>, <code>count[2]</code> 分别表示数组中 <code>0</code>、<code>1</code>、<code>2</code> 出现的次数。然后我们按照 <code>count</code> 数组的统计结果，依次填充原数组即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 统计 0, 1, 2 出现的次数</span>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>        <span class="token keyword">for</span> element <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>element<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 按照 count 数组的统计结果，依次填充原数组</span>        index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>count<span class="token punctuation">[</span>element<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element                index <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，我们就完成了颜色分类问题的排序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2025/05/02/dui-pai-xu/"/>
      <url>/2025/05/02/dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>堆排序是从 <em><strong>二叉堆结构</strong></em> 衍生出来的排序算法，复杂度为 $O(NlogN)$。堆排序主要分两步，第一步是在待排序数组上原地创建二叉堆（Heapify），然后进行原地排序（Sort）。</p></blockquote><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><blockquote><p>堆排序的两个关键步骤：</p><p>1、原地建堆（Heapify）：直接把待排序数组原地变成一个二叉堆。</p><p>2、排序（Sort）：将元素不断地从堆中取出，最终得到有序的结果。</p></blockquote><p>下面这些函数就是从 <strong>二叉堆实现优先级队列</strong> 中的优先级队列实现里抠出来的，把数组作为函数参数传入，其他的逻辑完全一样：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">min_heap_swim</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 小顶堆的上浮操作，时间复杂度是树高 O(logN)</span>    <span class="token keyword">while</span> node <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> heap<span class="token punctuation">[</span>parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>        node <span class="token operator">=</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">min_heap_sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 小顶堆的下沉操作，时间复杂度是树高 O(logN)</span>    <span class="token keyword">while</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">or</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>        <span class="token comment"># 比较自己和左右子节点，看看谁最小</span>        min_index <span class="token operator">=</span> node        <span class="token keyword">if</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>left<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            min_index <span class="token operator">=</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>right<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            min_index <span class="token operator">=</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> min_index <span class="token operator">==</span> node<span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token comment"># 如果左右子节点中有比自己小的，就交换</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> min_index<span class="token punctuation">)</span>        node <span class="token operator">=</span> min_index<span class="token keyword">def</span> <span class="token function">max_heap_swim</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 大顶堆的上浮操作</span>    <span class="token keyword">while</span> node <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> heap<span class="token punctuation">[</span>parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>        node <span class="token operator">=</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">max_heap_sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 大顶堆的下沉操作</span>    <span class="token keyword">while</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">or</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>        <span class="token comment"># 小顶堆和大顶堆的唯一区别就在这里，比较逻辑相反</span>        <span class="token comment"># 比较自己和左右子节点，看看谁最大</span>        max_index <span class="token operator">=</span> node        <span class="token keyword">if</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>left<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            max_index <span class="token operator">=</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>right<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            max_index <span class="token operator">=</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> max_index <span class="token operator">==</span> node<span class="token punctuation">:</span>            <span class="token keyword">break</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> max_index<span class="token punctuation">)</span>        node <span class="token operator">=</span> max_index<span class="token keyword">def</span> <span class="token function">parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 父节点的索引</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>node <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">left</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 左子节点的索引</span>    <span class="token keyword">return</span> node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">def</span> <span class="token function">right</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 右子节点的索引</span>    <span class="token keyword">return</span> node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 交换数组中两个元素的位置</span>    heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单直接的堆排序实现"><a href="#简单直接的堆排序实现" class="headerlink" title="简单直接的堆排序实现"></a>简单直接的堆排序实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 第一步，原地建堆，注意这里创建的是大顶堆</span>    <span class="token comment"># 只要从左往右对每个元素调用 swim 方法，就可以原地建堆</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        max_heap_swim<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token comment"># 第二步，排序</span>    <span class="token comment"># 现在整个数组已经是一个大顶了，直接模拟删除堆顶元素的过程即可</span>    heap_size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">while</span> heap_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token comment"># 从堆顶删除元素，放到堆的后面</span>        swap<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heap_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        heap_size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 恢复堆的性质</span>        max_heap_sink<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heap_size<span class="token punctuation">)</span>        <span class="token comment"># 现在 nums[0..heap_size) 是一个大顶堆，nums[heap_size..) 是有序元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面一个关键点是要用大顶堆来完成 <code>nums</code> 从小到大的排序，因为从堆顶删除的元素是从后往前填到 <code>nums</code> 数组中的，最终 <code>nums</code> 中的元素是从小到大排序的。</p><p>如果你用小顶堆的话，最终 <code>nums</code> 中的元素是从大到小排序的，还需要再翻转一下数组，没有大顶堆的效率高。</p><h2 id="堆排序的复杂度分析"><a href="#堆排序的复杂度分析" class="headerlink" title="堆排序的复杂度分析"></a>堆排序的复杂度分析</h2><p>我们来分析一下上述代码的时间复杂度，假设 <code>nums</code> 的元素个数为 <code>N</code>：</p><ul><li>第一步建堆的过程中，<code>swim</code> 方法的时间复杂度是<br>$O(logN)$，算法对每个元素调用一次 <code>swim</code> 方法，所以总时间复杂度是 $O(NlogN)$。</li><li>第二步排序的过程中，每次 <code>sink</code> 方法的时间复杂度是 $O(logN)$，算法对每个元素调用一次 <code>sink</code> 方法，所以总时间复杂度是 $O(NlogN)$。</li></ul><p><strong>综上，整个堆排序的时间复杂度是 $2NlogN$，用 Big O 表示就是 $O(NlogN)$</strong>。与 快速排序、归并排序 是一个级别的排序算法。</p><h2 id="堆排序的稳定性"><a href="#堆排序的稳定性" class="headerlink" title="堆排序的稳定性"></a>堆排序的稳定性</h2><p>堆排序是一种不稳定的排序算法，原因在于它在排序过程中交换元素时，可能会改变相同元素的相对顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2025/05/02/gui-bing-pai-xu/"/>
      <url>/2025/05/02/gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>归并排序的核心思路需要结合<em><strong>二叉树的后序遍历</strong></em> 来理解：先利用递归把左右两半子数组排好序，然后在二叉树的后序位置合并两个有序数组。</p></blockquote><h2 id="归并排序核心思路"><a href="#归并排序核心思路" class="headerlink" title="归并排序核心思路"></a>归并排序核心思路</h2><p>前文快速排序的思路是，先把一个元素放到正确的位置（排好序），然后将这个元素左右两边剩下的元素利用递归分别排好序，最终整个数组就排好序了。代码框架如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># ****** 前序位置 ******</span>    <span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span>    <span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>    p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>    <span class="token comment"># 去左右子数组进行切分</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序的思路是，把数组切成两半，先把这两半子数组分别排好序，然后再合并这两个有序数组，整个数组就排好序了。代码框架如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：排序 nums[lo..hi]</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>        <span class="token keyword">return</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo <span class="token operator">+</span> hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token comment"># 利用定义，排序 nums[lo..mid]</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>    <span class="token comment"># 利用定义，排序 nums[mid+1..hi]</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>    <span class="token comment"># ****** 后序位置 ******</span>    <span class="token comment"># 此时两部分子数组已经被排好序</span>    <span class="token comment"># 合并两个有序数组，使 nums[lo..hi] 有序</span>    merge<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>归并排序的时间复杂度是 $O(nlogn)$，其中 $n$ 是数组的长度。</p><p><img src="/2025/05/02/gui-bing-pai-xu/1.jpeg"></p><p>每向下一层，每个节点的数组元素就减半，但是每一层总的元素数量就是数组的长度 $O(n)$。</p><p>这棵二叉树是平衡二叉树，即树高是$O(logn)$，所以总的时间复杂度是 $O(nlogn)$，即树高乘以每层的复杂度。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>归并排序的空间复杂度是 $O(n)$，其中 $n$ 是数组的长度。</p><h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>归并排序是一种稳定的排序算法，归并排序的稳定性取决于 merge 函数的实现</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2025/05/02/kuai-su-pai-xu/"/>
      <url>/2025/05/02/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>快速排序的核心思路需要结合<em><strong>二叉树的前序遍历</strong></em> 来理解：在二叉树遍历的前序位置将一个元素排好位置，然后递归地将剩下的元素排好位置。</p></blockquote><h2 id="快速排序核心思路"><a href="#快速排序核心思路" class="headerlink" title="快速排序核心思路"></a>快速排序核心思路</h2><p>快速排序的基本思路是这样的：</p><p>1、在 <code>nums</code> 数组中任意选择一个元素作为切分元素 <code>pivot</code>（一般选择第一个元素）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">^</span>pivot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、对数组中的元素进行若干交换操作，将小于 <code>pivot</code> 的元素放到 <code>pivot</code> 的左边，大于 <code>pivot</code> 的元素放到 <code>pivot</code> 的右边（换句话说，其实就是将 <code>pivot</code> 这一个元素排好序）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>          <span class="token operator">^</span>        pivot    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、递归地对 <code>pivot</code> 左边和右边的子数组进行快速排序。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">^</span>         <span class="token operator">^</span>   <span class="token operator">^</span>pivot1          pivot2 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>        <span class="token operator">^</span>   <span class="token operator">^</span>            <span class="token operator">^</span>    pivot1             pivot2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、递归地重复上述操作，直到所有元素都放到正确的位置：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h2><ul><li>代码框架  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>    <span class="token keyword">return</span><span class="token comment"># ****** 前序位置 ******</span><span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span><span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token comment"># 去左右子数组进行切分</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>具体代码  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># ****** 前序位置 ******</span>    <span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span>    <span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>    p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>    <span class="token comment"># 去左右子数组进行切分</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>    pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>    left <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token number">1</span>    right <span class="token operator">=</span> hi    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right <span class="token keyword">and</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right <span class="token keyword">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> left <span class="token operator">></span> right<span class="token punctuation">:</span>            <span class="token keyword">break</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>    <span class="token keyword">return</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>快速排序的平均时间复杂度为$O(n\log n)$，最坏情况时间复杂度为$O(n^2)$。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>快速排序不需要额外的辅助空间，是原地排序算法。</p><p>递归遍历二叉树时，递归函数的堆栈深度为树的高度，所以空间复杂度是$O(n\log n)$</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>快速排序是不稳定排序算法，因为在 <code>partition</code> 函数中，不会考虑相同元素的相对位置，所以相同元素的相对位置可能会发生变化。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2025/04/28/xi-er-pai-xu/"/>
      <url>/2025/04/28/xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>希尔排序是基于插入排序 的简单改进，通过预处理增加数组的局部有序性，突破了插入排序的$O(n^2)$时间复杂度。</p></blockquote><h2 id="h有序数组"><a href="#h有序数组" class="headerlink" title="h有序数组"></a><code>h</code>有序数组</h2><p>一个数组是<code>h</code>有序的，是指这个数组中任意间隔为 <code>h</code>（或者说间隔元素的个数为 <code>h-1</code>）的元素都是有序的。</p><p>这个概念用文字不好描述清楚，直接看个例子吧。比方说 <code>h=3 </code>时，一个 <code>3</code> 有序数组是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">nums<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span>    <span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span>       <span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">9</span>    <span class="token number">2</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">12</span>        <span class="token number">4</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">7</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，数组中任意间隔为 <code>3</code>的元素都是有序的。</p><p>另外，按照这个定义，当一个数组完成排序的时候，其实就是 <code>1</code> 有序数组。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序要发表看法了：</p><p>你插入排序的问题是，上来就想着一步到位，直接把乱序数组变成 <code>1</code> 有序数组。而我希尔排序不着急，比方说，我先把乱序数组变成一个 <code>16</code> 有序数组，然后再变成 <code>8</code> 有序数组，<code>4 </code>有序数组，<code>2</code> 有序数组，最后变成 <code>1</code> 有序数组，完成排序。</p><p>这个<code>1, 2, 4, 8, 16...</code>的序列称之为「<strong>递增函数</strong>」，我上面举的例子的递增函数就是 $2^(k-1)$</p><p>那么如何把一个数组变成 h 有序数组呢？基于插入排序的代码改动几个地方就行了，直接看希尔排序的代码吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 希尔排序，对 h 有序数组进行插入排序</span><span class="token comment"># 逐渐缩小 h，最后 h=1 时，完成整个数组的排序</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># 我们使用的生成函数是 2^(k-1)</span>    <span class="token comment"># 即 h = 1, 2, 4, 8, 16...</span>    h <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> h <span class="token operator">&lt;</span> n <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">:</span>        h <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> h    <span class="token comment"># 改动一，把插入排序的主要逻辑套在 h 的 while 循环中</span>    <span class="token keyword">while</span> h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment"># 改动二，sorted_index 初始化为 h，而不是 1</span>        sorted_index <span class="token operator">=</span> h        <span class="token keyword">while</span> sorted_index <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            <span class="token comment"># 改动三，把比较和交换元素的步长设置为 h，而不是相邻元素</span>            i <span class="token operator">=</span> sorted_index            <span class="token keyword">while</span> i <span class="token operator">>=</span> h<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token comment"># swap(nums[i], nums[i - h])</span>                    tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span> <span class="token operator">=</span> tmp                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                i <span class="token operator">-=</span> h            sorted_index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 按照递增函数的规则，缩小 h</span>        h <span class="token operator">//=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="递增函数的选择是关键"><a href="#递增函数的选择是关键" class="headerlink" title="递增函数的选择是关键"></a>递增函数的选择是关键</h3></blockquote><p>希尔排序的性能和递增函数的选择有很大关系，上面的代码中我们使用的递增函数是 $h &#x3D; 2^k-1$。因为这是最简单的，但这并不最优的选择。</p><p>比方说《算法4》中给的递增函数是 $h &#x3D; (3^k - 1) &#x2F; 2$，即<code>1，4，13，40，121 ...</code>这个递增函数的选择是比较合理的。代码如下，主要修改 <code>h</code> 的初始化和更新逻辑：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 把生成函数换成 (3^k - 1) / 2</span><span class="token comment"># 即 h = 1, 4, 13, 40, 121, 364...</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    h <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> h <span class="token operator">&lt;</span> n <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">:</span>        h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">while</span> h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>        sorted_index <span class="token operator">=</span> h        <span class="token keyword">while</span> sorted_index <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            i <span class="token operator">=</span> sorted_index            <span class="token keyword">while</span> i <span class="token operator">>=</span> h<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span> <span class="token operator">=</span> tmp                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                i <span class="token operator">-=</span> h            sorted_index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 按照递增函数的规则，缩小 h</span>        h <span class="token operator">//=</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h2><p>希尔排序是不稳定排序。</p><p>这个比较容易理解吧，当 <code>h</code> 大于 <code>1</code> 时进行的排序操作，就可能打乱相同元素的相对位置了。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>希尔排序的空间复杂度是 $O(1)$，是原地排序。</p><p>希尔排序的时间复杂度很难分析，主要取决于递增函数的选择，且涉及较多的数学知识，这里就不展开了，不过一个重要结论是：<strong>希尔排序的时间复杂度是小于 $O(n^2)$ 的</strong>。</p><blockquote><p>绕了一大圈，终于能够成功通过第 912 题「<a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a>」了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2025/04/27/cha-ru-pai-xu/"/>
      <url>/2025/04/27/cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>插入排序是基于选择排序的一种优化，将 <code>nums[sortedIndex]</code> 插入到左侧的有序数组中。对于有序度较高的数组，插入排序的效率比较高。</p></blockquote><ul><li>练习题目: 力扣第 912 题 <a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a>，先不纠结时间复杂度。</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>选择排序的思路是：在 <code>nums[sortedIndex..]</code> 中找到最小值，然后将其插入到 <code>nums[sortedIndex]</code> 的位置。</p><p>那么我们能不能反过来想，在 <code>nums[0..sortedIndex-1]</code> 这个部分有序的数组中，找到 <code>nums[sortedIndex]</code> 应该插入的位置，然后进行插入呢？</p><p>我想利用数组的有序性：既然 <code>nums[0..sortedIndex-1]</code> 这部分是已经排好序的，那么我就可以用二分搜索来寻找 <code>nums[sortedIndex]</code> 应该插入的位置。  </p><p>用二分搜索好像是多此一举的。因为就算我用二分搜索找到了 <code>nums[sortedIndex]</code> 应该插入的位置，我还是需要搬移元素进行插入，那还不如一边遍历一遍交换元素的方法简单高效呢。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>从 <code>nums[1..n]</code> 开始遍历，对于 <code>nums[sortedIndex]</code>，在 <code>nums[0..sortedIndex-1]</code> 中找到 <code>nums[sortedIndex]</code> 应该插入的位置 <code>j</code>，并一步步左移 <code>nums[sortedIndex]</code> 到 <code>nums[j]</code>的位置</li><li>重复步骤 1，直到 <code>nums[sortedIndex]</code> 到达 <code>nums[n]</code>。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对选择排序进一步优化，向左侧有序数组中插入元素</span><span class="token comment"># 这个算法有另一个名字，叫做插入排序</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># 维护 [0, sorted_index) 是有序数组</span>    sorted_index <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sorted_index <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 将 nums[sorted_index] 插入到有序数组 [0, sorted_index) 中</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sorted_index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># swap(nums[i], nums[i - 1])</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        sorted_index <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><font color=Blue >这个算法的名字叫做插入排序，它的执行过程就像是打扑克牌时，将新抓到的牌插入到手中已经排好序的牌中。</font>        </p></blockquote><h2 id="初始有序度越高，效率越高"><a href="#初始有序度越高，效率越高" class="headerlink" title="初始有序度越高，效率越高"></a>初始有序度越高，效率越高</h2><p>插入排序的空间复杂度是$O(1)$，是原地排序算法。时间复杂度是$O(n^2)$ ，具体的操作次数和选择排序类似，是一个等差数列求和，大约是 $ n^2&#x2F;2 $次。</p><p>如果输入数组已经有序，或者仅有个别元素逆序，那么插入排序的内层 for 循环几乎不需要执行元素交换，所以时间复杂度接近$O(n)$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2025/04/27/mou-pao-pai-xu/"/>
      <url>/2025/04/27/mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>冒泡算法是对选择排序的一种优化，通过交换 nums[sortedIndex] 右侧的逆序对完成排序，是一种<strong>稳定</strong>排序算法。</p></blockquote><ul><li>练习题目: 力扣第 912 题 <a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a>，先不纠结时间复杂度。</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>选择排序失去稳定性的原因，即每次都要交换最小元素<code>nums[minIndex]</code>和当前元素<code>nums[sortedIndex]</code>，这样可能会改变相同元素的相对位置。  </p><p>所以优化的方向就在这里，你不要图省事儿直接把 <code>nums[sortedIndex]</code> 交换到 <code>nums[minIndex]</code>，而是模仿<br>在数组中部插入元素的操作，将 <code>nums[sortedIndex..minIndex]</code> 的元素整体向后移动一位，把 <code>nums[sortedIndex + 1]</code> 的位置空出来让 <code>nums[sortedIndex]</code> 这个元素去那里待着。</p><p>这就是冒泡排序实际做的事。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。 </li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 </li><li>针对所有的元素重复以上的步骤，除了最后一个。 </li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对选择排序进行第一波优化，获得了稳定性</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sortedIndex <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 在未排序部分中找到最小值 nums[minIndex]</span>        minIndex <span class="token operator">=</span> sortedIndex        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sortedIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>                minIndex <span class="token operator">=</span> i        <span class="token comment"># 优化：将 nums[minIndex] 插入到 nums[sortedIndex] 的位置</span>        <span class="token comment"># 将 nums[sortedIndex..minIndex] 的元素整体向后移动一位</span>        minVal <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span>        <span class="token comment"># 数组搬移数据的操作</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>minIndex<span class="token punctuation">,</span> sortedIndex<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> minVal        sortedIndex <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码上优化一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sortedIndex <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 通过一次循环,一边找最小值一边换位，可以将一个元素换到正确的位置</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>sortedIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># Output: n-1,n-2,..., 0 </span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                sortedIndex <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>稳定性：稳定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2025/04/27/xuan-ze-pai-xu/"/>
      <url>/2025/04/27/xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>选择排序是最简单朴素的排序算法，但是时间复杂度较高，且不是稳定排序。其他基础排序算法都是基于选择排序的优化。</p></blockquote><ul><li>练习题目: 力扣第 912 题 <a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a>，先不纠结时间复杂度</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>现在就是给你输入一个数组，让你写个排序算法把所有元素从小到大排序，你来说，怎么写？  </p><p>我第一次思考这个问题时，想到的最直接的方法是这样的：</p><p>先遍历一遍数组，找到数组中的最小值，然后把它和数组的第一个元素交换位置；接着再遍历一遍数组，找到第二小的元素，和数组的第二个元素交换位置；以此类推，直到整个数组有序。</p><p>这个算法有一个被大家熟知的名字，叫做「选择排序」，即每次都去遍历选择最小的元素。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。      </li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到<strong>已排序序列</strong>的末尾。      </li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># sortedIndex 是一个分割线</span>    <span class="token comment"># 索引 &lt; sortedIndex 的元素都是已排序的</span>    <span class="token comment"># 索引 >= sortedIndex 的元素都是未排序的</span>    <span class="token comment"># 初始化为 0，表示整个数组都是未排序的</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sortedIndex <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 找到未排序部分 [sortedIndex, n) 中的最小值</span>        minIndex <span class="token operator">=</span> sortedIndex        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sortedIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>                minIndex <span class="token operator">=</span> i        <span class="token comment"># 交换最小值和 sortedIndex 处的元素</span>        nums<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span>        <span class="token comment"># sortedIndex 后移一位</span>        sortedIndex <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>选择排序的最好时间复杂度是 $O(n^2)$，最坏时间复杂度是 $O(n^2)$，平均时间复杂度是 $O(n^2)$。  </p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>选择排序的空间复杂度是$O(1)$，因为只需要一个辅助变量来记录最小（大）元素的索引。  </p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>选择排序不是稳定排序算法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法的关键指标</title>
      <link href="/2025/04/27/pai-xu-suan-fa-de-guan-jian-zhi-biao/"/>
      <url>/2025/04/27/pai-xu-suan-fa-de-guan-jian-zhi-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>首先一个指标肯定是时间复杂度和空间复杂度。</p><p>正如 时空复杂度入门 中所说，对于任意一个算法，其时间复杂度和空间复杂度都是越小越好的。</p><h3 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h3><p>稳定性是排序算法的一个重要性质，我们可以简单总结为：</p><p><strong>对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。</strong></p><p>如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定排序就会有一定的优势。</p><p>比如说现在你有若干订单数据，已经按照交易日期排好序了，现在你想对用户 ID 再进行排序，<br>如果你用稳定排序算法，那么排序完成后，相同用户 ID 的订单依然会按照交易日期有序排列</p><h3 id="是否原地排序"><a href="#是否原地排序" class="headerlink" title="是否原地排序"></a>是否原地排序</h3><p>原地排序就是指排序过程中不需要额外的辅助空间，只需要常数级别的额外空间，直接操作原数组进行排序。</p><p>注意，关键是是否需要额外的空间，而不是是否返回一个新的数组。具体来说就是类似这样的区别：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 非原地排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 排序过程中需要额外的辅助数组，消耗 O(N) 的空间</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 对 nums 进行排序</span>    <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">// 原地排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 直接操作 nums，不需要额外的辅助数组，消耗 O(1) 的空间</span>    <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难想到，对于大数据量的排序，原地排序算法是比较有优势的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo图片加载问题</title>
      <link href="/2025/04/27/hexo-tu-pian-jia-zai-wen-ti/"/>
      <url>/2025/04/27/hexo-tu-pian-jia-zai-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通用解决方案（推荐）"><a href="#一、通用解决方案（推荐）" class="headerlink" title="一、通用解决方案（推荐）"></a>一、通用解决方案（推荐）</h3><h4 id="1-启用资源文件夹并配置插件"><a href="#1-启用资源文件夹并配置插件" class="headerlink" title="1. 启用资源文件夹并配置插件"></a>1. <strong>启用资源文件夹并配置插件</strong></h4><ul><li><p>步骤1：在_config.yml中配置</p>  <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>步骤 2：安装适配新版 Hexo 的插件（二选一）</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方案一：改进版插件（兼容性更强）</span><span class="token function">npm</span> uninstall hexo-asset-image <span class="token parameter variable">--save</span><span class="token function">npm</span> <span class="token function">install</span> hexo-asset-img <span class="token parameter variable">--save</span><span class="token comment"># 方案二：官方推荐语法（无需插件）</span><span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-marked <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在_config.yml中补充配置：</p>  <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">marked</span><span class="token punctuation">:</span>  <span class="token key atrule">prependRoot</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">postAsset</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-Typora-与-Markdown-协作优化"><a href="#2-Typora-与-Markdown-协作优化" class="headerlink" title="2. Typora 与 Markdown 协作优化"></a>2. <strong>Typora 与 Markdown 协作优化</strong></h4><ul><li><p>Typora设置：<code> 偏好设置 → 图像 → 复制到 ./$&#123;filename&#125;</code>，实现图片自动存入同名文件夹</p></li><li><p>Markdown 语法：</p> <pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token comment">&lt;!-- 插件方案 --></span>&#123;% asset_img image.jpg 图片描述 %&#125;<span class="token comment">&lt;!-- 无插件方案（需 hexo-renderer-marked） --></span><span class="token url"><span class="token operator">!</span>[<span class="token content">图片描述</span>](<span class="token url">image.jpg</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-验证生成路径"><a href="#3-验证生成路径" class="headerlink" title="3. 验证生成路径"></a>3. <strong>验证生成路径</strong></h4><ul><li>执行<pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo g --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>检查 <code>public/年份/月份/日期/文章名/</code> 目录下是否包含图片文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程线程协程</title>
      <link href="/2025/04/17/jin-cheng-xian-cheng/"/>
      <url>/2025/04/17/jin-cheng-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><p>  进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p><p><img src="/2025/04/17/jin-cheng-xian-cheng/6470aeedc4699483fdcae88b3edb7a36.png"></p><p><img src="/2025/04/17/jin-cheng-xian-cheng/29c6aba84af60c91c99d25eb92b26ac7.jpeg"></p><p><strong>【进程间通信（IPC）】：</strong></p><p>管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存（Shared Memory）；套接字（Socket）。</p><h1 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h1><p>  线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</p><h1 id="三、进程和线程的区别与联系"><a href="#三、进程和线程的区别与联系" class="headerlink" title="三、进程和线程的区别与联系"></a>三、进程和线程的区别与联系</h1><h3 id="【区别】："><a href="#【区别】：" class="headerlink" title="【区别】："></a>【区别】：</h3><p><strong>调度</strong>：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p><strong>并发性</strong>：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><p><strong>拥有资源</strong>：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p><p><strong>系统开销</strong>：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><h3 id="【联系】："><a href="#【联系】：" class="headerlink" title="【联系】："></a>【联系】：</h3><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><h1 id="四、一个形象的例子解释进程和线程的区别"><a href="#四、一个形象的例子解释进程和线程的区别" class="headerlink" title="四、一个形象的例子解释进程和线程的区别"></a>四、一个形象的例子解释进程和线程的区别</h1><p>进程就好比一个车间，线程就是车间的工人</p><h1 id="五、协程"><a href="#五、协程" class="headerlink" title="五、协程"></a>五、协程</h1><p>  协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><img src="/2025/04/17/jin-cheng-xian-cheng/b7a5938afc75f67d3f1554fd98875f75-1744896323880-35.png"></p><p>  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>  协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p><strong>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</strong></p><p><strong>极高的执行效率</strong>：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p><strong>不需要多线程的锁机制</strong>：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github配置SSH-Key保姆教程</title>
      <link href="/2025/04/15/github-pei-zhi-ssh-key/"/>
      <url>/2025/04/15/github-pei-zhi-ssh-key/</url>
      
        <content type="html"><![CDATA[<h1 id="github配置SSH-Key保姆级教程"><a href="#github配置SSH-Key保姆级教程" class="headerlink" title="github配置SSH-Key保姆级教程"></a>github配置SSH-Key保姆级教程</h1><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><h3 id="第1步：查看-或者-生成一个SSH-Key"><a href="#第1步：查看-或者-生成一个SSH-Key" class="headerlink" title="第1步：查看 或者 生成一个SSH-Key"></a>第1步：查看 或者 生成一个<a href="https://zhida.zhihu.com/search?content_id=241042157&content_type=Article&match_order=1&q=SSH-Key&zhida_source=entity">SSH-Key</a></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 新环境大概率会报错 ，因为这个目录不存在</span>$ cd <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果报错如下</p><p><img src="https://picx.zhimg.com/v2-8cd1f45e079593a46cbb4bc449c86609_1440w.jpg" alt="img"></p><p>使用下面命令生成ssh-key</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"xxx@xxx.com"</span>  <span class="token comment">// 将 "xxx@xxx.com" 替换为你自己GitHub的邮箱地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后一直按 “enter”键，如下图</p><p><img src="https://pic3.zhimg.com/v2-0be2a290a6a935679ac33b3eb9518686_1440w.jpg" alt="img"></p><h3 id="第2步：获取ssh-key公钥内容"><a href="#第2步：获取ssh-key公钥内容" class="headerlink" title="第2步：获取ssh key公钥内容"></a>第2步：获取ssh key公钥内容</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 进入ssh目录</span>$ cd <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token comment">//其中：</span><span class="token comment">//id_rsa：是私钥</span><span class="token comment">//id_rsa.pub：是公钥</span><span class="token comment">// 查看ssh 公钥  进行复制</span>$ cat id_rsa<span class="token punctuation">.</span>pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic3.zhimg.com/v2-3dec0306103257b6adfdb581aa640f28_1440w.jpg" alt="img"></p><h3 id="第3步：GitHub设置中添加公钥"><a href="#第3步：GitHub设置中添加公钥" class="headerlink" title="第3步：GitHub设置中添加公钥"></a>第3步：GitHub设置中添加公钥</h3><p>点击GitHub中设置标签，然后点击 <strong>SSH and GPG keys</strong> 、 <strong>New SSH key</strong> 将复制好的链接粘贴进去</p><p><img src="https://pic4.zhimg.com/v2-61ad52bd47aedb08f6d39fa4750ad847_1440w.jpg" alt="img"></p><p><img src="https://picx.zhimg.com/v2-7ff3ec3c4945801c9174f40dda7a7ba3_1440w.jpg" alt="img"></p><h3 id="第4步：检查是否设置成功"><a href="#第4步：检查是否设置成功" class="headerlink" title="第4步：检查是否设置成功"></a>第4步：检查是否设置成功</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ ssh <span class="token operator">-</span>T git@github<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到<strong>successfully</strong>字样就成功了</p><h3 id="第5步：GitHub中创建仓库，并使用ssh链接进行下拉"><a href="#第5步：GitHub中创建仓库，并使用ssh链接进行下拉" class="headerlink" title="第5步：GitHub中创建仓库，并使用ssh链接进行下拉"></a>第5步：GitHub中创建仓库，并使用ssh链接进行下拉</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git clone <span class="token operator">+</span> <span class="token string">"ssh链接"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第6步：编码，代码上传"><a href="#第6步：编码，代码上传" class="headerlink" title="第6步：编码，代码上传"></a>第6步：编码，代码上传</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">解释<span class="token comment">// 查看更改项</span>$ git status<span class="token comment">// 添加所有更改项</span>$ git add <span class="token punctuation">.</span><span class="token comment">// 提交commit , 这一步可能会有问题</span>$ git commit <span class="token operator">-</span>m <span class="token string">"feat:add code"</span><span class="token comment">// 推送至远端</span>$git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在commit的时候可能会碰到问题 “<strong>please tell me who you are</strong>”,按照提示进行设置就行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"you@example.com"</span>   <span class="token comment">// "you@example.com"替换为你的GitHub邮箱地址</span>$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Your Name"</span>   <span class="token comment">// "Your Name"替换为你的GitHub名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/15/hello-world/"/>
      <url>/2025/04/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

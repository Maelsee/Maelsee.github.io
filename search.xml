<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树算法习题</title>
      <link href="/2025/08/03/er-cha-shu-suan-fa-xi-ti/"/>
      <url>/2025/08/03/er-cha-shu-suan-fa-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】用「遍历」思维解题-I"><a href="#【练习】用「遍历」思维解题-I" class="headerlink" title="【练习】用「遍历」思维解题 I"></a>【练习】用「遍历」思维解题 I</h1><p>一般来说，如果让你在二叉树的「树枝」上做文章，那么用遍历的思维模式解题是比较自然的想法。</p><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_binary-tree-paths">257. 二叉树的所有路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">257. 二叉树的所有路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>，返回所有从根节点到叶子节点的路径。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶子节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p>&nbsp;<p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/03/12/paths-tree.jpg" style="max-width: 100%; width: 207px; height: 293px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,5]<strong style="font-weight: 600;">输出：</strong>["1-&gt;2-&gt;5","1-&gt;3"]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>["1"]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-paths/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 257. 二叉树的所有路径</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>你让我求所有根节点到叶子节点的路径，那我遍历一遍二叉树肯定可以搞定，遍历到叶子节点的时候想办法把路径生成出来就行了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历一遍二叉树就能出结果了</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 traverse 函数递归时的路径</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 记录所有从根节点到叶子节点的路径</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># root 是叶子节点</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 将这条路径装入 res</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"->"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 递归遍历左右子树</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-paths" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-paths" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-paths/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_sum-root-to-leaf-numbers">129. 求根节点到叶节点数字之和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">129. 求根节点到叶节点数字之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div>给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，树中每个节点都存放有一个<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">9</code><span>&nbsp;</span>之间的数字。<div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;">每条从根节点到叶节点的路径都代表一个数字：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，从根节点到叶节点的路径<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 -&gt; 2 -&gt; 3</code><span>&nbsp;</span>表示数字<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">123</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">计算从根节点到叶节点生成的<span>&nbsp;</span><strong style="font-weight: 600;">所有数字之和</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/num1tree.jpg" style="max-width: 100%; width: 212px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3]<strong style="font-weight: 600;">输出：</strong>25<strong style="font-weight: 600;">解释：</strong>从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1-&gt;2</code> 代表数字 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">12</code>从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1-&gt;3</code> 代表数字 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">13</code>因此，数字总和 = 12 + 13 = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">25</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/num2tree.jpg" style="max-width: 100%; width: 292px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,9,0,5,1]<strong style="font-weight: 600;">输出：</strong>1026<strong style="font-weight: 600;">解释：</strong>从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;9-&gt;5</code> 代表数字 495从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;9-&gt;1</code> 代表数字 491从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;0</code> 代表数字 40因此，数字总和 = 495 + 491 + 40 = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1026</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 129. 求根节点到叶节点数字之和</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>你想，让我获取所有路径数字之和，那我递归遍历一遍二叉树，沿路记录下来路径上的数字，到叶子节点的时候求和，不就完事了？</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token string">""</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历一遍二叉树就能出结果</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置，记录节点值</span>        self<span class="token punctuation">.</span>path <span class="token operator">+=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 到达叶子节点，累加路径和</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">)</span>        <span class="token comment"># 二叉树递归框架，遍历左右子树</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后续遍历位置，撤销节点值</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/3Etpl5">剑指 Offer II 049. 从根节点到叶节点的路径数字之和 🟠</a></li></ul><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_binary-tree-right-side-view">199. 二叉树的右视图</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">199. 二叉树的右视图</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-right-side-view/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">根节点</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/02/14/tree.jpg" style="max-width: 100%; width: 270px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> [1,2,3,null,5,null,4]<strong style="font-weight: 600;">输出:</strong> [1,3,4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> [1,null,3]<strong style="font-weight: 600;">输出:</strong> [1,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> []<strong style="font-weight: 600;">输出:</strong> []</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,100]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 199. 二叉树的右视图</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这题有两个思路：</p><p>1、用 BFS 层序遍历算法，每一层的最后一个节点就是二叉树的右侧视图。我们可以把 BFS 反过来，从右往左遍历每一行，进一步提升效率。</p><p>2、用 DFS 递归遍历算法，同样需要反过来，先递归 <code>root.right</code> 再递归 <code>root.left</code>，同时用 <code>res</code> 记录每一层的最右侧节点作为右侧视图。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># BFS 层序遍历解法</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token comment"># BFS 层序遍历，计算右侧视图</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 每一层头部就是最右侧的元素</span>            last <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 控制每一层从右向左遍历</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token comment"># 每一层的最后一个节点就是二叉树的右侧视图</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>last<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token comment"># DFS 递归遍历解法</span>    <span class="token keyword">def</span> <span class="token function">rightSideView_DFS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 记录递归的层数</span>        self<span class="token punctuation">.</span>depth <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>depth<span class="token punctuation">:</span>            <span class="token comment"># 这一层还没有记录值</span>            <span class="token comment"># 说明 root 就是右侧视图的第一个节点</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 注意，这里反过来，先遍历右子树再遍历左子树</span>        <span class="token comment"># 这样首先遍历的一定是右侧节点</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">-=</span> <span class="token number">1</span><span class="token comment"># 从左到右正常遍历</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>bfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">bfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        q <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 移除并返回第一个元素</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-right-side-view" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-right-side-view" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-right-side-view/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree">662. 二叉树最大宽度 🟠</a></li><li><a href="https://leetcode.cn/problems/WNC0Lk">剑指 Offer II 046. 二叉树的右侧视图 🟠</a></li></ul><h2 id="988-从叶结点开始的最小字符串"><a href="#988-从叶结点开始的最小字符串" class="headerlink" title="988. 从叶结点开始的最小字符串"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_smallest-string-starting-from-leaf">988. 从叶结点开始的最小字符串</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">988. 从叶结点开始的最小字符串</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一颗根结点为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，树中的每一个结点都有一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 25]</code>&nbsp;范围内的值，分别代表字母&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'a'</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'z'</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回<span>&nbsp;</span><em><strong style="font-weight: 600;">按字典序最小</strong><span>&nbsp;</span>的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束</em>。</p><blockquote style="margin: 1rem 0px; padding-block: 0.25rem; padding-inline: 1rem 0px; border-inline-start: 3px solid rgb(184, 184, 186); color: rgba(60, 60, 67, 0.78); font-size: 1rem; overflow-wrap: break-word; transition: border-color 0.3s, color 0.3s;"><p style="line-height: 1.6; overflow-wrap: break-word; margin: inherit;">注<strong style="font-weight: 600;">：</strong>字符串中任何较短的前缀在<span>&nbsp;</span><strong style="font-weight: 600;">字典序上</strong><span>&nbsp;</span>都是<span>&nbsp;</span><strong style="font-weight: 600;">较小</strong><span>&nbsp;</span>的：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，在字典序上&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"ab"</code><span>&nbsp;</span>比&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"aba"</code>&nbsp;要小。叶结点是指没有子结点的结点。&nbsp;</li></ul></blockquote><p style="line-height: 1.6; overflow-wrap: break-word;">节点的叶节点是没有子节点的节点。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/02/tree1.png" style="max-width: 100%; height: 358px; width: 534px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,1,2,3,4,3,4]<strong style="font-weight: 600;">输出：</strong>"dba"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/01/30/tree2.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [25,1,3,1,3,0,2]<strong style="font-weight: 600;">输出：</strong>"adz"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/02/01/tree3.png" style="max-width: 100%; height: 513px; width: 490px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,2,1,null,1,0,null,0]<strong style="font-weight: 600;">输出：</strong>"abc"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定树的结点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 8500]</code><span>&nbsp;</span>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 25</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 988. 从叶结点开始的最小字符串</a>。</strong></details><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>代码看起来虽然多，但思路非常简单：用 <code>path</code> 维护递归遍历的路径，到达叶子节点的时候判断字典序最小的路径。</p><p>不要忘了在叶子节点的时候也要正确维护 <code>path</code> 变量，而且要把 StringBuilder 中的字符串反转才是题目想要的答案。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">smallestFromLeaf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        <span class="token comment"># 遍历过程中的路径</span>    path <span class="token operator">=</span> <span class="token string">""</span>    res <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 找到叶子结点，比较字典序最小的路径</span>            <span class="token comment"># 结果字符串是从叶子向根，所以需要反转</span>            self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>path            s <span class="token operator">=</span> self<span class="token punctuation">.</span>path            <span class="token keyword">if</span> self<span class="token punctuation">.</span>res <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>res <span class="token operator">></span> s<span class="token punctuation">:</span>                <span class="token comment"># 如果字典序更小，则更新 res</span>                self<span class="token punctuation">.</span>res <span class="token operator">=</span> s            <span class="token comment"># 恢复，正确维护 path 中的元素</span>            self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>path        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_smallest-string-starting-from-leaf" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_smallest-string-starting-from-leaf" src="https://labuladong.online/algo-visualize/leetcode/smallest-string-starting-from-leaf/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1022-从根到叶的二进制数之和"><a href="#1022-从根到叶的二进制数之和" class="headerlink" title="1022. 从根到叶的二进制数之和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_sum-of-root-to-leaf-binary-numbers">1022. 从根到叶的二进制数之和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1022. 从根到叶的二进制数之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出一棵二叉树，其上每个结点的值都是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;或&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，如果路径为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">01101</code>，也就是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">13</code>&nbsp;。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回这些数字之和。题目数据保证答案是一个<span>&nbsp;</span><strong style="font-weight: 600;">32 位<span>&nbsp;</span></strong>整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,1,0,1,0,1]<strong style="font-weight: 600;">输出：</strong>22<strong style="font-weight: 600;">解释：</strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;仅为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1022. 从根到叶的二进制数之和</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>用 <code>path</code> 变量维护每一条从根节点到叶子节点的路径形成的二进制数，到了叶子节点之后将这条路径的二进制数累加到 <code>res</code> 中即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumRootToLeaf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 叶子节点</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> self<span class="token punctuation">.</span>path <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> root<span class="token punctuation">.</span>val            <span class="token keyword">return</span>        <span class="token comment"># 前序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> root<span class="token punctuation">.</span>val        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path <span class="token operator">>></span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_sum-of-root-to-leaf-binary-numbers" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-root-to-leaf-binary-numbers" src="https://labuladong.online/algo-visualize/leetcode/sum-of-root-to-leaf-binary-numbers/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1457-二叉树中的伪回文路径"><a href="#1457-二叉树中的伪回文路径" class="headerlink" title="1457. 二叉树中的伪回文路径"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_pseudo-palindromic-paths-in-a-binary-tree">1457. 二叉树中的伪回文路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1457. 二叉树中的伪回文路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong style="font-weight: 600;">伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回从根到叶子节点的所有路径中&nbsp;<strong style="font-weight: 600;">伪回文&nbsp;</strong>路径的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png" style="max-width: 100%; height: 201px; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,3,1,3,1,null,1]<strong style="font-weight: 600;">输出：</strong>2 <strong style="font-weight: 600;">解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png" style="max-width: 100%; height: 314px; width: 300px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]<strong style="font-weight: 600;">输出：</strong>1 <strong style="font-weight: 600;">解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [9]<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定二叉树的节点数目在范围&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>5</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 9</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1457. 二叉树中的伪回文路径</a>。</strong></details><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>遍历一遍二叉树就能得到每条路径上的数字，但这题的考点在于，如何判断一组数字是否存在一个回文串组合？</p><p>稍加思考不难想到：<strong>如果一组数字中，只有最多一个数字出现的次数为奇数，剩余数字的出现次数均为偶数，那么这组数字可以组成一个回文串</strong>。</p><p>题目说了 <code>1 &lt;= root.val &lt;= 9</code>，所以我们可以用一个大小为 10 的 <code>count</code> 数组做计数器来记录每条路径上的元素出现次数，到达叶子节点之后根据元素出现的次数判断是否可以构成回文串。</p><p>当然，我们也可以用更巧妙的位运算来实现上述逻辑：</p><p>1、首先用到异或运算的特性，1 ^ 1 &#x3D; 0, 0 ^ 0 &#x3D; 0, 1 ^ 0 &#x3D; 1。</p><p>2、其次用到 <code>n &amp; (n - 1)</code> 去除二进制最后一个 1 的技巧，详见 <a href="https://labuladong.online/algo/frequency-interview/bitwise-operation/">东哥教你几招常用的位运算技巧</a>。</p><p>我同时实现了这两种方法，供你参考。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/">【练习】用「遍历」思维解题 I</a></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">pseudoPalindromicPaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 遇到叶子节点，判断路径是否是伪回文串</span>            self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 如果路径上出现奇数次的数字个数大于 1，</span>            <span class="token comment"># 则不可能组成回文串，反之则可以组成回文串</span>            odd <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> n <span class="token keyword">in</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>                <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    odd <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> odd <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token comment"># 用位运算代替数组计数，进一步提升效率</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">pseudoPalindromicPaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 遇到叶子节点，判断路径是否是伪回文串</span>            self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 判断二进制中只有一位 1，原理见 https://labuladong.online/algo/frequency-interview/bitwise-operation/</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">&amp;</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-4"><a href="#可视化-4" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_pseudo-palindromic-paths-in-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 0px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_pseudo-palindromic-paths-in-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/pseudo-palindromic-paths-in-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_sum-of-left-leaves">404. 左叶子之和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">404. 左叶子之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-left-leaves/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-left-leaves/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，返回所有左叶子之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/04/08/leftsum-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [3,9,20,null,null,15,7] <strong style="font-weight: 600;">输出:</strong> 24 <strong style="font-weight: 600;">解释:</strong> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [1]<strong style="font-weight: 600;">输出:</strong> 0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-left-leaves/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 404. 左叶子之和</a>。</strong></details><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>无非就是遍历一遍二叉树，然后找到那些左叶子节点，累加它们的值罢了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录左叶子之和</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 找到左侧的叶子节点，记录累加值</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val        <span class="token comment"># 递归框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-5"><a href="#可视化-5" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_sum-of-left-leaves" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-left-leaves" src="https://labuladong.online/algo-visualize/leetcode/sum-of-left-leaves/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_add-one-row-to-tree">623. 在二叉树中增加一行</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">623. 在二叉树中增加一行</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/add-one-row-to-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/add-one-row-to-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的根&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;和两个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>&nbsp;，在给定的深度&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>&nbsp;处添加一个值为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>的节点行。</p><p style="line-height: 1.6; overflow-wrap: break-word;">注意，根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;位于深度&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">加法规则如下:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>，对于深度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth - 1</code><span>&nbsp;</span>的每个非空树节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>，创建两个值为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>的树节点作为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>的左子树根和右子树根。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>原来的左子树应该是新的左子树根的左子树。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>原来的右子树应该是新的右子树根的右子树。</li><li>如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth == 1<span>&nbsp;</span></code>意味着&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth - 1</code>&nbsp;根本没有深度，那么创建一个树节点，值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val<span>&nbsp;</span></code>作为整个原始树的新根，而原始树就是新根的左子树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/15/addrow-tree.jpg" style="max-width: 100%; height: 231px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2<strong style="font-weight: 600;">输出:</strong> [4,1,1,2,null,null,6,3,1,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/11/add2-tree.jpg" style="max-width: 100%; height: 277px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [4,2,null,3,1], val = 1, depth = 3<strong style="font-weight: 600;">输出:</strong>  [4,2,null,1,1,3,null,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>&nbsp;范围内</li><li>树的深度在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= val &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= depth &lt;= the depth of tree + 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/add-one-row-to-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 623. 在二叉树中增加一行</a>。</strong></details><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>用 <code>traverse</code> 函数遍历到对应行，进行插入即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-7"><a href="#解法代码-7" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>targetVal <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>targetDepth <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">addOneRow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> depth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>targetVal <span class="token operator">=</span> val        self<span class="token punctuation">.</span>targetDepth <span class="token operator">=</span> depth        <span class="token comment"># 插入到第一行的话特殊对待一下</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>targetDepth <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            newRoot <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>targetVal<span class="token punctuation">)</span>            newRoot<span class="token punctuation">.</span>left <span class="token operator">=</span> root            <span class="token keyword">return</span> newRoot        <span class="token comment"># 遍历二叉树，走到对应行进行插入</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> curDepth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历</span>        <span class="token keyword">if</span> curDepth <span class="token operator">==</span> self<span class="token punctuation">.</span>targetDepth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 进行插入</span>            newLeft <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>targetVal<span class="token punctuation">)</span>            newRight <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>targetVal<span class="token punctuation">)</span>            newLeft<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left            newRight<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right            root<span class="token punctuation">.</span>left <span class="token operator">=</span> newLeft            root<span class="token punctuation">.</span>right <span class="token operator">=</span> newRight        <span class="token comment"># Recursively traverse the left and right subtree</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> curDepth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> curDepth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 后序遍历</span>        <span class="token comment"># Note: The original Java code does not have any action in the post-order position,</span>        <span class="token comment"># but we keep the comment for consistency.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-6"><a href="#可视化-6" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_add-one-row-to-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_add-one-row-to-tree" src="https://labuladong.online/algo-visualize/leetcode/add-one-row-to-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="971-翻转二叉树以匹配先序遍历"><a href="#971-翻转二叉树以匹配先序遍历" class="headerlink" title="971. 翻转二叉树以匹配先序遍历"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_flip-binary-tree-to-match-preorder-traversal">971. 翻转二叉树以匹配先序遍历</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">971. 翻转二叉树以匹配先序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，树中有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点，每个节点都有一个不同于其他节点且处于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>之间的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">另给你一个由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个值组成的行程序列<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span>，表示<span>&nbsp;</span><strong style="font-weight: 600;">预期</strong><span>&nbsp;</span>的二叉树<span>&nbsp;</span><a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;"><strong style="font-weight: 600;">先序遍历</strong></a><span>&nbsp;</span>结果。</p><p style="line-height: 1.6; overflow-wrap: break-word;">通过交换节点的左右子树，可以<span>&nbsp;</span><strong style="font-weight: 600;">翻转</strong><span>&nbsp;</span>该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/15/fliptree.jpg" style="max-width: 100%; width: 400px; height: 187px;"><p style="line-height: 1.6; overflow-wrap: break-word;">请翻转<span>&nbsp;</span><strong style="font-weight: 600;">最少<span>&nbsp;</span></strong>的树中节点，使二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">先序遍历</strong><span>&nbsp;</span>与预期的遍历行程<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span><strong style="font-weight: 600;">相匹配</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果可以，则返回<span>&nbsp;</span><strong style="font-weight: 600;">翻转的</strong><span>&nbsp;</span>所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-1]</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-01.png" style="max-width: 100%; width: 150px; height: 205px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2], voyage = [2,1]<strong style="font-weight: 600;">输出：</strong>[-1]<strong style="font-weight: 600;">解释：</strong>翻转节点无法令先序遍历匹配预期行程。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-02.png" style="max-width: 100%; width: 150px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], voyage = [1,3,2]<strong style="font-weight: 600;">输出：</strong>[1]<strong style="font-weight: 600;">解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-02.png" style="max-width: 100%; width: 150px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], voyage = [1,2,3]<strong style="font-weight: 600;">输出：</strong>[]<strong style="font-weight: 600;">解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数目为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == voyage.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val, voyage[i] &lt;= n</code></li><li>树中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span>中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 971. 翻转二叉树以匹配先序遍历</a>。</strong></details><h3 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>用 <code>traverse</code> 函数遍历整棵二叉树，对比前序遍历结果，如果节点的值对不上，就无解；如果子树对不上 <code>voyage</code>，就尝试翻转子树。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-8"><a href="#解法代码-8" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipMatchVoyage</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> voyage<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>can_flip <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 遍历的过程中尝试进行反转</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> node <span class="token keyword">or</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>can_flip<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>val <span class="token operator">!=</span> voyage<span class="token punctuation">[</span>self<span class="token punctuation">.</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># 节点的 val 对不上，必然无解</span>                self<span class="token punctuation">.</span>can_flip <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            self<span class="token punctuation">.</span>i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># Only flip if there's a left child and the next value in voyage doesn't match the left child's value</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> voyage<span class="token punctuation">[</span>self<span class="token punctuation">.</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># 前序遍历结果不对，尝试翻转左右子树</span>                self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left            <span class="token comment"># 记录翻转节点</span>            <span class="token comment"># Note: This comment was not in the original Java code, but added to match the pattern of comments. </span>            <span class="token comment"># If this was not intended, it can be removed.</span>            <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-7"><a href="#可视化-7" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_flip-binary-tree-to-match-preorder-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_flip-binary-tree-to-match-preorder-traversal" src="https://labuladong.online/algo-visualize/leetcode/flip-binary-tree-to-match-preorder-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="987-二叉树的垂序遍历"><a href="#987-二叉树的垂序遍历" class="headerlink" title="987. 二叉树的垂序遍历"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_vertical-order-traversal-of-a-binary-tree">987. 二叉树的垂序遍历</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">987. 二叉树的垂序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请你设计算法计算二叉树的<em><span>&nbsp;</span></em><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">对位于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row, col)</code>&nbsp;的每个结点而言，其左右子结点分别位于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row + 1, col - 1)</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row + 1, col + 1)</code><span>&nbsp;</span>。树的根结点位于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(0, 0)</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree1.jpg" style="max-width: 100%; width: 431px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>[[9],[3,15],[20],[7]]<strong style="font-weight: 600;">解释：</strong>列 -1 ：只有结点 9 在此列中。列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。列  1 ：只有结点 20 在此列中。列  2 ：只有结点 7 在此列中。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree2.jpg" style="max-width: 100%; width: 512px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6,7]<strong style="font-weight: 600;">输出：</strong>[[4],[2],[1,5,6],[3],[7]]<strong style="font-weight: 600;">解释：</strong>列 -2 ：只有结点 4 在此列中。列 -1 ：只有结点 2 在此列中。列  0 ：结点 1 、5 和 6 都在此列中。          1 在上面，所以它出现在前面。          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。列  1 ：只有结点 3 在此列中。列  2 ：只有结点 7 在此列中。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree3.jpg" style="max-width: 100%; width: 512px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,6,5,7]<strong style="font-weight: 600;">输出：</strong>[[4],[2],[1,5,6],[3],[7]]<strong style="font-weight: 600;">解释：</strong>这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中结点数目总数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 987. 二叉树的垂序遍历</a>。</strong></details><h3 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>看这题的难度是困难，但你别被吓住了，我们从简单的开始，如果以整棵树的根节点为坐标 <code>(0, 0)</code>，你如何打印出其他节点的坐标？</p><p>很简单，写出如下代码遍历一遍二叉树即可：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">print</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就简单了，把这些坐标收集起来，依据题目要求进行排序，组装成题目要求的返回数据格式即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-9"><a href="#解法代码-9" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 记录每个节点和对应的坐标 (row, col)</span>    <span class="token keyword">class</span> <span class="token class-name">Triple</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>node <span class="token operator">=</span> node            self<span class="token punctuation">.</span>row <span class="token operator">=</span> row            self<span class="token punctuation">.</span>col <span class="token operator">=</span> col    <span class="token keyword">def</span> <span class="token function">verticalTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历二叉树，并且为所有节点生成对应的坐标</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># 根据题意，根据坐标值对所有节点进行排序：</span>        <span class="token comment"># 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，</span>        <span class="token comment"># 如果 col 和 row 都相同，按照 node.val 从小到大排序。</span>        self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>col<span class="token punctuation">,</span> x<span class="token punctuation">.</span>row<span class="token punctuation">,</span> x<span class="token punctuation">.</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 将排好序的节点组装成题目要求的返回格式</span>        res <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 记录上一列编号，初始化一个特殊值</span>        preCol <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> cur <span class="token keyword">in</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>col <span class="token operator">!=</span> preCol<span class="token punctuation">:</span>                <span class="token comment"># 开始记录新的一列</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                preCol <span class="token operator">=</span> cur<span class="token punctuation">.</span>col            res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span> <span class="token keyword">for</span> col <span class="token keyword">in</span> res<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token comment"># 二叉树遍历函数，记录所有节点对应的坐标</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> row<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> col<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 记录坐标</span>        self<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Triple<span class="token punctuation">(</span>root<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/path-sum-iv">666. 路径总和 IV 🟠</a></li></ul><h2 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_cousins-in-binary-tree">993. 二叉树的堂兄弟节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">993. 二叉树的堂兄弟节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/cousins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/cousins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在二叉树中，根节点位于深度<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>处，每个深度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>的节点的子节点位于深度<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k+1</code><span>&nbsp;</span>处。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果二叉树的两个节点深度相同，但<strong style="font-weight: 600;"><span>&nbsp;</span>父节点不同</strong><span>&nbsp;</span>，则它们是一对<em>堂兄弟节点</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">我们给出了具有唯一值的二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，以及树中两个不同节点的值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">只有与值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code><span>&nbsp;</span>对应的节点是堂兄弟节点时，才返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>。否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" style="max-width: 100%; height: 160px; width: 180px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4], x = 4, y = 3<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" style="max-width: 100%; height: 160px; width: 201px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" style="max-width: 100%; height: 160px; width: 156px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4], x = 2, y = 3<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点数介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>之间。</li><li>每个节点的值都是唯一的、范围为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>的整数。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/cousins-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 993. 二叉树的堂兄弟节点</a>。</strong></details><h3 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>遍历找到 x，y 的深度和父节点，对比即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-10"><a href="#解法代码-10" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>parentX <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>parentY <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>depthX <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>depthY <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">isCousins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x        self<span class="token punctuation">.</span>y <span class="token operator">=</span> y        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>depthX <span class="token operator">==</span> self<span class="token punctuation">.</span>depthY <span class="token keyword">and</span> self<span class="token punctuation">.</span>parentX <span class="token operator">!=</span> self<span class="token punctuation">.</span>parentY<span class="token punctuation">:</span>            <span class="token comment"># 判断 x，y 是否是表兄弟节点</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> depth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> parent<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>x<span class="token punctuation">:</span>            <span class="token comment"># 找到 x，记录它的深度和父节点</span>            self<span class="token punctuation">.</span>parentX <span class="token operator">=</span> parent            self<span class="token punctuation">.</span>depthX <span class="token operator">=</span> depth        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>y<span class="token punctuation">:</span>            <span class="token comment"># 找到 y，记录它的深度和父节点</span>            self<span class="token punctuation">.</span>parentY <span class="token operator">=</span> parent            self<span class="token punctuation">.</span>depthY <span class="token operator">=</span> depth        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-8"><a href="#可视化-8" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_cousins-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_cousins-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/cousins-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1315-祖父节点值为偶数的节点和"><a href="#1315-祖父节点值为偶数的节点和" class="headerlink" title="1315. 祖父节点值为偶数的节点和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_sum-of-nodes-with-even-valued-grandparent">1315. 祖父节点值为偶数的节点和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1315. 祖父节点值为偶数的节点和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">如果不存在祖父节点值为偶数的节点，那么返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png" style="max-width: 100%; height: 214px; width: 350px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<strong style="font-weight: 600;">输出：</strong>18<strong style="font-weight: 600;">解释：</strong>图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10^4</code>&nbsp;之间。</li><li>每个节点的值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1315. 祖父节点值为偶数的节点和</a>。</strong></details><h3 id="基本思路-11"><a href="#基本思路-11" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>很简单，遍历一遍二叉树，对于节点值为偶数的节点，累加它的孙子节点的值即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-11"><a href="#解法代码-11" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">sumEvenGrandparent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>    <span class="token comment"># 二叉树的遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 累加左子树孙子节点的值</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val            <span class="token comment"># 累加右子树孙子节点的值</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val        <span class="token comment"># 二叉树的遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-9"><a href="#可视化-9" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_sum-of-nodes-with-even-valued-grandparent" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-nodes-with-even-valued-grandparent" src="https://labuladong.online/algo-visualize/leetcode/sum-of-nodes-with-even-valued-grandparent/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448. 统计二叉树中好节点的数目"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_count-good-nodes-in-binary-tree">1448. 统计二叉树中好节点的数目</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1448. 统计二叉树中好节点的数目</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵根为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，请你返回二叉树中好节点的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;">「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png" style="max-width: 100%; height: 156px; width: 263px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,1,4,3,null,1,5]<strong style="font-weight: 600;">输出：</strong>4<strong style="font-weight: 600;">解释：</strong>图中蓝色节点为好节点。根节点 (3) 永远是个好节点。节点 4 -&gt; (3,4) 是路径中的最大值。节点 5 -&gt; (3,4,5) 是路径中的最大值。节点 3 -&gt; (3,1,3) 是路径中的最大值。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png" style="max-width: 100%; height: 161px; width: 157px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,3,null,4,2]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>节点 2 -&gt; (3, 3, 2) 不是好节点，因为 "3" 比它大。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>1<strong style="font-weight: 600;">解释：</strong>根节点是好节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树中节点数目范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10^5]</code>&nbsp;。</li><li>每个节点权值的范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-10^4, 10^4]</code>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1448. 统计二叉树中好节点的数目</a>。</strong></details><h3 id="基本思路-12"><a href="#基本思路-12" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维，利用函数参数给子树传递信息。</p><p>函数参数 <code>pathMax</code> 记录从根节点到当前节点路径中的最大值，通过比较 <code>root.val</code> 和 <code>pathMax</code> 比较就可判断 <code>root</code> 节点是不是「好节点」。然后再把 <code>pathMax</code> 传递到子树中继续判断其他节点。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/">【练习】用「遍历」思维解题 II</a></li></ul><h3 id="解法代码-12"><a href="#解法代码-12" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">goodNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count    <span class="token comment"># 二叉树遍历函数，pathMax 参数记录从根节点到当前节点路径中的最大值</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> pathMax<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> pathMax <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token comment"># 找到一个「好节点」</span>            self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 更新路径上的最大值</span>        pathMax <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>pathMax<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pathMax<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> pathMax<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-10"><a href="#可视化-10" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_count-good-nodes-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_count-good-nodes-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/count-good-nodes-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_path-sum-iii">437. 路径总和 III</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">437. 路径总和 III</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/path-sum-iii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/path-sum-iii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">targetSum</code><span>&nbsp;</span>，求该二叉树里节点值之和等于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">targetSum</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">路径</strong><span>&nbsp;</span>的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">路径</strong><span>&nbsp;</span>不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/04/09/pathsum3-1-tree.jpg" style="max-width: 100%; width: 452px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>和等于 8 的路径有 3 条，如图所示。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,1000]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>9</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 10<sup>9</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= targetSum &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/path-sum-iii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 437. 路径总和 III</a>。</strong></details><h3 id="基本思路-13"><a href="#基本思路-13" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维模式。</p><p>这题的难度应该设置为困难，因为这题及要求你准确理解二叉树的前序后序遍历，还要熟悉前缀和技巧，把前缀和技巧用到二叉树上。</p><p>你可以先看前文 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a>，然后做一下 <a href="https://leetcode.cn/problems/subarray-sum-equals-k">560. 和为K的子数组</a>，应该能够理解这道题的思路了。</p><p>你把二叉树看做是数组，利用前后序遍历来维护前缀和，看下图就能理解解法中几个关键变量的关系了：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/437.jpeg" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-13"><a href="#解法代码-13" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 记录前缀和</span>    <span class="token comment"># 定义：从二叉树的根节点开始，路径和为 pathSum 的路径有 preSumCount.get(pathSum) 个</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>preSumCount <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        self<span class="token punctuation">.</span>path_sum <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>target_sum <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>path_sum <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>target_sum <span class="token operator">=</span> targetSum        self<span class="token punctuation">.</span>preSumCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>path_sum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val        <span class="token comment"># 从二叉树的根节点开始，路径和为 pathSum - targetSum 的路径条数</span>        <span class="token comment"># 就是路径和为 targetSum 的路径条数</span>        self<span class="token punctuation">.</span>res <span class="token operator">+=</span> self<span class="token punctuation">.</span>preSumCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path_sum <span class="token operator">-</span> self<span class="token punctuation">.</span>target_sum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># 记录从二叉树的根节点开始，路径和为 pathSum 的路径条数</span>        self<span class="token punctuation">.</span>preSumCount<span class="token punctuation">[</span>self<span class="token punctuation">.</span>path_sum<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>preSumCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path_sum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>preSumCount<span class="token punctuation">[</span>self<span class="token punctuation">.</span>path_sum<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>preSumCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path_sum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>path_sum <span class="token operator">-=</span> root<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-11"><a href="#可视化-11" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_path-sum-iii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_path-sum-iii" src="https://labuladong.online/algo-visualize/leetcode/path-sum-iii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/6eUYwP">剑指 Offer II 050. 向下的路径节点之和 🟠</a></li></ul><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_find-bottom-left-tree-value">513. 找树左下角的值</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">513. 找树左下角的值</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/find-bottom-left-tree-value/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">根节点</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，请找出该二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">最底层 最左边<span>&nbsp;</span></strong>节点的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">假设二叉树中至少有一个节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2020/12/14/tree1.jpg" style="max-width: 100%; width: 182px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>root = [2,1,3]<strong style="font-weight: 600;">输出: </strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2020/12/14/tree2.jpg" style="max-width: 100%; width: 242px;"><strong style="font-weight: 600;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>[1,2,3,4,null,5,6,null,null,7]<strong style="font-weight: 600;">输出: </strong>7</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1,10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 513. 找树左下角的值</a>。</strong></details><h3 id="基本思路-14"><a href="#基本思路-14" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>二叉树递归框架代码是先递归左子树，后递归右子树，所以到最大深度时第一次遇到的节点就是左下角的节点。</p><p>当然，这题也可以用 BFS 层序遍历来做，留给你思考吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-14"><a href="#解法代码-14" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录二叉树的最大深度</span>        self<span class="token punctuation">.</span>maxDepth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 记录 traverse 递归遍历到的深度</span>        self<span class="token punctuation">.</span>depth <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token keyword">def</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>depth <span class="token operator">></span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">:</span>            <span class="token comment"># 到最大深度时第一次遇到的节点就是左下角的节点</span>            self<span class="token punctuation">.</span>maxDepth <span class="token operator">=</span> self<span class="token punctuation">.</span>depth            self<span class="token punctuation">.</span>res <span class="token operator">=</span> root        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-12"><a href="#可视化-12" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_find-bottom-left-tree-value" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_find-bottom-left-tree-value" src="https://labuladong.online/algo-visualize/leetcode/find-bottom-left-tree-value/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/LwUNpT">剑指 Offer II 045. 二叉树最底层最左边的值 🟠</a></li></ul><h2 id="1261-在受污染的二叉树中查找元素"><a href="#1261-在受污染的二叉树中查找元素" class="headerlink" title="1261. 在受污染的二叉树中查找元素"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_find-elements-in-a-contaminated-binary-tree">1261. 在受污染的二叉树中查找元素</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1261. 在受污染的二叉树中查找元素</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出一个满足下述规则的二叉树：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root.val == 0</code></li><li>如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.val == x</code><span>&nbsp;</span>且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.left != null</code>，那么&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.left.val == 2 * x + 1</code></li><li>如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.val == x</code><span>&nbsp;</span>且<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.right != null</code>，那么&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.right.val == 2 * x + 2</code></li></ol><p style="line-height: 1.6; overflow-wrap: break-word;">现在这个二叉树受到「污染」，所有的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">treeNode.val</code>&nbsp;都变成了&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你先还原二叉树，然后实现&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FindElements</code>&nbsp;类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FindElements(TreeNode* root)</code>&nbsp;用受污染的二叉树初始化对象，你需要先把它还原。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">bool find(int target)</code>&nbsp;判断目标值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;是否存在于还原后的二叉树中并返回结果。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1.jpg" style="max-width: 100%; height: 119px; width: 320px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FindElements","find","find"][[[-1,null,-1]],[1],[2]]<strong style="font-weight: 600;">输出：</strong>[null,false,true]<strong style="font-weight: 600;">解释：</strong>FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True </pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4.jpg" style="max-width: 100%; height: 198px; width: 400px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FindElements","find","find","find"][[[-1,-1,-1,-1,-1]],[1],[3],[5]]<strong style="font-weight: 600;">输出：</strong>[null,true,true,false]<strong style="font-weight: 600;">解释：</strong>FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);findElements.find(1); // return TruefindElements.find(3); // return TruefindElements.find(5); // return False</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1-1.jpg" style="max-width: 100%; height: 274px; width: 306px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FindElements","find","find","find","find"][[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]<strong style="font-weight: 600;">输出：</strong>[null,true,false,false,true]<strong style="font-weight: 600;">解释：</strong>FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);findElements.find(2); // return TruefindElements.find(3); // return FalsefindElements.find(4); // return FalsefindElements.find(5); // return True</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">TreeNode.val == -1</code></li><li>二叉树的高度不超过&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">20</code></li><li>节点的总数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1,&nbsp;10^4]</code>&nbsp;之间</li><li>调用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">find()</code>&nbsp;的总次数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1,&nbsp;10^4]</code>&nbsp;之间</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= target &lt;= 10^6</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1261. 在受污染的二叉树中查找元素</a>。</strong></details><h3 id="基本思路-15"><a href="#基本思路-15" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>还原二叉树的时候只需要遍历所有节点，通过函数参数传递每个节点的值；由于节点的个数规模不算大，所以可以直接用一个 HashSet 缓存所有节点值，实现 <code>find</code> 函数的功能。</p><p>当然，题目给的这种二叉树节点的取值规律非常像用数组存储完全二叉树的场景，所以你应该可以通过 <code>target</code> 推算出来它在第几层的什么位置，不过我这里就不实现了，类似的题目你可以参考 <a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree">1104. 二叉树寻路</a> 和 <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree">662. 二叉树最大宽度</a>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-15"><a href="#解法代码-15" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">FindElements</span><span class="token punctuation">:</span>    <span class="token comment"># 帮助 find 函数快速判断</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 还原二叉树中的值</span>        self<span class="token punctuation">.</span>values <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        root<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span>values<span class="token punctuation">.</span>add<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> val <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> target <span class="token keyword">in</span> self<span class="token punctuation">.</span>values<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_lexicographical-numbers">386. 字典序排数</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">386. 字典序排数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/lexicographical-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/lexicographical-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，按字典序返回范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, n]</code><span>&nbsp;</span>内所有整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你必须设计一个时间复杂度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(n)</code><span>&nbsp;</span>且使用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(1)</code><span>&nbsp;</span>额外空间的算法。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 13<strong style="font-weight: 600;">输出：</strong>[1,10,11,12,13,2,3,4,5,6,7,8,9]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 2<strong style="font-weight: 600;">输出：</strong>[1,2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/lexicographical-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 386. 字典序排数</a>。</strong></details><h3 id="基本思路-16"><a href="#基本思路-16" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这个题还挺有意思，要不是它把这道题放在 DFS 的题目分类里面，可能还不太好发现这是一个 DFS 的题目。</p><p>既然题目提示你这是个 DFS 的题目了，你心里那棵递归树出来没有？如果没有，建议去看看前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树视角学习递归思维</a>。</p><p>它的递归树大概是这样生长的：</p><p>首先看 1 这个节点，1 可以生出二位数 10, 11, 12…</p><p>其中 10 又可以生出 100, 101, 102…，11 又可以生出 110, 111, 112…</p><p>这棵多叉树是不是就出来了？每个节点最多可以生出 10 个节点，这就是一个十叉树。</p><p>还是想不出来？看可视化面板。实际的解法代码需要以 1~9 分别作为根节点，画 9 棵多叉树，<strong>这里仅仅以 1 为根节点画递归树，方便你理解</strong>：</p><details data-v-ee1a9bd0="" id="div_lexicographical-numbers-example" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lexicographical-numbers-example" src="https://labuladong.online/algo-visualize/tutorial/lexicographical-numbers-example/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>我们只需要以前序顺序遍历这棵多叉树，收集所有小于 <code>n</code> 的节点，就可以得到题目想要的答案。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-16"><a href="#解法代码-16" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 总共有 9 棵多叉树，从 1 开始</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 多叉树遍历框架，前序位置收集所有小于 n 的节点</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">></span> n<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">for</span> child <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>root <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span> root <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> child <span class="token operator">></span> n<span class="token punctuation">:</span>                <span class="token keyword">break</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>child<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1104-二叉树寻路"><a href="#1104-二叉树寻路" class="headerlink" title="1104. 二叉树寻路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_path-in-zigzag-labelled-binary-tree">1104. 二叉树寻路</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1104. 二叉树寻路</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点<span>&nbsp;</span><strong style="font-weight: 600;">逐行</strong><span>&nbsp;</span>依次按&nbsp;“之” 字形进行标记。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p><p style="line-height: 1.6; overflow-wrap: break-word;">而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/06/28/tree.png" style="max-width: 100%; height: 138px; width: 300px;"></p><p style="line-height: 1.6; overflow-wrap: break-word;">给你树上某一个节点的标号<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">label</code>，请你返回从根节点到该标号为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">label</code><span>&nbsp;</span>节点的路径，该路径是由途经的节点标号所组成的。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>label = 14<strong style="font-weight: 600;">输出：</strong>[1,3,4,14]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>label = 26<strong style="font-weight: 600;">输出：</strong>[1,2,6,10,26]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= label &lt;= 10^6</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1104. 二叉树寻路</a>。</strong></details><h3 id="基本思路-17"><a href="#基本思路-17" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>如果你看过前文 <a href="https://labuladong.online/algo/data-structure-basic/binary-heap-basic/">二叉堆（优先级队列）原理及实现</a>，就知道这种完全二叉树可以通过索引来模拟左右指针以及父节点指针。</p><p>具体来说，先假设全都是从左到右排列，没有之字形排列的这个条件：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/1104.png" alt="img"></p><p>如果我想求到达某一个 <code>label</code> 节点的路径，那么我一直对 <code>label</code> 除以 2 就行了（忽略余数）。</p><p>你比如我想求到达 13 的路径，就是 13, 6, 3, 1，然后反转一下就行了。大致的代码逻辑如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>label <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>    label <span class="token operator">=</span> label <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 反转成从根节点到目标节点的路径</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在虽然是之字形排列，但稍加修改就可以适应这个变化：</p><p><img src="/tree.png" alt="img"></p><p>13 的父节点不是 6 了，而是 7 - (6 - 4) &#x3D; 5。</p><p>这个 7 和 4 是哪里来的？就是 6 这一行的最小节点值和最大节点值，而对于完全二叉树，每一行的最大最小值可以通过计算 2 的指数算出来的。</p><p>理解了上述思路，就能看懂解法代码了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-17"><a href="#解法代码-17" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathInZigZagTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> label <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>label<span class="token punctuation">)</span>            label <span class="token operator">=</span> label <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> label <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            depth <span class="token operator">=</span> self<span class="token punctuation">.</span>log<span class="token punctuation">(</span>label<span class="token punctuation">)</span>            range_ <span class="token operator">=</span> self<span class="token punctuation">.</span>getLevelRange<span class="token punctuation">(</span>depth<span class="token punctuation">)</span>            <span class="token comment"># 由于之字形分布，根据上层的节点取值范围，修正父节点</span>            label <span class="token operator">=</span> range_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>label <span class="token operator">-</span> range_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment"># 反转成从根节点到目标节点的路径</span>        path<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> path    <span class="token comment"># 获取第 n 层节点的取值范围</span>    <span class="token keyword">def</span> <span class="token function">getLevelRange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> n        <span class="token keyword">return</span> <span class="token punctuation">[</span>p<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-13"><a href="#可视化-13" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_path-in-zigzag-labelled-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_path-in-zigzag-labelled-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/path-in-zigzag-labelled-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree">1261. 在受污染的二叉树中查找元素 🟠</a></li><li><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree">662. 二叉树最大宽度 🟠</a></li><li><a href="https://leetcode.cn/problems/path-sum-iv">666. 路径总和 IV 🟠</a></li></ul><h2 id="1145-二叉树着色游戏"><a href="#1145-二叉树着色游戏" class="headerlink" title="1145. 二叉树着色游戏"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_binary-tree-coloring-game">1145. 二叉树着色游戏</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1145. 二叉树着色游戏</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-coloring-game/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-coloring-game/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，树上总共有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点，且<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>为奇数，其中每个节点上的值从&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;各不相同。</p><p style="line-height: 1.6; overflow-wrap: break-word;">最开始时：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>「一号」玩家从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, n]</code>&nbsp;中取一个值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code>（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= x &lt;= n</code>）；</li><li>「二号」玩家也从&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, n]</code>&nbsp;中取一个值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code>（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= y &lt;= n</code>）且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y != x</code>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">「一号」玩家给值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code>&nbsp;的节点染上红色，而「二号」玩家给值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code>&nbsp;的节点染上蓝色。</p><p style="line-height: 1.6; overflow-wrap: break-word;">之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个<span>&nbsp;</span><strong style="font-weight: 600;">未着色<span>&nbsp;</span></strong>的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。</p><p style="line-height: 1.6; overflow-wrap: break-word;">若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。</p><p style="line-height: 1.6; overflow-wrap: break-word;">现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code>&nbsp;值可以确保你赢得这场游戏，则返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；若无法获胜，就请返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</p>&nbsp;<p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1 ：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/08/01/1480-binary-tree-coloring-game.png" style="max-width: 100%; width: 500px; height: 310px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>第二个玩家可以选择值为 2 的节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], n = 3, x = 1<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= x &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>是奇数</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= n</code></li><li>树中所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-coloring-game/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1145. 二叉树着色游戏</a>。</strong></details><h3 id="基本思路-18"><a href="#基本思路-18" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>这道题的关键是要观察规律，根据游戏规则，对方先选一个节点之后，你的最优策略就是紧贴着对方的那个节点选择，也就是说你应该选择节点 <code>x</code> 的左右子节点或者父节点。</p><p>做出以上三种选择，你可以占据二叉树的不同部分，如下图：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/1145.png" alt="img"></p><p>你如果想赢，必须占据超过 <code>n / 2</code> 的节点，也就是说，如果这三个蓝色区域中节点数最多的那个区域中的节点个数大于 <code>n / 2</code>，你能赢，否则你就输。</p><p>所以本题转化为计算二叉树节点个数的简单问题，具体看代码逻辑。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-18"><a href="#解法代码-18" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">btreeGameWinningMove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span>        left_count <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right_count <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        other_count <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> left_count <span class="token operator">-</span> right_count        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_count<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">(</span>right_count<span class="token punctuation">,</span> other_count<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> n <span class="token operator">//</span> <span class="token number">2</span>    <span class="token comment"># 定义：在以 root 为根的二叉树中搜索值为 x 的节点并返回</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> x<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token comment"># 去左子树找</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span>        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> left        <span class="token comment"># 左子树找不到的话去右子树找</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span>    <span class="token comment"># 定义：计算以 root 为根的二叉树的节点总数</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-14"><a href="#可视化-14" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-coloring-game" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-coloring-game" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-coloring-game/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="2096-从二叉树一个节点到另一个节点每一步的方向"><a href="#2096-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="2096. 从二叉树一个节点到另一个节点每一步的方向"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_step-by-step-directions-from-a-binary-tree-node-to-another">2096. 从二叉树一个节点到另一个节点每一步的方向</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">2096. 从二叉树一个节点到另一个节点每一步的方向</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵<span>&nbsp;</span><strong style="font-weight: 600;">二叉树</strong>&nbsp;的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，这棵二叉树总共有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;个节点。每个节点的值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;中的一个整数，且互不相同。给你一个整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">startValue</code>&nbsp;，表示起点节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;的值，和另一个不同的整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">destValue</code>&nbsp;，表示终点节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code>&nbsp;的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请找到从节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;到节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code>&nbsp;的<span>&nbsp;</span><strong style="font-weight: 600;">最短路径</strong>&nbsp;，并以字符串的形式返回每一步的方向。每一步用<span>&nbsp;</span><strong style="font-weight: 600;">大写</strong>&nbsp;字母&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'L'</code>&nbsp;，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'R'</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'U'</code>&nbsp;分别表示一种方向：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'L'</code>&nbsp;表示从一个节点前往它的<span>&nbsp;</span><strong style="font-weight: 600;">左孩子</strong>&nbsp;节点。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'R'</code>&nbsp;表示从一个节点前往它的<span>&nbsp;</span><strong style="font-weight: 600;">右孩子</strong>&nbsp;节点。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'U'</code>&nbsp;表示从一个节点前往它的<span>&nbsp;</span><strong style="font-weight: 600;">父</strong>&nbsp;节点。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code>&nbsp;<strong style="font-weight: 600;">最短路径</strong>&nbsp;每一步的方向。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/11/15/eg1.png" style="max-width: 100%; width: 214px; height: 163px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6<b>输出：</b>"UURL"<b>解释：</b>最短路径为：3 → 1 → 5 → 2 → 6 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/11/15/eg2.png" style="max-width: 100%; width: 74px; height: 102px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>root = [2,1], startValue = 2, destValue = 1<b>输出：</b>"L"<b>解释：</b>最短路径为：2 → 1 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= n</code></li><li>树中所有节点的值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong>&nbsp;。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= startValue, destValue &lt;= n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">startValue != destValue</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 2096. 从二叉树一个节点到另一个节点每一步的方向</a>。</strong></details><h3 id="基本思路-19"><a href="#基本思路-19" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维模式。</p><p>这题的思路比较巧妙，主要分三步：</p><p>1、分别记录从根节点到 <code>startValue</code> 和 <code>destValue</code> 的路径 <code>startPath</code> 和 <code>destPath</code>。</p><p>2、然后去除 <code>startPath</code> 和 <code>destPath</code> 的公共前缀。</p><p>3、最后将 <code>startPath</code> 全部变成 <code>U</code>，把 <code>startPath</code> 和 <code>destPath</code> 接在一起，就是题目要求的路径了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-19"><a href="#解法代码-19" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getDirections</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> startValue<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> destValue<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>startValue <span class="token operator">=</span> startValue        self<span class="token punctuation">.</span>destValue <span class="token operator">=</span> destValue        <span class="token comment"># 寻找走到 startValue 和 destValue 的方向路径</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 去除两个方向路径的公共前缀</span>        p <span class="token operator">=</span> <span class="token number">0</span>        m <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>startPath<span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>destPath<span class="token punctuation">)</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;</span> m <span class="token keyword">and</span> p <span class="token operator">&lt;</span> n <span class="token keyword">and</span> self<span class="token punctuation">.</span>startPath<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>destPath<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>            p <span class="token operator">+=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>startPath <span class="token operator">=</span> self<span class="token punctuation">.</span>startPath<span class="token punctuation">[</span>p<span class="token punctuation">:</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>destPath <span class="token operator">=</span> self<span class="token punctuation">.</span>destPath<span class="token punctuation">[</span>p<span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token comment"># 将走向 startValue 的方向路径全部变成 U</span>        self<span class="token punctuation">.</span>startPath <span class="token operator">=</span> <span class="token string">'U'</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>startPath<span class="token punctuation">)</span>        <span class="token comment"># 组合 startPath 和 destPath 就得到了答案</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>startPath <span class="token operator">+</span> self<span class="token punctuation">.</span>destPath    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token string">''</span>        self<span class="token punctuation">.</span>startPath <span class="token operator">=</span> <span class="token string">''</span>        self<span class="token punctuation">.</span>destPath <span class="token operator">=</span> <span class="token string">''</span>        self<span class="token punctuation">.</span>startValue <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>destValue <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>startValue<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>startPath <span class="token operator">=</span> self<span class="token punctuation">.</span>path        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>destValue<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>destPath <span class="token operator">=</span> self<span class="token punctuation">.</span>path        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>path <span class="token operator">+=</span> <span class="token string">'L'</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>path <span class="token operator">+=</span> <span class="token string">'R'</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>path <span class="token operator">=</span> self<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-15"><a href="#可视化-15" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_step-by-step-directions-from-a-binary-tree-node-to-another" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_step-by-step-directions-from-a-binary-tree-node-to-another" src="https://labuladong.online/algo-visualize/leetcode/step-by-step-directions-from-a-binary-tree-node-to-another/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>Tip</p><p>题目也可以让你在二叉树中寻找某棵子树，这种情况下会在递归函数中调用其他递归函数，时间复杂度会上升到平方级别，但也没有什么别的办法优化，只能通过遍历来对比子树。</p><h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_subtree-of-another-tree">572. 另一棵树的子树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">572. 另一棵树的子树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/subtree-of-another-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/subtree-of-another-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你两棵二叉树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subRoot</code><span>&nbsp;</span>。检验<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>中是否包含和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subRoot</code><span>&nbsp;</span>具有相同结构和节点值的子树。如果存在，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">二叉树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tree</code><span>&nbsp;</span>的一棵子树包括<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tree</code><span>&nbsp;</span>的某个节点和这个节点的所有后代节点。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tree</code><span>&nbsp;</span>也可以看做它自身的一棵子树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/04/28/subtree1-tree.jpg" style="max-width: 100%; width: 532px; height: 400px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,4,5,1,2], subRoot = [4,1,2]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/04/28/subtree2-tree.jpg" style="max-width: 100%; width: 502px; height: 458px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>树上的节点数量范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2000]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subRoot</code><span>&nbsp;</span>树上的节点数量范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= root.val &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= subRoot.val &lt;= 10<sup>4</sup></code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/subtree-of-another-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 572. 另一棵树的子树</a>。</strong></details><h3 id="基本思路-20"><a href="#基本思路-20" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-7">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>遍历以 <code>root</code> 为根的这棵二叉树的所有节点，用 <a href="https://leetcode.cn/problems/same-tree">100. 相同的树</a> 中的 <code>isSame</code> 函数判断以该节点为根的子树是否和以 <code>subRoot</code> 为根的那棵树相同。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> subRoot<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> subRoot <span class="token keyword">is</span> <span class="token boolean">None</span>        <span class="token comment"># 判断以 root 为根的二叉树是否和 subRoot 相同</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>root<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment"># 去左右子树中判断是否有和 subRoot 相同的子树</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSubtree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>isSubtree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 判断一对节点是否相同</span>        <span class="token keyword">if</span> p <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> q <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> p <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> q <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">!=</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 判断其他节点是否相同</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-16"><a href="#可视化-16" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_subtree-of-another-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_subtree-of-another-tree" src="https://labuladong.online/algo-visualize/leetcode/subtree-of-another-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1367-二叉树中的列表"><a href="#1367-二叉树中的列表" class="headerlink" title="1367. 二叉树中的列表"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#slug_linked-list-in-binary-tree">1367. 二叉树中的列表</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1367. 二叉树中的链表</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/linked-list-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/linked-list-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵以&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;为根的二叉树和一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code>&nbsp;为第一个节点的链表。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code>&nbsp;为首的链表中每个节点的值，那么请你返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">True</code><span>&nbsp;</span>，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">False</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png" style="max-width: 100%; height: 280px; width: 220px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>树中蓝色的节点构成了与链表对应的子路径。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png" style="max-width: 100%; height: 280px; width: 220px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>二叉树中不存在一一对应链表的路径。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树和链表中的每个节点的值都满足&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= node.val&nbsp;&lt;= 100</code>&nbsp;。</li><li>链表包含的节点数目在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code>&nbsp;之间。</li><li>二叉树包含的节点数目在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2500</code>&nbsp;之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/linked-list-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1367. 二叉树中的链表</a>。</strong></details><h3 id="基本思路-21"><a href="#基本思路-21" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-8">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>本质上，<code>isSubPath</code> 就是在遍历二叉树的所有节点，对每个节点用 <code>check</code> 函数判断是否能够将链表嵌进去。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/">【练习】用「遍历」思维解题 III</a></li></ul><h3 id="解法代码-20"><a href="#解法代码-20" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-8">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 当找到一个二叉树节点的值等于链表头结点时</span>        <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token comment"># 判断是否能把链表嵌进去</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>check<span class="token punctuation">(</span>head<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment"># 继续去遍历其他节点尝试嵌入链表</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSubPath<span class="token punctuation">(</span>head<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>isSubPath<span class="token punctuation">(</span>head<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 检查是否能够将链表嵌入二叉树</span>    <span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token comment"># 在子树上嵌入子链表</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>check<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>check<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-17"><a href="#可视化-17" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-traverse-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-6">可视化</a></h3><details data-v-ee1a9bd0="" id="div_linked-list-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_linked-list-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/linked-list-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h1 id="【练习】用「分解问题」思维解题-I"><a href="#【练习】用「分解问题」思维解题-I" class="headerlink" title="【练习】用「分解问题」思维解题 I"></a>【练习】用「分解问题」思维解题 I</h1><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">105. 从前序与中序遍历序列构造二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定两个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code><span>&nbsp;</span>是二叉树的<strong style="font-weight: 600;">先序遍历</strong>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;是同一棵树的<strong style="font-weight: 600;">中序遍历</strong>，请构造二叉树并返回其根节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/tree.jpg" style="max-width: 100%; height: 302px; width: 277px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong><strong style="font-weight: 600;">:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<strong style="font-weight: 600;">输出:</strong> [3,9,20,null,null,15,7]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> preorder = [-1], inorder = [-1]<strong style="font-weight: 600;">输出:</strong> [-1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= preorder.length &lt;= 3000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder.length == preorder.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;均<span>&nbsp;</span><strong style="font-weight: 600;">无重复</strong><span>&nbsp;</span>元素</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;均出现在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code>&nbsp;<strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>为二叉树的前序遍历序列</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;<strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>为二叉树的中序遍历序列</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 105. 从前序与中序遍历序列构造二叉树</a>。</strong></details><h3 id="基本思路-22"><a href="#基本思路-22" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p><strong>构造二叉树，第一件事一定是找根节点，然后想办法构造左右子树</strong>。</p><p>二叉树的前序和中序遍历结果的特点如下：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/1.jpeg" alt="img"></p><p>前序遍历结果第一个就是根节点的值，然后再根据中序遍历结果确定左右子树的节点。</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/4.jpeg" alt="img"></p><p>结合这个图看代码辅助理解。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a></li><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-21"><a href="#解法代码-21" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 存储 inorder 中值到索引的映射</span>    valToIndex <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>valToIndex<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>                          inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># build 函数的定义：</span>    <span class="token comment"># 若前序遍历数组为 preorder[preStart..preEnd]，</span>    <span class="token comment"># 中序遍历数组为 inorder[inStart..inEnd]，</span>    <span class="token comment"># 构造二叉树，返回该二叉树的根节点</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> preStart<span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span>               inorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> inEnd<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> preStart <span class="token operator">></span> preEnd<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># root 节点对应的值就是前序遍历数组的第一个元素</span>        rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span>        <span class="token comment"># rootVal 在中序遍历数组中的索引</span>        index <span class="token operator">=</span> self<span class="token punctuation">.</span>valToIndex<span class="token punctuation">[</span>rootVal<span class="token punctuation">]</span>        leftSize <span class="token operator">=</span> index <span class="token operator">-</span> inStart        <span class="token comment"># 先构造出当前根节点</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>         <span class="token comment"># 递归构造左右子树</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preStart <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>                               inorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span>                                inorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/maximum-binary-tree">654. 最大二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal">889. 根据前序和后序遍历构造二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof">剑指 Offer 07. 重建二叉树 🟠</a></li></ul><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">106. 从中序与后序遍历序列构造二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定两个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code><span>&nbsp;</span>，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code><span>&nbsp;</span>是二叉树的中序遍历，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code><span>&nbsp;</span>是同一棵树的后序遍历，请你构造并返回这颗&nbsp;<em>二叉树</em>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/tree.jpg" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<b>输出：</b>[3,9,20,null,null,15,7]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>inorder = [-1], postorder = [-1]<b>输出：</b>[-1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= inorder.length &lt;= 3000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder.length == inorder.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code>&nbsp;都由<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong><span>&nbsp;</span>的值组成</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code>&nbsp;中每一个值都在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;中</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">inorder</code>&nbsp;<strong style="font-weight: 600;">保证</strong>是树的中序遍历</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code>&nbsp;<strong style="font-weight: 600;">保证</strong>是树的后序遍历</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 106. 从中序与后序遍历序列构造二叉树</a>。</strong></details><h3 id="基本思路-23"><a href="#基本思路-23" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p><strong>构造二叉树，第一件事一定是找根节点，然后想办法构造左右子树</strong>。</p><p>二叉树的后序和中序遍历结果的特点如下：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/5.jpeg" alt="img"></p><p>后序遍历结果最后一个就是根节点的值，然后再根据中序遍历结果确定左右子树的节点。</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/6.jpeg" alt="img"></p><p>结合这个图看代码辅助理解。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a></li><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-22"><a href="#解法代码-22" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 存储 inorder 中值到索引的映射</span>    val_to_index <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>val_to_index<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>                          postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 定义：中序遍历数组为 inorder[inStart..inEnd]，</span>    <span class="token comment"># 后序遍历数组为 postorder[postStart..postEnd]，</span>    <span class="token comment"># build 函数构造这个二叉树并返回该二叉树的根节点</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> in_start<span class="token punctuation">,</span> in_end<span class="token punctuation">,</span>              postorder<span class="token punctuation">,</span> post_start<span class="token punctuation">,</span> post_end<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> in_start <span class="token operator">></span> in_end<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># root 节点对应的值就是后序遍历数组的最后一个元素</span>        root_val <span class="token operator">=</span> postorder<span class="token punctuation">[</span>post_end<span class="token punctuation">]</span>        <span class="token comment"># rootVal 在中序遍历数组中的索引</span>        index <span class="token operator">=</span> self<span class="token punctuation">.</span>val_to_index<span class="token punctuation">[</span>root_val<span class="token punctuation">]</span>        <span class="token comment"># 左子树的节点个数</span>        left_size <span class="token operator">=</span> index <span class="token operator">-</span> in_start        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>root_val<span class="token punctuation">)</span>         <span class="token comment"># 递归构造左右子树</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> in_start<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>                               postorder<span class="token punctuation">,</span> post_start<span class="token punctuation">,</span> post_start <span class="token operator">+</span> left_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> in_end<span class="token punctuation">,</span>                                postorder<span class="token punctuation">,</span> post_start <span class="token operator">+</span> left_size<span class="token punctuation">,</span> post_end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-18"><a href="#可视化-18" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_construct-binary-tree-from-inorder-and-postorder-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_construct-binary-tree-from-inorder-and-postorder-traversal" src="https://labuladong.online/algo-visualize/leetcode/construct-binary-tree-from-inorder-and-postorder-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/maximum-binary-tree">654. 最大二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal">889. 根据前序和后序遍历构造二叉树 🟠</a></li></ul><h2 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_construct-binary-tree-from-preorder-and-postorder-traversal">889. 根据前序和后序遍历构造二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">889. 根据前序和后序遍历构造二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定两个整数数组，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code>&nbsp;和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code><span>&nbsp;</span>，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code><span>&nbsp;</span>是一个具有<span>&nbsp;</span><strong style="font-weight: 600;">无重复</strong><span>&nbsp;</span>值的二叉树的前序遍历，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code><span>&nbsp;</span>是同一棵树的后序遍历，重构并返回二叉树。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果存在多个答案，您可以返回其中<span>&nbsp;</span><strong style="font-weight: 600;">任何</strong><span>&nbsp;</span>一个。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/07/24/lc-prepost.jpg" style="max-width: 100%; height: 265px; width: 304px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]<strong style="font-weight: 600;">输出：</strong>[1,2,3,4,5,6,7]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> preorder = [1], postorder = [1]<strong style="font-weight: 600;">输出:</strong> [1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= preorder.length &lt;= 30</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= preorder[i] &lt;= preorder.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code>&nbsp;中所有值都<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder.length == preorder.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= postorder[i] &lt;= postorder.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code>&nbsp;中所有值都<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong></li><li>保证<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code>&nbsp;和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">postorder</code>&nbsp;是同一棵二叉树的前序遍历和后序遍历</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 889. 根据前序和后序遍历构造二叉树</a>。</strong></details><h3 id="基本思路-24"><a href="#基本思路-24" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>做这道题之前，建议你先看一下 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a>，做一下 <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树（中等）</a> 和 <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树（中等）</a> 这两道题。</p><p>这道题让用后序遍历和前序遍历结果还原二叉树，和前两道题有一个本质的区别：</p><p><strong>通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树</strong>。题目也说了，如果有多种结果，你可以返回任意一种。</p><p>为什么呢？我们说过，构建二叉树的套路很简单，先找到根节点，然后找到并递归构造左右子树即可。</p><p>前两道题，可以通过前序或者后序遍历结果找到根节点，然后根据中序遍历结果确定左右子树。</p><p>这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点。</p><p>举个例子，下面这两棵树结构不同，但是它们的前序遍历和后序遍历结果是相同的：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/7.png" alt="img"></p><p>不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：</p><p><strong>1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值</strong>。</p><p><strong>2、然后把前序遍历结果的第二个元素作为左子树的根节点的值</strong>。</p><p><strong>3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可</strong>。</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/8.jpeg" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a></li><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-23"><a href="#解法代码-23" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 存储 postorder 中值到索引的映射</span>    valToIndex <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">constructFromPrePost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>valToIndex<span class="token punctuation">[</span>postorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>                          postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]</span>    <span class="token comment"># 构建二叉树，并返回根节点。</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> preStart<span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span>              postorder<span class="token punctuation">,</span> postStart<span class="token punctuation">,</span> postEnd<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> preStart <span class="token operator">></span> preEnd<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> preStart <span class="token operator">==</span> preEnd<span class="token punctuation">:</span>            <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># root 节点对应的值就是前序遍历数组的第一个元素</span>        rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span>        <span class="token comment"># root.left 的值是前序遍历第二个元素</span>        <span class="token comment"># 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点</span>        <span class="token comment"># 确定 preorder 和 postorder 中左右子树的元素区间</span>        leftRootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment"># leftRootVal 在后序遍历数组中的索引</span>        index <span class="token operator">=</span> self<span class="token punctuation">.</span>valToIndex<span class="token punctuation">[</span>leftRootVal<span class="token punctuation">]</span>        <span class="token comment"># 左子树的元素个数</span>        leftSize <span class="token operator">=</span> index <span class="token operator">-</span> postStart <span class="token operator">+</span> <span class="token number">1</span>             <span class="token comment"># 先构造出当前根节点</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>         <span class="token comment"># 递归构造左右子树</span>        <span class="token comment"># 根据左子树的根节点索引和元素个数推导左右子树的索引边界</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preStart <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>                               postorder<span class="token punctuation">,</span> postStart<span class="token punctuation">,</span> index<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span>                                postorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> postEnd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-19"><a href="#可视化-19" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_construct-binary-tree-from-preorder-and-postorder-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_construct-binary-tree-from-preorder-and-postorder-traversal" src="https://labuladong.online/algo-visualize/leetcode/construct-binary-tree-from-preorder-and-postorder-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/maximum-binary-tree">654. 最大二叉树 🟠</a></li></ul><h2 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_verify-preorder-serialization-of-a-binary-tree">331. 验证二叉树的前序序列化</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">331. 验证二叉树的前序序列化</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">序列化二叉树的一种方法是使用<span>&nbsp;</span><strong style="font-weight: 600;">前序遍历<span>&nbsp;</span></strong>。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">#</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/12/pre-tree.jpg" style="max-width: 100%;"></p><p style="line-height: 1.6; overflow-wrap: break-word;">例如，上面的二叉树可以被序列化为字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"9,3,4,#,#,1,#,#,2,#,6,#,#"</code>，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">#</code><span>&nbsp;</span>代表一个空节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>每个以逗号分隔的字符或为一个整数或为一个表示<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">null</code><span>&nbsp;</span>指针的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'#'</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你可以认为输入格式总是有效的</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如它永远不会包含两个连续的逗号，比如&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"1,,3"</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong>不允许重建树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>preorder = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">"9,3,4,#,#,1,#,#,2,#,6,#,#"</code><strong style="font-weight: 600;">输出: </strong><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">true</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>preorder = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">"1,#"</code><strong style="font-weight: 600;">输出: </strong><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">false</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>preorder = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">"9,#,#,1"</code><strong style="font-weight: 600;">输出: </strong><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">false</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code>&nbsp;由以逗号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">“，”</code><span>&nbsp;</span>分隔的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,100]</code><span>&nbsp;</span>范围内的整数和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">“#”</code><span>&nbsp;</span>组成</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 331. 验证二叉树的前序序列化</a>。</strong></details><h3 id="基本思路-25"><a href="#基本思路-25" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>首先，如果看过前文 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">手把手带你刷二叉树（序列化篇）</a> 理解了前序遍历序列化和反序列化的原理，肯定可以通过改造反序列化函数 <code>deserialize</code> 来判断序列化的合法性。</p><p>另外还有一种更巧妙的解法，就是利用二叉树节点和边的关系。</p><p>每个非空的二叉树节点都会产生两条边，并消耗一条边；而每个空节点只会消耗一条边：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/331.jpeg" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-24"><a href="#解法代码-24" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidSerialization</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 一条指向根节点的虚拟边</span>        edge <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> node <span class="token keyword">in</span> preorder<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 任何时候，边数都不能小于 0</span>            <span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">:</span>                <span class="token comment"># 空指针消耗一条空闲边</span>                edge <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> edge <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 非空节点消耗一条空闲边，增加两条空闲边</span>                edge <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> edge <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                edge <span class="token operator">+=</span> <span class="token number">2</span>        <span class="token comment"># 最后不应该存在空闲边</span>        <span class="token keyword">return</span> edge <span class="token operator">==</span> <span class="token number">0</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidSerialization</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 将字符串转化成列表</span>        nodes <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>    <span class="token comment"># 改造后的前序遍历反序列化函数</span>    <span class="token comment"># 详细解析：https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> nodes<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># ***** 前序遍历位置 *****</span>        <span class="token comment"># 列表最左侧就是根节点</span>        first <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> first <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment"># *********************</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-20"><a href="#可视化-20" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_verify-preorder-serialization-of-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_verify-preorder-serialization-of-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/verify-preorder-serialization-of-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="894-所有可能的满二叉树"><a href="#894-所有可能的满二叉树" class="headerlink" title="894. 所有可能的满二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_all-possible-full-binary-trees">894. 所有可能的满二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">894. 所有可能的真二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/all-possible-full-binary-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/all-possible-full-binary-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，请你找出所有可能含<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点的<span>&nbsp;</span><strong style="font-weight: 600;">真二叉树</strong><span>&nbsp;</span>，并以列表形式返回。答案中每棵树的每个节点都必须符合<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val == 0</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">答案的每个元素都是一棵真二叉树的根节点。你可以按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>返回最终的真二叉树列表<strong style="font-weight: 600;">。</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">真二叉树</strong><span>&nbsp;</span>是一类二叉树，树中每个节点恰好有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>个子节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/08/22/fivetrees.png" style="max-width: 100%; width: 700px; height: 400px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 7<strong style="font-weight: 600;">输出：</strong>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 3<strong style="font-weight: 600;">输出：</strong>[[0,0,0]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 20</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/all-possible-full-binary-trees/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 894. 所有可能的真二叉树</a>。</strong></details><h3 id="基本思路-26"><a href="#基本思路-26" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>注意：国外和国内关于完全二叉树、满二叉树的定义有区别，我在 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础知识</a> 有介绍。不过这些文学词汇并不重要，重要的是算法思维，所以我们按照题目说的来就好。</p><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>如果你想生成一棵 <code>n</code> 个节点的满二叉树，首先要固定根节点，然后组装左右子树，根节点加上左右子树节点之和应该等于 <code>n</code>。</p><p>我们定义 <code>helper</code> 能够生成节点数为 <code>n</code> 的所有可能的二叉树，然后利用这个定义生成左右子树，然后通过子树组装出结果即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-25"><a href="#解法代码-25" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 备忘录，记录 n 个节点能够组合成的所有可能二叉树</span>    memo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">allPossibleFBT</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 题目描述的满二叉树不可能是偶数个节点</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>TreeNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token comment"># 定义：输入一个 n，生成节点树为 n 的所有可能的满二叉树</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token keyword">in</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">:</span>            <span class="token comment"># 避免冗余计算</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>TreeNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 递归生成所有符合条件的左右子树</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span>            <span class="token comment"># 利用函数定义，生成左右子树</span>            leftSubTrees <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            rightSubTrees <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>j<span class="token punctuation">)</span>            <span class="token comment"># 左右子树的不同排列也能构成不同的二叉树</span>            <span class="token keyword">for</span> left <span class="token keyword">in</span> leftSubTrees<span class="token punctuation">:</span>                <span class="token keyword">for</span> right <span class="token keyword">in</span> rightSubTrees<span class="token punctuation">:</span>                    <span class="token comment"># 生成根节点</span>                    root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token comment"># 组装出一种可能的二叉树形状</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right                    <span class="token comment"># 加入结果列表</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 存入备忘录</span>        self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-21"><a href="#可视化-21" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_all-possible-full-binary-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_all-possible-full-binary-trees" src="https://labuladong.online/algo-visualize/leetcode/all-possible-full-binary-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="998-最大二叉树-II"><a href="#998-最大二叉树-II" class="headerlink" title="998. 最大二叉树 II"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_maximum-binary-tree-ii">998. 最大二叉树 II</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">998. 最大二叉树 II</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-binary-tree-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-binary-tree-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">最大树</strong><span>&nbsp;</span>定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你最大树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">就像<span>&nbsp;</span><a href="https://leetcode.cn/problems/maximum-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">之前的问题</a><span>&nbsp;</span>那样，给定的树是利用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Construct(a)</code>&nbsp;例程从列表&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a</code>（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root = Construct(a)</code>）递归地构建的：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a</code><span>&nbsp;</span>为空，返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">null</code><span>&nbsp;</span>。</li><li>否则，令&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a[i]</code><span>&nbsp;</span>作为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a</code><span>&nbsp;</span>的最大元素。创建一个值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a[i]</code>&nbsp;的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的左子树将被构建为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Construct([a[0], a[1], ..., a[i - 1]])</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的右子树将被构建为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])</code><span>&nbsp;</span>。</li><li>返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">请注意，题目没有直接给出<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a</code><span>&nbsp;</span>，只是给出一个根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root = Construct(a)</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">假设<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">b</code><span>&nbsp;</span>是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">a</code><span>&nbsp;</span>的副本，并在末尾附加值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code>。题目数据保证<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">b</code><span>&nbsp;</span>中的值互不相同。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Construct(b)</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png" style="max-width: 100%; height: 160px; width: 159px;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png" style="max-width: 100%; height: 160px; width: 169px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,1,3,null,null,2], val = 5<strong style="font-weight: 600;">输出：</strong>[5,4,null,1,3,null,null,2]<strong style="font-weight: 600;">解释：</strong>a = [1,4,2,3], b = [1,4,2,3,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png" style="max-width: 100%; height: 160px; width: 180px;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png" style="max-width: 100%; height: 160px; width: 214px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,2,4,null,1], val = 3<strong style="font-weight: 600;">输出：</strong>[5,2,4,null,1,null,3]<strong style="font-weight: 600;">解释：</strong>a = [2,1,5,4], b = [2,1,5,4,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png" style="max-width: 100%; height: 160px; width: 180px;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png" style="max-width: 100%; height: 160px; width: 201px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,2,3,null,1], val = 4<strong style="font-weight: 600;">输出：</strong>[5,2,4,null,1,3]<strong style="font-weight: 600;">解释：</strong>a = [2,1,5,3], b = [2,1,5,3,4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 100</code></li><li>树中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-binary-tree-ii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 998. 最大二叉树 II</a>。</strong></details><h3 id="基本思路-27"><a href="#基本思路-27" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>做这道题之前，你一定要去做一下 <a href="https://leetcode.cn/problems/maximum-binary-tree">654. 最大二叉树</a> 这道题，知道了构建最大二叉树的逻辑就很容易解决这道题了。</p><p>新增的 <code>val</code> 是添加在原始数组的最后的，根据构建最大二叉树的逻辑，正常来说最后的这个值一定是在右子树的，可以对右子树递归调用 <code>insertIntoMaxTree</code> 插入进去。</p><p>但是一种特殊情况是 <code>val</code> 比原始数组中的所有元素都大，那么根据构建最大二叉树的逻辑，原来的这棵树应该成为 <code>val</code> 节点的左子树。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-26"><a href="#解法代码-26" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertIntoMaxTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>            <span class="token comment"># 如果 val 是整棵树最大的，那么原来的这棵树应该是 val 节点的左子树，</span>            <span class="token comment"># 因为 val 节点是接在原始数组 a 的最后一个元素</span>            temp <span class="token operator">=</span> root            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> temp        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果 val 不是最大的，那么就应该在右子树上，</span>            <span class="token comment"># 因为 val 节点是接在原始数组 a 的最后一个元素</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>insertIntoMaxTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-22"><a href="#可视化-22" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-binary-tree-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-binary-tree-ii" src="https://labuladong.online/algo-visualize/leetcode/maximum-binary-tree-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110. 删点成林"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#slug_delete-nodes-and-return-forest">1110. 删点成林</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1110. 删点成林</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/delete-nodes-and-return-forest/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/delete-nodes-and-return-forest/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，树上每个节点都有一个不同的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果节点值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">to_delete</code>&nbsp;中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回森林中的每棵树。你可以按任意顺序组织答案。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png" style="max-width: 100%; height: 150px; width: 237px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6,7], to_delete = [3,5]<strong style="font-weight: 600;">输出：</strong>[[1,2,null,4],[6],[7]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,4,null,3], to_delete = [3]<strong style="font-weight: 600;">输出：</strong>[[1,2,4]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数最大为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code>。</li><li>每个节点都有一个介于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code>&nbsp;之间的值，且各不相同。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">to_delete.length &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">to_delete</code><span>&nbsp;</span>包含一些从&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code>、各不相同的值。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/delete-nodes-and-return-forest/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1110. 删点成林</a>。</strong></details><h3 id="基本思路-28"><a href="#基本思路-28" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>首先，如果在递归过程中修改二叉树结构，必须要让父节点接收递归函数的返回值，因为子树不管删成啥样，都要接到父节点上。</p><p>而且，<a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说了可以通过函数参数传递父节点传递的数据，所以可以在前序位置判断是否得到了一个新的根节点。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/">【练习】用「分解问题」思维解题 I</a></li></ul><h3 id="解法代码-27"><a href="#解法代码-27" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>delSet <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 记录森林的根节点</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">delNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> to_delete<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> d <span class="token keyword">in</span> to_delete<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>delSet<span class="token punctuation">.</span>add<span class="token punctuation">(</span>d<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>doDelete<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 定义：输入一棵二叉树，删除 delSet 中的节点，返回删除完成后的根节点</span>    <span class="token keyword">def</span> <span class="token function">doDelete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> hasParent<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 判断是否需要被删除</span>        deleted <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token keyword">in</span> self<span class="token punctuation">.</span>delSet        <span class="token keyword">if</span> <span class="token keyword">not</span> deleted <span class="token keyword">and</span> <span class="token keyword">not</span> hasParent<span class="token punctuation">:</span>            <span class="token comment"># 没有父节点且不需要被删除，就是一个新的根节点</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 去左右子树进行删除</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>doDelete<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token keyword">not</span> deleted<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>doDelete<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token keyword">not</span> deleted<span class="token punctuation">)</span>        <span class="token comment"># 如果需要被删除，返回 null 给父节点</span>        <span class="token keyword">return</span> <span class="token boolean">None</span> <span class="token keyword">if</span> deleted <span class="token keyword">else</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-23"><a href="#可视化-23" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_delete-nodes-and-return-forest" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_delete-nodes-and-return-forest" src="https://labuladong.online/algo-visualize/leetcode/delete-nodes-and-return-forest/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="技巧一"><a href="#技巧一" class="headerlink" title="技巧一"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E6%8A%80%E5%B7%A7%E4%B8%80">技巧一</a></h2><p>类似于判断镜像二叉树、翻转二叉树的问题，一般也可以用分解问题的思路，无非就是把整棵树的问题（原问题）分解成子树之间的问题（子问题）。</p><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#slug_same-tree">100. 相同的树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">100. 相同的树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/same-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/same-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你两棵二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">p</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">q</code><span>&nbsp;</span>，编写一个函数来检验这两棵树是否相同。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/20/ex1.jpg" style="max-width: 100%; width: 622px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>p = [1,2,3], q = [1,2,3]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/20/ex2.jpg" style="max-width: 100%; width: 382px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>p = [1,2], q = [1,null,2]<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/20/ex3.jpg" style="max-width: 100%; width: 622px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>p = [1,2,1], q = [1,1,2]<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>两棵树上的节点数目都在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 100]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/same-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 100. 相同的树</a>。</strong></details><h3 id="基本思路-29"><a href="#基本思路-29" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维模式。</p><p>判断两棵树是否相同，可以分解为判断根节点是否相同，然后判断左右子树的节点是否都相同。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/">【练习】用「分解问题」思维解题 II</a></li></ul><h3 id="解法代码-28"><a href="#解法代码-28" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入两个根节点，返回以它们为根的两棵二叉树是否相同</span>    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 判断一对节点是否相同</span>        <span class="token keyword">if</span> p <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> q <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> p <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> q <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">!=</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 判断其他节点是否相同</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-24"><a href="#可视化-24" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_same-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_same-tree" src="https://labuladong.online/algo-visualize/leetcode/same-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/subtree-of-another-tree">572. 另一棵树的子树 🟢</a></li></ul><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#slug_symmetric-tree">101. 对称二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">101. 对称二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/symmetric-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/symmetric-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>， 检查它是否轴对称。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/1698026966-JDYPDU-image.png" style="max-width: 100%; width: 354px; height: 291px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,2,3,4,4,3]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/1698027008-nPFLbM-image.png" style="max-width: 100%; width: 308px; height: 258px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,2,null,3,null,3]<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/symmetric-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 101. 对称二叉树</a>。</strong></details><h3 id="基本思路-30"><a href="#基本思路-30" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维模式。</p><p>这道题有点像 <a href="https://leetcode.cn/problems/same-tree">100.相同的树</a>，你可以对比一下两道题的代码，<strong>只不过本题不是让你比较两棵树是否相同，而是让你比较两棵子树是否对称</strong>。</p><p>那么分解问题的思路就很明显了，判断两棵树是否镜像对称，只要判断两棵子树都是镜像对称的就行了。</p><p>如果用迭代的方式，可以使用 BFS 层序遍历，把每一层的节点求出来，然后用左右双指针判断每一层是否是对称的。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/">【练习】用「分解问题」思维解题 II</a></li></ul><h3 id="解法代码-29"><a href="#解法代码-29" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment"># 检查两棵子树是否对称</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>check<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 定义：判断输入的两棵树是否是镜像对称的</span>    <span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> left<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> right<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> left <span class="token operator">==</span> right        <span class="token comment"># 两个根节点需要相同</span>        <span class="token keyword">if</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 左右子树也需要镜像对称</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>check<span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>check<span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-25"><a href="#可视化-25" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_symmetric-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_symmetric-tree" src="https://labuladong.online/algo-visualize/leetcode/symmetric-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof">剑指 Offer 28. 对称的二叉树 🟢</a></li></ul><h2 id="951-翻转等价二叉树"><a href="#951-翻转等价二叉树" class="headerlink" title="951. 翻转等价二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#slug_flip-equivalent-binary-trees">951. 翻转等价二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">951. 翻转等价二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/flip-equivalent-binary-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/flip-equivalent-binary-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">我们可以为二叉树<span>&nbsp;</span><strong style="font-weight: 600;">T</strong><span>&nbsp;</span>定义一个&nbsp;<strong style="font-weight: 600;">翻转操作&nbsp;</strong>，如下所示：选择任意节点，然后交换它的左子树和右子树。</p><p style="line-height: 1.6; overflow-wrap: break-word;">只要经过一定次数的翻转操作后，能使<span>&nbsp;</span><strong style="font-weight: 600;">X</strong><span>&nbsp;</span>等于<span>&nbsp;</span><strong style="font-weight: 600;">Y</strong>，我们就称二叉树<span>&nbsp;</span><strong style="font-weight: 600;">X</strong><span>&nbsp;</span><em>翻转 等价&nbsp;</em>于二叉树<span>&nbsp;</span><strong style="font-weight: 600;">Y</strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">这些树由根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root2</code>&nbsp;给出。如果两个二叉树是否是<em>翻转 等价&nbsp;</em>的函数，则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="Flipped Trees Diagram" src="https://labuladong.online/algo/images/lc/uploads/2018/11/29/tree_ex.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>我们翻转值为 1，3 以及 5 的三个节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root1 = [], root2 = []<strong style="font-weight: 600;">输出:</strong> true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root1 = [], root2 = [1]<strong style="font-weight: 600;">输出:</strong> false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>每棵树节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 100]</code><span>&nbsp;</span>范围内</li><li>每棵树中的每个值都是唯一的、在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 99]</code>&nbsp;范围内的整数</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/flip-equivalent-binary-trees/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 951. 翻转等价二叉树</a>。</strong></details><h3 id="基本思路-31"><a href="#基本思路-31" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>如何分解这个问题呢？原问题是两棵二叉树是否是翻转等价的，只要两棵树的根节点能够匹配，那我们就可以去考察这两个根节点的左右子树（共四棵）是否是翻转等价的。</p><p>对子树把翻转和不翻转两种情况全都穷举一遍，只要有一种情况能够匹配，就说明整棵树是翻转等价的，具体实现见代码。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/">【练习】用「分解问题」思维解题 II</a></li></ul><h3 id="解法代码-30"><a href="#解法代码-30" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入两棵二叉树，判断这两棵二叉树是否是翻转等价的</span>    <span class="token keyword">def</span> <span class="token function">flipEquiv</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 判断 root1 和 root2 两个节点是否能够匹配</span>        <span class="token keyword">if</span> root1 <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root2 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> root1 <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> root2 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> root1<span class="token punctuation">.</span>val <span class="token operator">!=</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 根据函数定义，判断子树是否能够匹配</span>        <span class="token comment"># 不翻转、翻转两种情况满足一种即可算是匹配</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>                <span class="token comment"># 不翻转子树</span>                self<span class="token punctuation">.</span>flipEquiv<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>flipEquiv<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>                <span class="token comment"># 反转子树</span>                self<span class="token punctuation">.</span>flipEquiv<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>flipEquiv<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-26"><a href="#可视化-26" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_flip-equivalent-binary-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_flip-equivalent-binary-trees" src="https://labuladong.online/algo-visualize/leetcode/flip-equivalent-binary-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="技巧二"><a href="#技巧二" class="headerlink" title="技巧二"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E6%8A%80%E5%B7%A7%E4%BA%8C">技巧二</a></h2><p>一般来说，遍历的思维模式可以帮你寻找<strong>从根节点开始的</strong>符合条件的「树枝」，但在不限制起点必须是根节点的条件下，让你寻找符合条件的「树枝」，就需要用到分解问题的思维模式了。</p><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#slug_binary-tree-maximum-path-sum">124. 二叉树中的最大路径和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">124. 二叉树中的最大路径和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">二叉树中的<strong style="font-weight: 600;"><span>&nbsp;</span>路径</strong><span>&nbsp;</span>被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中<span>&nbsp;</span><strong style="font-weight: 600;">至多出现一次</strong><span>&nbsp;</span>。该路径<strong style="font-weight: 600;"><span>&nbsp;</span>至少包含一个<span>&nbsp;</span></strong>节点，且不一定经过根节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">路径和</strong><span>&nbsp;</span>是路径中各节点值的总和。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，返回其<span>&nbsp;</span><strong style="font-weight: 600;">最大路径和</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/13/exx1.jpg" style="max-width: 100%; width: 322px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3]<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/13/exx2.jpg" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [-10,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>42<strong style="font-weight: 600;">解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 3 * 10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 124. 二叉树中的最大路径和</a>。</strong></details><h3 id="基本思路-32"><a href="#基本思路-32" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>这题需要巧用二叉树的后序遍历，可以先去做一下 <a href="https://leetcode.cn/problems/diameter-of-binary-tree">543. 二叉树的直径</a> 和 <a href="https://leetcode.cn/problems/find-leaves-of-binary-tree">366. 寻找二叉树的叶子节点</a>。</p><p><code>oneSideMax</code> 函数和上述几道题中都用到的 <code>maxDepth</code> 函数非常类似，只不过 <code>maxDepth</code> 计算最大深度，<code>oneSideMax</code> 计算「单边」最大路径和：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/124.png" alt="img"></p><p>然后在后序遍历的时候顺便计算题目要求的最大路径和。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/">【练习】用「分解问题」思维解题 II</a></li></ul><h3 id="解法代码-31"><a href="#解法代码-31" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 计算单边路径和时顺便计算最大路径和</span>        self<span class="token punctuation">.</span>oneSideMax<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 定义：计算从根节点 root 为起点的最大单边路径和</span>    <span class="token keyword">def</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left_max_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>oneSideMax<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        right_max_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>oneSideMax<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置，顺便更新最大路径和</span>        path_max_sum <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> left_max_sum <span class="token operator">+</span> right_max_sum        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> path_max_sum<span class="token punctuation">)</span>        <span class="token comment"># 实现函数定义，左右子树的最大单边路径和加上根节点的值</span>        <span class="token comment"># 就是从根节点 root 为起点的最大单边路径和</span>        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_max_sum<span class="token punctuation">,</span> right_max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-27"><a href="#可视化-27" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-divide-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-maximum-path-sum" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-maximum-path-sum" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-maximum-path-sum/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/jC7MId">剑指 Offer II 051. 节点之和最大的路径 🔴</a></li></ul><h1 id="【练习】同时运用两种思维解题"><a href="#【练习】同时运用两种思维解题" class="headerlink" title="【练习】同时运用两种思维解题"></a>【练习】同时运用两种思维解题</h1><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_maximum-depth-of-n-ary-tree">559. N 叉树的最大深度</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">559. N 叉树的最大深度</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个 N 叉树，找到其最大深度。</p><p class="MachineTrans-lang-zh-CN" style="line-height: 1.6; overflow-wrap: break-word;">最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p class="MachineTrans-lang-zh-CN" style="line-height: 1.6; overflow-wrap: break-word;">N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p class="MachineTrans-lang-zh-CN" style="line-height: 1.6; overflow-wrap: break-word;"></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2018/10/12/narytreeexample.png" style="max-width: 300px; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,3,2,4,null,5,6]<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/11/08/sample_4_964.png" style="max-width: 100%; width: 296px; height: 241px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<strong style="font-weight: 600;">输出：</strong>5</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树的深度不会超过<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code><span>&nbsp;</span>。</li><li>树的节点数目位于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 10<sup>4</sup>]</code><span>&nbsp;</span>之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 559. N 叉树的最大深度</a>。</strong></details><h3 id="基本思路-33"><a href="#基本思路-33" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时使用两种思维模式，我把两种解法都写一下。</p><p>可以对照 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a> 题的解法。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-32"><a href="#解法代码-32" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 分解问题的思路</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        subTreeMaxDepth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            subTreeMaxDepth <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>subTreeMaxDepth<span class="token punctuation">,</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> subTreeMaxDepth<span class="token comment"># 遍历的思路</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录递归遍历到的深度</span>        self<span class="token punctuation">.</span>depth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 记录最大的深度</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">+=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> self<span class="token punctuation">.</span>depth<span class="token punctuation">)</span>        <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>child<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>depth <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-28"><a href="#可视化-28" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-depth-of-n-ary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-depth-of-n-ary-tree" src="https://labuladong.online/algo-visualize/leetcode/maximum-depth-of-n-ary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_path-sum">112. 路径总和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">112. 路径总和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/path-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/path-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>和一个表示目标和的整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">targetSum</code><span>&nbsp;</span>。判断该树中是否存在<span>&nbsp;</span><strong style="font-weight: 600;">根节点到叶子节点</strong><span>&nbsp;</span>的路径，这条路径上所有节点值相加等于目标和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">targetSum</code><span>&nbsp;</span>。如果存在，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶子节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/pathsum1.jpg" style="max-width: 100%; width: 500px; height: 356px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>等于目标和的根节点到叶节点路径如上图所示。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/pathsum2.jpg" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], targetSum = 5<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [], targetSum = 0<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>由于树是空的，所以不存在根节点到叶子节点的路径。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 5000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= targetSum &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/path-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 112. 路径总和</a>。</strong></details><h3 id="基本思路-34"><a href="#基本思路-34" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/algorithm-summary/">我的刷题经验总结</a> 说过，二叉树的遍历代码是动态规划和回溯算法的祖宗。</p><p><a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划</a> 的关键在于明确递归函数的定义，把用子问题的结果推导出大问题的结果。</p><p><a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法</a> 就简单粗暴多了，就是单纯的遍历回溯树。</p><p>下面给出两种思路下的解法，请仔细体会。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-33"><a href="#解法代码-33" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 解法一、分解问题的思路</span>    <span class="token comment"># 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径</span>    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># root.left == root.right 等同于 root.left == null &amp;&amp; root.right == null</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> root<span class="token punctuation">.</span>right <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> targetSum<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>hasPathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>hasPathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token comment"># 解法二、遍历二叉树的思路</span>    <span class="token comment"># 记录遍历过程中的路径和</span>    <span class="token keyword">def</span> <span class="token function">hasPathSum_2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>target <span class="token operator">=</span> targetSum        self<span class="token punctuation">.</span>found <span class="token operator">=</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>curSum <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>found    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置</span>        self<span class="token punctuation">.</span>curSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>curSum <span class="token operator">==</span> self<span class="token punctuation">.</span>target<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>found <span class="token operator">=</span> <span class="token boolean">True</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        self<span class="token punctuation">.</span>curSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-29"><a href="#可视化-29" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_path-sum" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_path-sum" src="https://labuladong.online/algo-visualize/leetcode/path-sum/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_path-sum-ii">113. 路径总和 II</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">113. 路径总和 II</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/path-sum-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/path-sum-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>和一个整数目标和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">targetSum</code><span>&nbsp;</span>，找出所有<span>&nbsp;</span><strong style="font-weight: 600;">从根节点到叶子节点</strong><span>&nbsp;</span>路径总和等于给定目标和的路径。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶子节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/pathsumii1.jpg" style="max-width: 100%; width: 500px; height: 356px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<strong style="font-weight: 600;">输出：</strong>[[5,4,11,2],[5,8,4,5]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/pathsum2.jpg" style="max-width: 100%; width: 212px; height: 181px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], targetSum = 5<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2], targetSum = 0<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点总数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 5000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= targetSum &lt;= 1000</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/path-sum-ii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 113. 路径总和 II</a>。</strong></details><h3 id="基本思路-35"><a href="#基本思路-35" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时运用两种思维。</p><p>遍历的思维很简单，只要遍历一遍二叉树，就可以把所有符合条件的路径找出来。为了维护经过的路径，在进入递归的时候要在 <code>path</code> 列表添加节点，结束递归的时候删除节点，类似 <a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法</a>。</p><p>分解问题的思路也不难，你计算以 <code>root</code> 为根的二叉树中和为 <code>sum</code> 的路径，不就可以分解成计算以 <code>root.left, root.right</code> 为根的二叉树中所有和为 <code>sum - root.val</code> 的路径，然后再加上 <code>root</code> 节点吗？</p><p>我这里同时写出了遍历思路和分解问题思路的解法，供大家参考。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-34"><a href="#解法代码-34" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token punctuation">,</span> Optional<span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">,</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 遍历二叉树</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> path<span class="token punctuation">:</span> deque<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        remain <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">-</span> root<span class="token punctuation">.</span>val        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> remain <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment"># 找到一条路径</span>                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span>                path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment"># 维护路径列表</span>        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> remain<span class="token punctuation">,</span> path<span class="token punctuation">)</span>        path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> remain<span class="token punctuation">,</span> path<span class="token punctuation">)</span>        path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 分解问题的思维模式</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res                <span class="token comment"># 如果是叶子节点并且值等于 targetSum，则找到一条路径</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> targetSum<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token comment"># 分别递归左右子树，找到子树中和为 targetSum - root.val 的路径</span>        left_answers <span class="token operator">=</span> self<span class="token punctuation">.</span>pathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        right_answers <span class="token operator">=</span> self<span class="token punctuation">.</span>pathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 左右子树的路径加上根节点，就是和为 targetSum 的路径</span>        <span class="token keyword">for</span> answer <span class="token keyword">in</span> left_answers<span class="token punctuation">:</span>            <span class="token comment"># 因为底层使用的是 LinkedList，所以这个操作的复杂度是 O(1)</span>            answer<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>answer<span class="token punctuation">)</span>                <span class="token keyword">for</span> answer <span class="token keyword">in</span> right_answers<span class="token punctuation">:</span>            <span class="token comment"># 因为底层使用的是 LinkedList，所以这个操作的复杂度是 O(1)</span>            answer<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>answer<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-30"><a href="#可视化-30" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_path-sum-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_path-sum-ii" src="https://labuladong.online/algo-visualize/leetcode/path-sum-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">1430. 判断给定的序列是否是二叉树从根到叶的路径 🟠</a></li><li><a href="https://leetcode.cn/problems/path-sum-iv">666. 路径总和 IV 🟠</a></li><li><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">剑指 Offer 34. 二叉树中和为某一值的路径 🟠</a></li></ul><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_merge-two-binary-trees">617. 合并二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">617. 合并二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/merge-two-binary-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/merge-two-binary-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你两棵二叉树：<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root2</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong style="font-weight: 600;">不为</strong><span>&nbsp;</span>null 的节点将直接作为新二叉树的节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回合并后的二叉树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意:</strong><span>&nbsp;</span>合并过程必须从两个树的根节点开始。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/05/merge.jpg" style="max-width: 100%; height: 163px; width: 600px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<strong style="font-weight: 600;">输出：</strong>[3,4,5,5,4,null,7]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [1], root2 = [1,2]<strong style="font-weight: 600;">输出：</strong>[2,2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>两棵树中的节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 2000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/merge-two-binary-trees/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 617. 合并二叉树</a>。</strong></details><h3 id="基本思路-36"><a href="#基本思路-36" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时用到两种思维模式。</p><p>虽然输入的是两棵树的根节点，但它们的操作是同步的，所以可以看做是在遍历 <code>root1</code> 这一棵二叉树，顺便把 <code>root2</code> 的节点合并过来。下面我给出两种思维模式的解法代码，具体看注释吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-35"><a href="#解法代码-35" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 分解问题的思维模式</span>    <span class="token comment"># 定义：输入两棵树的根节点，返回合并后的树的根节点</span>    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># 如果一棵树非空，那么合并后就是另一棵树</span>        <span class="token keyword">if</span> root1 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root2        <span class="token keyword">if</span> root2 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root1        <span class="token comment"># 两棵树都有的节点，叠加节点值</span>        root1<span class="token punctuation">.</span>val <span class="token operator">+=</span> root2<span class="token punctuation">.</span>val        <span class="token comment"># 利用函数定义，子树合并后接到</span>        root1<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        root1<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root1<span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token comment"># 遍历的思维模式</span>    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root1 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root2        <span class="token comment"># 遍历 root1，顺便把 root2 的节点合并过来</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root1<span class="token punctuation">,</span> root2<span class="token punctuation">)</span>        <span class="token keyword">return</span> root1    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root1 <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> root2 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root1 <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root2 <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 两棵树都有的节点，叠加节点值</span>            root1<span class="token punctuation">.</span>val <span class="token operator">+=</span> root2<span class="token punctuation">.</span>val        <span class="token comment"># 如果 root1 没有子树而 root2 有，那么就把 root2 的子树接到 root1 上</span>        <span class="token comment"># 注意接完之后把 root2 的子树置为 null，免得错误计算节点累加值</span>        <span class="token keyword">if</span> root1<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root2<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            root1<span class="token punctuation">.</span>left <span class="token operator">=</span> root2<span class="token punctuation">.</span>left            root2<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> root1<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root2<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            root1<span class="token punctuation">.</span>right <span class="token operator">=</span> root2<span class="token punctuation">.</span>right            root2<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token comment"># 递归遍历左右子节点，root2 的节点也跟着同步移动</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-31"><a href="#可视化-31" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_merge-two-binary-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_merge-two-binary-trees" src="https://labuladong.online/algo-visualize/leetcode/merge-two-binary-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="897-递增顺序搜索树"><a href="#897-递增顺序搜索树" class="headerlink" title="897. 递增顺序搜索树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_increasing-order-search-tree">897. 递增顺序搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">897. 递增顺序搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/increasing-order-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/increasing-order-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉搜索树的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，请你<span>&nbsp;</span><strong style="font-weight: 600;">按中序遍历</strong><span>&nbsp;</span>将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/11/17/ex1.jpg" style="max-width: 100%; height: 350px; width: 600px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]<strong style="font-weight: 600;">输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/11/17/ex2.jpg" style="max-width: 100%; height: 114px; width: 300px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,1,7]<strong style="font-weight: 600;">输出：</strong>[1,null,5,null,7]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数的取值范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/increasing-order-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 897. 递增顺序搜索树</a>。</strong></details><h3 id="基本思路-37"><a href="#基本思路-37" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时用到两种思维模式。</p><p>「遍历」的话很简单，你对 BST 做中序遍历，其结果就是有序的，重新构造出题目要求的这个类似链表的二叉树即可。</p><p>「分解问题」的思路也不难，你只要做过 <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list">114. 二叉树展开为链表</a> 这道题，稍微改下解法就可以解决这道题了，明确 <code>increasingBST</code> 的定义，然后利用这个定义进行操作即可。</p><p>这里我给出分解问题的解法思路。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-36"><a href="#解法代码-36" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入一棵 BST，返回一个有序「链表」</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">increasingBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 先把左右子树拉平</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>increasingBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>increasingBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> right        <span class="token comment"># 左子树为空的话，就不用处理了</span>        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token comment"># 左子树非空，需要把根节点和右子树接到左子树末尾</span>        p <span class="token operator">=</span> left        <span class="token keyword">while</span> p <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> p<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right        p<span class="token punctuation">.</span>right <span class="token operator">=</span> root        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-32"><a href="#可视化-32" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_increasing-order-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_increasing-order-search-tree" src="https://labuladong.online/algo-visualize/leetcode/increasing-order-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/NYBBNL">剑指 Offer II 052. 展平二叉搜索树 🟢</a></li></ul><h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_range-sum-of-bst">938. 二叉搜索树的范围和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">938. 二叉搜索树的范围和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/range-sum-of-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/range-sum-of-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉搜索树的根结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，返回值位于范围<span>&nbsp;</span><em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[low, high]</code></em><span>&nbsp;</span>之间的所有结点的值的和。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/11/05/bst1.jpg" style="max-width: 100%; width: 400px; height: 222px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [10,5,15,3,7,null,18], low = 7, high = 15<strong style="font-weight: 600;">输出：</strong>32</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/11/05/bst2.jpg" style="max-width: 100%; width: 400px; height: 335px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10<strong style="font-weight: 600;">输出：</strong>23</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2 * 10<sup>4</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li><li>所有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code><span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/range-sum-of-bst/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 938. 二叉搜索树的范围和</a>。</strong></details><h3 id="基本思路-38"><a href="#基本思路-38" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时使用这两种思维模式。</p><p>遍历的思路就是单纯用 <code>traverse</code> 函数遍历一遍 BST，找到落在区间的元素。分解问题的思路关键是要明确函数定义，然后利用这个定义。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-37"><a href="#解法代码-37" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 遍历的思路</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">rangeSumBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 遍历一遍 BST 计算区间元素和</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">:</span>            <span class="token comment"># 目标区间在右子树</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> high<span class="token punctuation">:</span>            <span class="token comment"># 目标区间在左子树</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># root.val 落在目标区间，累加 sum</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>val            <span class="token comment"># 继续遍历左右子树</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token comment"># 分解问题的思路</span>    <span class="token comment"># 定义：输入一个 BST，计算值落在 [low, high] 之间的元素之和</span>    <span class="token keyword">def</span> <span class="token function">rangeSumBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">:</span>            <span class="token comment"># 目标区间在右子树</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>rangeSumBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> high<span class="token punctuation">:</span>            <span class="token comment"># 目标区间在左子树</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>rangeSumBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 以 root 为根的这棵 BST 落在 [low, high] 之间的元素之和，</span>            <span class="token comment"># 等于 root.val 加上左右子树落在区间的元素之和</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> self<span class="token punctuation">.</span>rangeSumBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>rangeSumBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-33"><a href="#可视化-33" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_range-sum-of-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_range-sum-of-bst" src="https://labuladong.online/algo-visualize/leetcode/range-sum-of-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1379-找出克隆二叉树中的相同节点"><a href="#1379-找出克隆二叉树中的相同节点" class="headerlink" title="1379. 找出克隆二叉树中的相同节点"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#slug_find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree">1379. 找出克隆二叉树中的相同节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1379. 找出克隆二叉树中的相同节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你两棵二叉树，原始树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">original</code><span>&nbsp;</span>和克隆树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cloned</code>，以及一个位于原始树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">original</code>&nbsp;中的目标节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">其中，克隆树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cloned</code>&nbsp;是原始树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">original</code>&nbsp;的一个<strong style="font-weight: 600;"><span>&nbsp;</span>副本<span>&nbsp;</span></strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请找出在树&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cloned</code>&nbsp;中，与&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;<strong style="font-weight: 600;">相同&nbsp;</strong>的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong>你<span>&nbsp;</span><strong style="font-weight: 600;">不能</strong><span>&nbsp;</span>对两棵二叉树，以及<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;节点进行更改。<strong style="font-weight: 600;">只能</strong><span>&nbsp;</span>返回对克隆树&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cloned</code>&nbsp;中已有的节点的引用。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ul><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/02/21/e1.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> tree = [7,4,3,null,null,6,19], target = 3<strong style="font-weight: 600;">输出:</strong> 3<strong style="font-weight: 600;">解释:</strong> 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/02/21/e2.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> tree = [7], target =  7<strong style="font-weight: 600;">输出:</strong> 7</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/02/21/e3.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4<strong style="font-weight: 600;">输出:</strong> 4</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数量范围为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>&nbsp;。</li><li>同一棵树中，没有值相同的节点。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;节点是树&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">original</code>&nbsp;中的一个节点，并且不会是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">null</code>&nbsp;。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>如果树中允许出现值相同的节点，将如何解答？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1379. 找出克隆二叉树中的相同节点</a>。</strong></details><h3 id="基本思路-39"><a href="#基本思路-39" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题可以同时用到两种思维。</p><p>说白了，这道题就是让你从一棵二叉树中搜索一个目标节点，考虑到题目的 follow up 问你节点的值存在重复的情况，所以用对比节点引用的方式进行比较。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/">【练习】同时运用两种思维解题</a></li></ul><h3 id="解法代码-38"><a href="#解法代码-38" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 遍历的思路</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：找到 original 中 target 节点在 cloned 树中对应的节点</span>    <span class="token keyword">def</span> <span class="token function">getTargetCopy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> original<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> cloned<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>target <span class="token operator">=</span> target        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>original<span class="token punctuation">,</span> cloned<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> original<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> cloned<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> original <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>res <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> original <span class="token operator">==</span> self<span class="token punctuation">.</span>target<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>res <span class="token operator">=</span> cloned            <span class="token keyword">return</span>        <span class="token comment"># 二叉树遍历框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>original<span class="token punctuation">.</span>left<span class="token punctuation">,</span> cloned<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>original<span class="token punctuation">.</span>right<span class="token punctuation">,</span> cloned<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment"># 分解问题的思路</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：找到 original 中 target 节点在 cloned 树中对应的节点</span>    <span class="token keyword">def</span> <span class="token function">getTargetCopy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> original<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> cloned<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> original <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 找到目标节点</span>        <span class="token keyword">if</span> target <span class="token operator">==</span> original<span class="token punctuation">:</span>            <span class="token keyword">return</span> cloned        <span class="token comment"># 去左子树找</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>getTargetCopy<span class="token punctuation">(</span>original<span class="token punctuation">.</span>left<span class="token punctuation">,</span> cloned<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> left        <span class="token comment"># 左子树找不到的话去右子树找</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>getTargetCopy<span class="token punctuation">(</span>original<span class="token punctuation">.</span>right<span class="token punctuation">,</span> cloned<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-34"><a href="#可视化-34" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-combine-two-view/#%E5%8F%AF%E8%A7%86%E5%8C%96-6">可视化</a></h3><details data-v-ee1a9bd0="" id="div_find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree" src="https://labuladong.online/algo-visualize/leetcode/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h1 id="【练习】利用后序位置解题-I"><a href="#【练习】利用后序位置解题-I" class="headerlink" title="【练习】利用后序位置解题 I"></a>【练习】利用后序位置解题 I</h1><p>有些题目，你按照拍脑袋的方式去做，可能发现需要在递归代码中调用其他递归函数计算字数的信息。一般来说，出现这种情况时你可以考虑用后序遍历的思维方式来优化算法，利用后序遍历传递子树的信息，避免过高的时间复杂度。</p><p>像求和、求高度这种基本的二叉树函数很容易写，有时候只要在它们的后序位置添加一点代码，就能得到我们想要的答案。</p><hr><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#slug_balanced-binary-tree">110. 平衡二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">110. 平衡二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/balanced-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/balanced-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树，判断它是否是<span>&nbsp;</span><span data-keyword="height-balanced">平衡二叉树</span><span>&nbsp;</span>&nbsp;</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/06/balance_1.jpg" style="max-width: 100%; width: 342px; height: 221px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/06/balance_2.jpg" style="max-width: 100%; width: 452px; height: 301px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,2,3,3,null,null,4,4]<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = []<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 5000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/balanced-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 110. 平衡二叉树</a>。</strong></details><h3 id="基本思路-40"><a href="#基本思路-40" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这里要用到前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过的后序位置的妙用。</p><p>一般的拍脑袋思路是，遍历二叉树，然后对每一个节点计算左右的最大高度。</p><p>但是计算一棵二叉树的最大深度也需要递归遍历这棵树的所有节点，如果对每个节点都算一遍最大深度，时间复杂度是比较高的。</p><p>所以最好的解法是反过来思考，只计算一次最大深度，计算的过程中在后序遍历位置顺便判断二叉树是否平衡：</p><p>对于每个节点，先算出来左右子树的最大高度，然后在后序遍历的位置根据左右子树的最大高度判断平衡性。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/">【练习】利用后序位置解题 I</a></li></ul><h3 id="解法代码-39"><a href="#解法代码-39" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录二叉树是否平衡</span>        self<span class="token punctuation">.</span>balanced <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>balanced    <span class="token comment"># 输入一个节点，返回以该节点为根的二叉树的最大深度</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># if not self.balanced:</span>        <span class="token comment"># 随便返回一个值即可，旨在结束递归</span>        <span class="token comment">#     return -666</span>        leftMaxDepth <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightMaxDepth <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置</span>        <span class="token comment"># 如果左右最大深度大于 1，就不是平衡二叉树</span>        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>rightMaxDepth <span class="token operator">-</span> leftMaxDepth<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>balanced <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token builtin">max</span><span class="token punctuation">(</span>leftMaxDepth<span class="token punctuation">,</span> rightMaxDepth<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-35"><a href="#可视化-35" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_balanced-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_balanced-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/balanced-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/count-univalue-subtrees">250. 统计同值子树 🟠</a></li><li><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof">剑指 Offer 55 - II. 平衡二叉树 🟢</a></li></ul><h2 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508. 出现次数最多的子树元素和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#slug_most-frequent-subtree-sum">508. 出现次数最多的子树元素和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">508. 出现次数最多的子树元素和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/most-frequent-subtree-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/most-frequent-subtree-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根结点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一个结点的&nbsp;<strong style="font-weight: 600;">「子树元素和」</strong>&nbsp;定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/04/24/freq1-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [5,2,-3]<strong style="font-weight: 600;">输出:</strong> [2,-3,4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/04/24/freq2-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [5,2,-5]<b>输出:</b> [2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/most-frequent-subtree-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 508. 出现次数最多的子树元素和</a>。</strong></details><h3 id="基本思路-41"><a href="#基本思路-41" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维，同时要利用后序位置来计算答案。</p><p><code>sum</code> 函数根据子树的元素和推导出原树的所有元素和，只不过在后序遍历位置添加一些统计工作，便于找出出现频率最高的子树和。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/">【练习】利用后序位置解题 I</a></li></ul><h3 id="解法代码-40"><a href="#解法代码-40" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># sum -> count</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sum_to_count <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">findFrequentTreeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># traverse the binary tree and record all subtree sums and their frequencies</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># find the highest frequency</span>        max_count <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>sum_to_count<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># find the subtree sums that have the highest frequency</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span>key <span class="token keyword">for</span> key<span class="token punctuation">,</span> count <span class="token keyword">in</span> self<span class="token punctuation">.</span>sum_to_count<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> count <span class="token operator">==</span> max_count<span class="token punctuation">]</span>        <span class="token comment"># convert to a python list</span>        <span class="token keyword">return</span> res    <span class="token comment"># definition: given a node, return the sum of all nodes in the subtree rooted at that node</span>    <span class="token keyword">def</span> <span class="token function">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left_sum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right_sum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        res <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> left_sum <span class="token operator">+</span> right_sum        <span class="token comment"># postorder traversal position, record the frequency of the subtree sum</span>        self<span class="token punctuation">.</span>sum_to_count<span class="token punctuation">[</span>res<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>sum_to_count<span class="token punctuation">.</span>get<span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-36"><a href="#可视化-36" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_most-frequent-subtree-sum" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_most-frequent-subtree-sum" src="https://labuladong.online/algo-visualize/leetcode/most-frequent-subtree-sum/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#slug_binary-tree-tilt">563. 二叉树的坡度</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">563. 二叉树的坡度</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-tilt/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-tilt/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，计算并返回<span>&nbsp;</span><strong style="font-weight: 600;">整个树<span>&nbsp;</span></strong>的坡度 。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一个树的<strong style="font-weight: 600;"><span>&nbsp;</span>节点的坡度<span>&nbsp;</span></strong>定义即为，该节点左子树的节点之和和右子树节点之和的<span>&nbsp;</span><strong style="font-weight: 600;">差的绝对值<span>&nbsp;</span></strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">整个树</strong><span>&nbsp;</span>的坡度就是其所有节点的坡度之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/20/tilt1.jpg" style="max-width: 100%; width: 712px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3]<strong style="font-weight: 600;">输出：</strong>1<strong style="font-weight: 600;">解释：</strong>节点 2 的坡度：|0-0| = 0（没有子节点）节点 3 的坡度：|0-0| = 0（没有子节点）节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）坡度总和：0 + 0 + 1 = 1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/20/tilt2.jpg" style="max-width: 100%; width: 800px; height: 203px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,2,9,3,5,null,7]<strong style="font-weight: 600;">输出：</strong>15<strong style="font-weight: 600;">解释：</strong>节点 3 的坡度：|0-0| = 0（没有子节点）节点 5 的坡度：|0-0| = 0（没有子节点）节点 7 的坡度：|0-0| = 0（没有子节点）节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/20/tilt3.jpg" style="max-width: 100%; width: 800px; height: 293px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [21,7,14,1,1,2,2,3,3]<strong style="font-weight: 600;">输出：</strong>9</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目的范围在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 10<sup>4</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-tilt/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 563. 二叉树的坡度</a>。</strong></details><h3 id="基本思路-42"><a href="#基本思路-42" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这里要用到前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过的后序位置的妙用。</p><p><code>sum</code> 函数记录二叉树的节点之和，在后序位置顺便计算二叉树的「坡度」即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/">【练习】利用后序位置解题 I</a></li></ul><h3 id="解法代码-41"><a href="#解法代码-41" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 定义：输入一棵二叉树，返回这棵二叉树所有元素的和</span>    <span class="token keyword">def</span> <span class="token function">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left_sum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right_sum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置</span>        self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_sum <span class="token operator">-</span> right_sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> left_sum <span class="token operator">+</span> right_sum <span class="token operator">+</span> root<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">findTilt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-37"><a href="#可视化-37" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-tilt" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-tilt" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-tilt/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="814-二叉树剪枝"><a href="#814-二叉树剪枝" class="headerlink" title="814. 二叉树剪枝"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#slug_binary-tree-pruning">814. 二叉树剪枝</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">814. 二叉树剪枝</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-pruning/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-pruning/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根结点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，此外树的每个结点的值要么是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>，要么是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回移除了所有不包含<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>的子树的原二叉树。</p><p style="line-height: 1.6; overflow-wrap: break-word;">节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code><span>&nbsp;</span>的子树为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code><span>&nbsp;</span>本身加上所有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code><span>&nbsp;</span>的后代。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/04/06/1028_2.png" style="max-width: 100%; width: 500px; height: 140px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,0,0,1]<strong style="font-weight: 600;">输出：</strong>[1,null,0,null,1]<strong style="font-weight: 600;">解释：</strong>只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/04/06/1028_1.png" style="max-width: 100%; width: 500px; height: 115px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,1,0,0,0,1]<strong style="font-weight: 600;">输出：</strong>[1,null,1,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/04/05/1028.png" style="max-width: 100%; width: 500px; height: 134px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,1,0,1,1,0,1,0]<strong style="font-weight: 600;">输出：</strong>[1,1,0,1,1,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 200]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code><span>&nbsp;</span>为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-pruning/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 814. 二叉树剪枝</a>。</strong></details><h3 id="基本思路-43"><a href="#基本思路-43" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>建议先做一下 <a href="https://leetcode.cn/problems/diameter-of-binary-tree">543. 二叉树的直径</a> 和 <a href="https://leetcode.cn/problems/longest-univalue-path">687. 最长同值路径</a>，理解后序遍历位置的特殊性。</p><p>这道题的难点在于要一直剪枝，直到没有值为 0 的叶子节点为止，只有从后序遍历位置自底向上处理才能获得最高的效率。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/">【练习】利用后序位置解题 I</a></li></ul><h3 id="解法代码-42"><a href="#解法代码-42" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入一棵二叉树，返回的二叉树叶子节点都是 1</span>    <span class="token keyword">def</span> <span class="token function">pruneTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 二叉树递归框架</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>pruneTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>pruneTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置，判断自己是否是值为 0 的叶子节点</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 返回值会被父节点接收，相当于把自己删掉了</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 如果不是，正常返回</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-38"><a href="#可视化-38" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-pruning" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-pruning" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-pruning/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/delete-leaves-with-a-given-value">1325. 删除给定值的叶子节点 🟠</a></li><li><a href="https://leetcode.cn/problems/pOCWxh">剑指 Offer II 047. 二叉树剪枝 🟠</a></li></ul><h2 id="1325-删除给定值的叶子节点"><a href="#1325-删除给定值的叶子节点" class="headerlink" title="1325. 删除给定值的叶子节点"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#slug_delete-leaves-with-a-given-value">1325. 删除给定值的叶子节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1325. 删除给定值的叶子节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/delete-leaves-with-a-given-value/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/delete-leaves-with-a-given-value/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵以&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;为根的二叉树和一个整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;，请你删除所有值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code><span>&nbsp;</span>的&nbsp;<strong style="font-weight: 600;">叶子节点</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">注意，一旦删除值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code><span>&nbsp;</span>，那么这个节点也应该被删除。</p><p style="line-height: 1.6; overflow-wrap: break-word;">也就是说，你需要重复此过程直到不能继续删除。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png" style="max-width: 100%; width: 500px; height: 112px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,2,null,2,4], target = 2<strong style="font-weight: 600;">输出：</strong>[1,null,3,null,4]<strong style="font-weight: 600;">解释：</strong>上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/01/16/sample_2_1684.png" style="max-width: 100%; width: 400px; height: 154px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,3,3,3,2], target = 3<strong style="font-weight: 600;">输出：</strong>[1,3,null,null,2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/01/16/sample_3_1684.png" style="max-width: 100%; width: 450px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,null,2,null,2], target = 2<strong style="font-weight: 600;">输出：</strong>[1]<strong style="font-weight: 600;">解释：</strong>每一步都删除一个绿色的叶子节点（值为 2）。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数量的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 3000]</code>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val, target &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/delete-leaves-with-a-given-value/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1325. 删除给定值的叶子节点</a>。</strong></details><h3 id="基本思路-44"><a href="#基本思路-44" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>删除指定值的叶子节点，其实就是遍历所有的叶子节点，然后判断是否需要删除；删除叶子节点也很简单，return null 让父节点接收即可。</p><p><strong>难点在于他这个删除操作是循环的，一直删到叶子结点不存在 <code>target</code> 为止</strong>。这里要用到前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过的后序位置的妙用了：</p><p>一个节点要在后序位置接收左右子树的返回值，才能知道自己的叶子节点是否都被删掉了，以此判断自己是不是变成了叶子节点。</p><p>这个考点在 <a href="https://leetcode.cn/problems/binary-tree-pruning">814. 二叉树剪枝</a> 中也有体现，没做过的读者建议去做一下，解法的关键点在于利用后序遍历特点，在后序遍历位置每个节点可以直到自己是否需要被删除。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/">【练习】利用后序位置解题 I</a></li></ul><h3 id="解法代码-43"><a href="#解法代码-43" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeLeafNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 二叉树递归框架</span>        <span class="token comment"># 如果左右子节点需要被删除，先递归删除它们</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>removeLeafNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>removeLeafNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置，此时节点 root 直到自己是否需要被删除</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> target <span class="token keyword">and</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-39"><a href="#可视化-39" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_delete-leaves-with-a-given-value" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_delete-leaves-with-a-given-value" src="https://labuladong.online/algo-visualize/leetcode/delete-leaves-with-a-given-value/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687. 最长同值路径"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_longest-univalue-path">687. 最长同值路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">687. 最长同值路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/longest-univalue-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/longest-univalue-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，返回&nbsp;<em>最长的路径的长度</em><span>&nbsp;</span>，这个路径中的&nbsp;<em>每个节点具有相同值</em>&nbsp;。 这条路径可以经过也可以不经过根节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">两个节点之间的路径长度</strong>&nbsp;由它们之间的边数表示。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/13/ex1.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,4,5,1,1,5]<strong style="font-weight: 600;">输出：</strong>2</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/13/ex2.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,4,5,4,4,5]<strong style="font-weight: 600;">输出：</strong>2</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树的节点数的范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 10<sup>4</sup>]</code>&nbsp;</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code>&nbsp;</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/longest-univalue-path/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 687. 最长同值路径</a>。</strong></details><h3 id="基本思路-45"><a href="#基本思路-45" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维，而且这类题目需要利用二叉树的后序遍历。</p><p>做这题之前，我建议你先做 <a href="https://leetcode.cn/problems/diameter-of-binary-tree">543. 二叉树的直径</a> 题并进行对比，把那道题的最大深度函数 <code>maxDepth</code> 的定义带入到这道题中，<code>maxLen</code> 相当于求值为 <code>parentVal</code> 的节点的最大深度。配合代码注释就立马明白了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-44"><a href="#解法代码-44" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">longestUnivaluePath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 在后序遍历的位置更新 res</span>        self<span class="token punctuation">.</span>maxLen<span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 定义：计算以 root 为根的这棵二叉树中，从 root 开始值为 parentVal 的最长树枝长度</span>    <span class="token keyword">def</span> <span class="token function">maxLen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 利用函数定义，计算左右子树值为 root.val 的最长树枝长度</span>        leftLen <span class="token operator">=</span> self<span class="token punctuation">.</span>maxLen<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        rightLen <span class="token operator">=</span> self<span class="token punctuation">.</span>maxLen<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 后序遍历位置顺便更新全局变量</span>        <span class="token comment"># 同值路径就是左右同值树枝长度之和</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> leftLen <span class="token operator">+</span> rightLen<span class="token punctuation">)</span>        <span class="token comment"># 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">!=</span> parentVal<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 实现函数的定义：</span>        <span class="token comment"># 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度</span>        <span class="token comment"># 等于左右子树的最长树枝长度的最大值加上 root 节点本身</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token builtin">max</span><span class="token punctuation">(</span>leftLen<span class="token punctuation">,</span> rightLen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-40"><a href="#可视化-40" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_longest-univalue-path" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_longest-univalue-path" src="https://labuladong.online/algo-visualize/leetcode/longest-univalue-path/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-pruning">814. 二叉树剪枝 🟠</a></li><li><a href="https://leetcode.cn/problems/pOCWxh">剑指 Offer II 047. 二叉树剪枝 🟠</a></li></ul><h2 id="865-具有所有最深节点的最小子树"><a href="#865-具有所有最深节点的最小子树" class="headerlink" title="865. 具有所有最深节点的最小子树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_smallest-subtree-with-all-the-deepest-nodes">865. 具有所有最深节点的最小子树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">865. 具有所有最深节点的最小子树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个根为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，每个节点的深度是<span>&nbsp;</span><strong style="font-weight: 600;">该节点到根的最短距离</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回包含原始树中所有<span>&nbsp;</span><strong style="font-weight: 600;">最深节点</strong><span>&nbsp;</span>的<span>&nbsp;</span><em>最小子树</em><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果一个节点在<span>&nbsp;</span><strong style="font-weight: 600;">整个树<span>&nbsp;</span></strong>的任意节点之间具有最大的深度，则该节点是<span>&nbsp;</span><strong style="font-weight: 600;">最深的</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一个节点的<span>&nbsp;</span><strong style="font-weight: 600;">子树</strong><span>&nbsp;</span>是该节点加上它的所有后代的集合。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/07/01/sketch1.png" style="max-width: 100%; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]<strong style="font-weight: 600;">输出：</strong>[2,7,4]<strong style="font-weight: 600;">解释：</strong>我们返回值为 2 的节点，在图中用黄色标记。在图中用蓝色标记的是树的最深的节点。注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>[1]<strong style="font-weight: 600;">解释：</strong>根节点是树中最深的节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,1,3,null,2]<strong style="font-weight: 600;">输出：</strong>[2]<strong style="font-weight: 600;">解释：</strong>树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数量在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 500]</code>&nbsp;范围内。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 500</code></li><li>每个节点的值都是<span>&nbsp;</span><strong style="font-weight: 600;">独一无二</strong><span>&nbsp;</span>的。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">注意：</strong>本题与力扣 1123 重复：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a></p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 865. 具有所有最深节点的最小子树</a>。</strong></details><h3 id="基本思路-46"><a href="#基本思路-46" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维，而且涉及处理子树，需要用后序遍历。</p><p>说到底，这道题就是让你求那些「最深」的叶子节点的最近公共祖先，可以看下后文 <a href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/">二叉树最近公共祖先</a>。</p><p>你想想，一个节点需要知道哪些信息，才能确定自己是最深叶子节点的最近公共祖先？</p><p>它需要知道自己的左右子树的最大深度：如果左右子树一样深，那么当前节点就是最近公共祖先；如果左右子树不一样深，那么最深叶子节点的最近公共祖先肯定在左右子树上。</p><p>所以我们新建一个 <code>Result</code> 类，存放左右子树的最大深度及叶子节点的最近公共祖先节点，其余逻辑类似 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-45"><a href="#解法代码-45" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 记录最近公共祖先节点 node</span>            self<span class="token punctuation">.</span>node <span class="token operator">=</span> node            <span class="token comment"># 记录以 node 为根的二叉树最大深度</span>            self<span class="token punctuation">.</span>depth <span class="token operator">=</span> depth    <span class="token keyword">def</span> <span class="token function">subtreeWithAllDeepest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span>node    <span class="token comment"># 定义：输入一棵二叉树，返回该二叉树的最大深度以及最深叶子节点的最近公共祖先节点</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Solution.Result'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>Result<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> left<span class="token punctuation">.</span>depth <span class="token operator">==</span> right<span class="token punctuation">.</span>depth<span class="token punctuation">:</span>            <span class="token comment"># 当左右子树的最大深度相同时，这个根节点是新的最近公共祖先</span>            <span class="token comment"># 以当前 root 节点为根的子树深度是子树深度 + 1</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>Result<span class="token punctuation">(</span>root<span class="token punctuation">,</span> left<span class="token punctuation">.</span>depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 左右子树的深度不同，则最近公共祖先在 depth 较大的一边</span>        res <span class="token operator">=</span> left <span class="token keyword">if</span> left<span class="token punctuation">.</span>depth <span class="token operator">></span> right<span class="token punctuation">.</span>depth <span class="token keyword">else</span> right        <span class="token comment"># 正确维护二叉树的最大深度</span>        res<span class="token punctuation">.</span>depth <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-41"><a href="#可视化-41" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_smallest-subtree-with-all-the-deepest-nodes" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_smallest-subtree-with-all-the-deepest-nodes" src="https://labuladong.online/algo-visualize/leetcode/smallest-subtree-with-all-the-deepest-nodes/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves">1123. 最深叶节点的最近公共祖先 🟠</a></li></ul><h2 id="1026-节点与其祖先之间的最大差值"><a href="#1026-节点与其祖先之间的最大差值" class="headerlink" title="1026. 节点与其祖先之间的最大差值"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_maximum-difference-between-node-and-ancestor">1026. 节点与其祖先之间的最大差值</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1026. 节点与其祖先之间的最大差值</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，找出存在于<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong><span>&nbsp;</span>节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">B</code><span>&nbsp;</span>之间的最大值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">V</code>，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">V = |A.val - B.val|</code>，且<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code><span>&nbsp;</span>是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">B</code><span>&nbsp;</span>的祖先。</p><p style="line-height: 1.6; overflow-wrap: break-word;">（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/11/09/tmp-tree.jpg" style="max-width: 100%; width: 400px; height: 390px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [8,3,10,1,6,null,14,null,null,4,7,13]<strong style="font-weight: 600;">输出：</strong>7<strong style="font-weight: 600;">解释： </strong>我们有大量的节点与其祖先的差值，其中一些如下：|8 - 3| = 5|3 - 7| = 4|8 - 1| = 7|10 - 13| = 3在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/11/09/tmp-tree-1.jpg" style="max-width: 100%; width: 250px; height: 349px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,2,null,0,3]<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">5000</code><span>&nbsp;</span>之间。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1026. 节点与其祖先之间的最大差值</a>。</strong></details><h3 id="基本思路-47"><a href="#基本思路-47" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这题要用到 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 中强调的二叉树后序位置的特殊性。</p><p>站在某个节点，你如何判断以这个节点为根的二叉树中的最大差值？换句话说，你需要知道哪些信息，才能算出来这个最大差值？</p><p>思考这个问题很有必要，你必须先知道怎么算，才能写递归函数去实现你的思路。</p><p>这个问题的答案是，每个节点需要知道左右子树的最小值和最大值，然后就能算出「以自己为祖先」的最大差值。</p><p>每个节点都知道以自己为祖先的最大差值，那么所有这些差值中最大的那个就是整棵树的最大差值，这个取最大值的过程需要在后序遍历的位置进行，直接看解法代码理解吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-46"><a href="#解法代码-46" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxAncestorDiff</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>getMinMax<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 定义：输入一棵二叉树，返回该二叉树中节点的最小值和最大值，</span>    <span class="token comment"># 第一个元素是最小值，第二个值是最大值</span>    <span class="token keyword">def</span> <span class="token function">getMinMax</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        leftMinMax <span class="token operator">=</span> self<span class="token punctuation">.</span>getMinMax<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightMinMax <span class="token operator">=</span> self<span class="token punctuation">.</span>getMinMax<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 以 root 为根的这棵树的最大值和最小值可以通过左右子树的最大最小值推导出来</span>        rootMin <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> leftMinMax<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rightMinMax<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        rootMax <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> leftMinMax<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rightMinMax<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 在后序位置顺便判断所有差值的最大值</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> rootMax <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val <span class="token operator">-</span> rootMin<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>rootMin<span class="token punctuation">,</span> rootMax<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-42"><a href="#可视化-42" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-difference-between-node-and-ancestor" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-difference-between-node-and-ancestor" src="https://labuladong.online/algo-visualize/leetcode/maximum-difference-between-node-and-ancestor/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1339-分裂二叉树的最大乘积"><a href="#1339-分裂二叉树的最大乘积" class="headerlink" title="1339. 分裂二叉树的最大乘积"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_maximum-product-of-splitted-binary-tree">1339. 分裂二叉树的最大乘积</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1339. 分裂二叉树的最大乘积</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，它的根为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p><p style="line-height: 1.6; overflow-wrap: break-word;">由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png" style="max-width: 100%; height: 200px; width: 495px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6]<strong style="font-weight: 600;">输出：</strong>110<strong style="font-weight: 600;">解释：</strong>删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png" style="max-width: 100%; height: 200px; width: 495px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,2,3,4,null,null,5,6]<strong style="font-weight: 600;">输出：</strong>90<strong style="font-weight: 600;">解释：</strong>移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,3,9,10,7,8,6,5,4,11,1]<strong style="font-weight: 600;">输出：</strong>1025</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,1]<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>每棵树最多有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">50000</code>&nbsp;个节点，且至少有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code>&nbsp;个节点。</li><li>每个节点的值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10000]</code>&nbsp;之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1339. 分裂二叉树的最大乘积</a>。</strong></details><h3 id="基本思路-48"><a href="#基本思路-48" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这里要用到前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过的后序位置的妙用。</p><p>题目说的比较繁琐，这道题说的简单些就是：</p><p>在二叉树中切出一个小二叉树（子树），计算这个子树节点之和与剩下的节点之和的乘积。</p><p>想求最大乘积，那就穷举，把所有可能的切法都穷举一遍，计算乘积。</p><p>任何子树的节点之和都可以在后序位置获得，而剩下的其他节点之和就是整棵二叉树的节点之和减去子树节点之和。</p><p>所以我们写一个 <code>getSum</code> 函数，先执行一遍计算整棵树的节点之和，然后再调用一次利用它的后序位置计算乘积。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-47"><a href="#解法代码-47" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 先利用求和函数得到整棵树的节点之和</span>        self<span class="token punctuation">.</span>treeSum <span class="token operator">=</span> self<span class="token punctuation">.</span>getSum<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 再次调用，利用后序位置计算子树之积</span>        self<span class="token punctuation">.</span>getSum<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>treeSum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">getSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        leftSum <span class="token operator">=</span> self<span class="token punctuation">.</span>getSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rightSum <span class="token operator">=</span> self<span class="token punctuation">.</span>getSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        rootSum <span class="token operator">=</span> leftSum <span class="token operator">+</span> rightSum <span class="token operator">+</span> root<span class="token punctuation">.</span>val        <span class="token comment"># 后序位置计算乘积</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> rootSum <span class="token operator">*</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>treeSum <span class="token operator">-</span> rootSum<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> rootSum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/count-nodes-with-the-highest-score">2049. 统计最高分的节点数目 🟠</a></li></ul><h2 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372. 二叉树中的最长交错路径"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_longest-zigzag-path-in-a-binary-tree">1372. 二叉树中的最长交错路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1372. 二叉树中的最长交错路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵以&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;为根的二叉树，二叉树中的交错路径定义如下：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>选择二叉树中<span>&nbsp;</span><strong style="font-weight: 600;">任意</strong>&nbsp;节点和一个方向（左或者右）。</li><li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li><li>改变前进方向：左变右或者右变左。</li><li>重复第二步和第三步，直到你在树中无法继续移动。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">交错路径的长度定义为：<strong style="font-weight: 600;">访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回给定树中最长<span>&nbsp;</span><strong style="font-weight: 600;">交错路径</strong>&nbsp;的长度。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/03/07/sample_1_1702.png" style="max-width: 100%; height: 283px; width: 151px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/03/07/sample_2_1702.png" style="max-width: 100%; height: 253px; width: 120px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,1,1,null,1,null,null,1,1,null,1]<strong style="font-weight: 600;">输出：</strong>4<strong style="font-weight: 600;">解释：</strong>蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>每棵树最多有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">50000</code>&nbsp;个节点。</li><li>每个节点的值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code><span>&nbsp;</span>之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1372. 二叉树中的最长交错路径</a>。</strong></details><h3 id="基本思路-49"><a href="#基本思路-49" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维，而且要用到后序位置的妙用。</p><p>首先，我们先明确一下名词的含义，便于讲解：</p><p>如果一个从上到下的交错路径的开头是从右到左的，称之为「左交错路径」，反之成为「右交错路径」。</p><p>这样的话，一个节点 <code>x</code> 能够产生的交错路径就能分解到左右子树：</p><p>1、<code>x</code> 的左子树的「右交错路径」+ 节点 <code>x</code> &#x3D; <code>x</code> 的「左交错路径」</p><p>2、<code>x</code> 的右子树的「左交错路径」+ 节点 <code>x</code> &#x3D; <code>x</code> 的「右交错路径」</p><p>比较 <code>x</code> 的左右交错路径，即可算出以 <code>x</code> 开头的最长交错路径。</p><p>对二叉树上的所有节点计算交错路径长度，即可得到最长的交错路径长度。</p><p>所以我们定义一个 <code>getPathLen</code> 函数计算并返回一个节点的左右交错路径长度，然后在后序位置上更新全局最大值。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-48"><a href="#解法代码-48" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestZigZag</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>getPathLen<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 输入二叉树的根节点 root，返回两个值</span>    <span class="token comment"># 第一个是从 root 开始向左走的最长交错路径长度，</span>    <span class="token comment"># 第一个是从 root 开始向右走的最长交错路径长度</span>    <span class="token keyword">def</span> <span class="token function">getPathLen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">tuple</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>getPathLen<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>getPathLen<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置，根据左右子树的交错路径长度推算根节点的交错路径长度</span>        rootPathLen1 <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        rootPathLen2 <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token comment"># 更新全局最大值</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">(</span>rootPathLen1<span class="token punctuation">,</span> rootPathLen2<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>rootPathLen1<span class="token punctuation">,</span> rootPathLen2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-43"><a href="#可视化-43" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_longest-zigzag-path-in-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_longest-zigzag-path-in-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/longest-zigzag-path-in-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606. 根据二叉树创建字符串"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_construct-string-from-binary-tree">606. 根据二叉树创建字符串</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">606. 根据二叉树创建字符串</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/construct-string-from-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</p><p style="line-height: 1.6; overflow-wrap: break-word;">空节点使用一对空括号对<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"()"</code><span>&nbsp;</span>表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/05/03/cons1-tree.jpg" style="max-width: 100%; width: 292px; height: 301px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4]<strong style="font-weight: 600;">输出：</strong>"1(2(4))(3)"<strong style="font-weight: 600;">解释：</strong>初步转化后得到 "1(2(4)())(3()())" ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/05/03/cons2-tree.jpg" style="max-width: 100%; width: 207px; height: 293px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4]<strong style="font-weight: 600;">输出：</strong>"1(2()(4))(3)"<strong style="font-weight: 600;">解释：</strong>和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/construct-string-from-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 606. 根据二叉树创建字符串</a>。</strong></details><h3 id="基本思路-50"><a href="#基本思路-50" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>我们先明确 <code>tree2str</code> 函数的定义，然后利用这个定义生成左右子树的字符串，然后结合 <code>root</code> 组装出最后结果。</p><p>注意，题目说按照前序遍历的方式组装字符串，但我们必须在后序遍历位置去组装，因为只有那里你才能拿到左右子树的字符串。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-49"><a href="#解法代码-49" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入以 root 的二叉树，返回描述该二叉树的字符串</span>    <span class="token keyword">def</span> <span class="token function">tree2str</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 递归生成左右子树的字符串</span>        left_str <span class="token operator">=</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right_str <span class="token operator">=</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序代码位置</span>        <span class="token comment"># 根据左右子树字符串组装出前序遍历的顺序</span>        <span class="token comment"># 按题目要求处理 root 只有一边有子树的情况</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 省略空的右子树</span>            <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">&#125;</span></span><span class="token string">(</span><span class="token interpolation"><span class="token punctuation">&#123;</span>left_str<span class="token punctuation">&#125;</span></span><span class="token string">)"</span></span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 空的左子树不能省略</span>            <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">&#125;</span></span><span class="token string">()(</span><span class="token interpolation"><span class="token punctuation">&#123;</span>right_str<span class="token punctuation">&#125;</span></span><span class="token string">)"</span></span>        <span class="token comment"># 按题目要求处理 root 左右子树都不空的情况</span>        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">&#125;</span></span><span class="token string">(</span><span class="token interpolation"><span class="token punctuation">&#123;</span>left_str<span class="token punctuation">&#125;</span></span><span class="token string">)(</span><span class="token interpolation"><span class="token punctuation">&#123;</span>right_str<span class="token punctuation">&#125;</span></span><span class="token string">)"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-44"><a href="#可视化-44" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_construct-string-from-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_construct-string-from-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/construct-string-from-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1443-收集树上所有苹果的最少时间"><a href="#1443-收集树上所有苹果的最少时间" class="headerlink" title="1443. 收集树上所有苹果的最少时间"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#slug_minimum-time-to-collect-all-apples-in-a-tree">1443. 收集树上所有苹果的最少时间</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1443. 收集树上所有苹果的最少时间</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n-1</code>&nbsp;，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从&nbsp;<strong style="font-weight: 600;">节点 0&nbsp;</strong>出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p><p style="line-height: 1.6; overflow-wrap: break-word;">无向树的边由&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">edges</code>&nbsp;给出，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示有一条边连接&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">from</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">to<sub>i</sub></code><span>&nbsp;</span>。除此以外，还有一个布尔数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">hasApple</code><span>&nbsp;</span>，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">hasApple[i] = true</code>&nbsp;代表节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;有一个苹果，否则，节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;没有苹果。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_1.png" style="max-width: 100%; height: 212px; width: 300px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]<strong style="font-weight: 600;">输出：</strong>8 <strong style="font-weight: 600;">解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_2.png" style="max-width: 100%; height: 212px; width: 300px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">edges.length == n - 1</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">edges[i].length == 2</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= a<sub>i</sub>&nbsp;&lt; b<sub>i</sub>&nbsp;&lt;= n - 1</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">hasApple.length == n</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1443. 收集树上所有苹果的最少时间</a>。</strong></details><h3 id="基本思路-51"><a href="#基本思路-51" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>这里要用到前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过的后序位置的妙用。</p><p>题目输入的是若干条边的形式，我们首先需要用 <a href="https://labuladong.online/algo/data-structure-basic/graph-basic/">图论算法基础</a> 中讲到的表示无向图的邻接表来存储这棵多叉树。</p><p>构造出了多叉树，这道题显然要用分解问题的思维模式，并利用后序位置的妙用。</p><p>为什么？假设你站在这棵树中的某个节点上，你脚底下有多棵子树，你要去这些子树里面找苹果对不对？</p><p>你如果知道了在一棵子树中找苹果的最小步数，假设为 <code>x</code>，那么算上你进出这棵子树的 2 步，<code>x + 2</code> 就是从你进入这棵子树找苹果的最小步数。</p><p>当然，你脚底下可能有多棵子树都有苹果，所以就会有 <code>x1 + 2, x2 + 2...</code> 这些结果加起来，不就是在以你这个节点为根的整棵树找苹果的最小步数了么？这分解问题的思路不就出来了么？</p><p>把上述思路翻译出来即可，注意递归函数 <code>collect</code> 的定义，我们需要对没有苹果的情况给个特殊值，具体看代码吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/">【练习】利用后序位置解题 II</a></li></ul><h3 id="解法代码-50"><a href="#解法代码-50" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 邻接表形式，存储着一棵多叉树</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        self<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">minTime</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> edges<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hasApple<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">bool</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 构造多叉树结构</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>        <span class="token comment"># 根据 collect 函数的定义，返回题目想要的结果</span>        self<span class="token punctuation">.</span>hasApple <span class="token operator">=</span> hasApple  <span class="token comment"># Adding this line to fix the NameError</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> res <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>    <span class="token comment"># 定义：遍历以 root 为根的这棵多叉树，返回收集其中的所有苹果所需的最少步数（时间）</span>    <span class="token comment"># 如果返回的是 -1，说明以 root 为根的这棵多叉树中没有苹果</span>    <span class="token keyword">def</span> <span class="token function">collect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">in</span> self<span class="token punctuation">.</span>visited<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        self<span class="token punctuation">.</span>visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 去子树看看是否找到了苹果</span>        sum_time <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># Renamed sum to sum_time to avoid conflict with built-in sum function</span>        <span class="token keyword">for</span> child <span class="token keyword">in</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>            subTime <span class="token operator">=</span> self<span class="token punctuation">.</span>collect<span class="token punctuation">(</span>child<span class="token punctuation">)</span>            <span class="token keyword">if</span> subTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token comment"># 这棵子树中有苹果，从 root 进入和离开这棵子树，需要额外的两步</span>                sum_time <span class="token operator">+=</span> subTime <span class="token operator">+</span> <span class="token number">2</span>        <span class="token comment"># 在后序位置对当前节点的情况和子树返回的信息进行处理：</span>        <span class="token keyword">if</span> sum_time <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>hasApple<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 子树中发现苹果，或者当前节点是苹果，直接返回，sum_time 已经算上了本节点出入子树的步数</span>            <span class="token keyword">return</span> sum_time        <span class="token comment"># 以 root 为根的这棵多叉树中不存在苹果，按照定义返回 -1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-45"><a href="#可视化-45" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_minimum-time-to-collect-all-apples-in-a-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_minimum-time-to-collect-all-apples-in-a-tree" src="https://labuladong.online/algo-visualize/leetcode/minimum-time-to-collect-all-apples-in-a-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>写在后序位置的代码是最潇洒的，上通父节点（可以通过函数参数获取父节点信息），下通子树（可以通过递归返回值收集子树信息），有少部分难度比较大的题目会同时用到这两个特性。</p><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#slug_binary-tree-cameras">968. 监控二叉树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">968. 监控二叉树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-cameras/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-cameras/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树，我们在树的节点上安装摄像头。</p><p style="line-height: 1.6; overflow-wrap: break-word;">节点上的每个摄影头都可以监视<strong style="font-weight: 600;">其父对象、自身及其直接子对象。</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;">计算监控树的所有节点所需的最小摄像头数量。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" style="max-width: 100%; height: 163px; width: 138px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>[0,0,null,0,0]<strong style="font-weight: 600;">输出：</strong>1<strong style="font-weight: 600;">解释：</strong>如图所示，一台摄像头足以监控所有节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" style="max-width: 100%; height: 312px; width: 139px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>[0,0,null,0,null,0,null,null,0]<strong style="font-weight: 600;">输出：</strong>2<strong style="font-weight: 600;">解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><br><strong style="font-weight: 600;">提示：</strong></p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定树的节点数的范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-cameras/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 968. 监控二叉树</a>。</strong></details><h3 id="基本思路-52"><a href="#基本思路-52" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过后序位置的特殊之处，后序位置可以接收到子树的信息，同时也可以通过函数参数接收到父节点传递的信息，这道题就可以比较完美地体现这一特点。</p><p>首先我们列举一下一个节点可能存在的几种状态：</p><p>该节点不在监控区域内，称为 uncover 状态；该节点在附近节点的监控范围内，称为 cover 状态；该节点自己装了摄像头，称为 set 状态。</p><p>如何保证安装的摄像头数量尽可能少呢？显然就是要尽可能分散，让每个摄像头物尽其用。</p><p>具体来说就是自底向上安装摄像头，在叶子节点的父节点上安装摄像头，然后每隔两层再安装（因为每个摄像头都可以管三层）。</p><p>那么一个节点在什么情况下需要被安装摄像头呢？显然是当这个节点的子节点处于 uncover 的状态的时候必须安装摄像头，以便覆盖子节点。</p><p>综上，我们需要利用后序位置自底向上遍历二叉树，同时要利用子节点的状态以及父节点的状态，判断当前节点是否需要安装摄像头。</p><p>解法中 <code>setCamera</code> 函数就负责按照最优方式给二叉树安装摄像头，同时返回节点的状态。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/">【练习】利用后序位置解题 III</a></li></ul><h3 id="解法代码-51"><a href="#解法代码-51" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minCameraCover</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>setCamera<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 定义：输入以 root 为根的二叉树，以最优策略在这棵二叉树上放置摄像头，</span>    <span class="token comment"># 然后返回 root 节点的情况：</span>    <span class="token comment"># 返回 -1 代表 root 为空，返回 0 代表 root 未被 cover，</span>    <span class="token comment"># 返回 1 代表 root 已经被 cover，返回 2 代表 root 上放置了摄像头。</span>    <span class="token keyword">def</span> <span class="token function">setCamera</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> hasParent<span class="token punctuation">:</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token comment"># 获取左右子节点的情况</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>setCamera<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>setCamera<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment"># 根据左右子节点的情况和父节点的情况判断当前节点应该做的事情</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">and</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 当前节点是叶子节点</span>            <span class="token keyword">if</span> hasParent<span class="token punctuation">:</span>                <span class="token comment"># 有父节点的话，让父节点来 cover 自己</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token comment"># 没有父节点的话，自己 set 一个摄像头</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token number">2</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> right <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 左右子树存在没有被 cover 的</span>            <span class="token comment"># 必须在当前节点 set 一个摄像头</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token number">2</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">or</span> right <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token comment"># 左右子树只要有一个 set 了摄像头</span>            <span class="token comment"># 当前节点就已经是 cover 状态了</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token comment"># 剩下 left == 1 &amp;&amp; right == 1 的情况</span>        <span class="token comment"># 即当前节点的左右子节点都被 cover</span>        <span class="token keyword">if</span> hasParent<span class="token punctuation">:</span>            <span class="token comment"># 如果有父节点的话，可以等父节点 cover 自己</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 没有父节点，只能自己 set 一个摄像头</span>            self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-46"><a href="#可视化-46" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-cameras" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-cameras" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-cameras/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="979-在二叉树中分配硬币"><a href="#979-在二叉树中分配硬币" class="headerlink" title="979. 在二叉树中分配硬币"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#slug_distribute-coins-in-binary-tree">979. 在二叉树中分配硬币</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">979. 在二叉树中分配硬币</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个结点的二叉树的根结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，其中树中每个结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code><span>&nbsp;</span>都对应有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node.val</code><span>&nbsp;</span>枚硬币。整棵树上一共有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>枚硬币。</p><p style="line-height: 1.6; overflow-wrap: break-word;">在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回使每个结点上<span>&nbsp;</span><strong style="font-weight: 600;">只有</strong><span>&nbsp;</span>一枚硬币所需的<span>&nbsp;</span><strong style="font-weight: 600;">最少</strong><span>&nbsp;</span>移动次数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/18/tree1.png" style="max-width: 100%; width: 250px; height: 236px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,0,0]<strong style="font-weight: 600;">输出：</strong>2<strong style="font-weight: 600;">解释：</strong>一枚硬币从根结点移动到左子结点，一枚硬币从根结点移动到右子结点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/18/tree2.png" style="max-width: 100%; width: 250px; height: 236px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,3,0]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>将两枚硬币从根结点的左子结点移动到根结点（两次移动）。然后，将一枚硬币从根结点移动到右子结点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= n</code></li><li>所有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code><span>&nbsp;</span>的值之和是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 979. 在二叉树中分配硬币</a>。</strong></details><h3 id="基本思路-53"><a href="#基本思路-53" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>做这道题之前，你应该先做一下 <a href="https://leetcode.cn/problems/diameter-of-binary-tree">543. 二叉树的直径</a>，并且认真理解 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 中说到的后序遍历的用法。</p><p>硬币的移动规则看似很复杂，因为一个节点可能需要移出硬币，也可能移入硬币，还要求移动次数最少，是不是感觉无从下手？</p><p>对于这种问题，我们首先要观察规律仔细思考，看看能否对题目进行简化，然后再求解。</p><p>首先题目说了整棵树上一共有 <code>n</code> 枚硬币，意思是通过移动，一定是可以做到每个节点有且仅有一枚硬币，不存在无解的情况。</p><p>现在的情况是，每个节点有 <code>node.val</code> 个硬币，<code>node.val &gt;= 0</code>，允许我们在相邻节点随意移动硬币，计算将所有节点配平（只有 1 个硬币）的最少移动次数。</p><p><strong>我们可以简单变换一下：允许每个节点的硬币个数为负数，且只允许子节点向父节点移动硬币</strong>。</p><p>比方说父节点想向子节点移动 1 个硬币，等价于子节点向父节点移动 -1 个硬币；如果一个节点的硬币个数为 -3，那么他就需要向父节点移动 -4 个硬币，才能让自己的硬币个数变成 1。</p><p>这样，我们就不用考虑移入和移出的区别了，想要把一个节点的硬币个数变成 1，就要向父节点移动 <code>node.val - 1</code> 个节点。</p><p>现在就可以开始二叉树的通用解题思路：<strong>假想你现在站在根节点上，你如何知道把整棵树配平所需的最小移动次数</strong>？</p><p>左子树来跟你汇报，想给你移动 <code>left</code> 个节点；右子树来找你汇报，想给你移动 <code>right</code> 个节点，那么你所在节点向父节点移动的硬币个数就是：</p><pre class="line-numbers language-none"><code class="language-none">left + right + (node.val - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个过程中移动次数是：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 让当前这棵树平衡所需的移动次数Math.abs(left) + Math.abs(right) + (node.val - 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在你去看代码就能理解了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/">【练习】利用后序位置解题 III</a></li></ul><h3 id="解法代码-52"><a href="#解法代码-52" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">distributeCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>getRest<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 定义：输入一棵二叉树，返回这棵二叉树中多出的硬币个数，返回负数代表缺少硬币</span>    <span class="token keyword">def</span> <span class="token function">getRest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 计算左右子树多出的硬币个数</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>getRest<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>getRest<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置，计算当前这棵树配平所需的移动次数</span>        self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 实现函数的定义</span>        <span class="token keyword">return</span> left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-47"><a href="#可视化-47" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_distribute-coins-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_distribute-coins-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/distribute-coins-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1080-根到叶路径上的不足节点"><a href="#1080-根到叶路径上的不足节点" class="headerlink" title="1080. 根到叶路径上的不足节点"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#slug_insufficient-nodes-in-root-to-leaf-paths">1080. 根到叶路径上的不足节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1080. 根到叶路径上的不足节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">limit</code><span>&nbsp;</span>，请你同时删除树中所有<span>&nbsp;</span><strong style="font-weight: 600;">不足节点<span>&nbsp;</span></strong>，并返回最终二叉树的根节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;">假如通过节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code><span>&nbsp;</span>的每种可能的 “根-叶” 路径上值的总和全都小于给定的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">limit</code>，则该节点被称之为<strong style="font-weight: 600;"><span>&nbsp;</span>不足节点<span>&nbsp;</span></strong>，需要被删除。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶子节点</strong>，就是没有子节点的节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/06/05/insufficient-11.png" style="max-width: 100%; width: 500px; height: 207px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1<strong style="font-weight: 600;">输出：</strong>[1,2,3,4,null,null,7,8,9,null,14]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/06/05/insufficient-3.png" style="max-width: 100%; width: 400px; height: 274px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22<strong style="font-weight: 600;">输出：</strong>[5,4,8,11,null,17,4,7,null,null,null,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/06/11/screen-shot-2019-06-11-at-83301-pm.png" style="max-width: 100%; width: 250px; height: 199px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,-3,-5,null,4,null], limit = -1<strong style="font-weight: 600;">输出：</strong>[1,null,-3,4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 5000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>9</sup><span>&nbsp;</span>&lt;= limit &lt;= 10<sup>9</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1080. 根到叶路径上的不足节点</a>。</strong></details><h3 id="基本思路-54"><a href="#基本思路-54" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>可以说这道题非常精妙，完美运用前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 中说到的前序位置和后序位置的特点：</p><p>前序位置可以通过函数参数获取父节点传递来的数据，后序位置可以额外获取子树传递回来的数据。</p><p>首先，对于一个叶子节点，它本身就是以自己为根的这棵二叉树的路径，那么这条路径是否小于 <code>limit</code> 的约束是很显然的，如果小于 <code>limit</code>，说明它需要被删除。</p><p>然后，对于一个非叶子节点 <code>x</code>，它是否是一个「不足节点」，或者说是否存在一条不满足 <code>limit</code> 约束的路径穿过这个节点，其实可以根据子树推导出来。</p><p>如果 <code>x</code> 的左右子节点都被删除，那么就说明 <code>x</code> 的左右子树上的路径都不满足 <code>limit</code> 的约束，也就是说所有穿过 <code>x</code> 的路径都不满足约束，即 <code>x</code> 也应该被删除。</p><p>根据上述思路实现代码，即可解决这道题。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/">【练习】利用后序位置解题 III</a></li></ul><h3 id="解法代码-53"><a href="#解法代码-53" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：输入一个节点 root，和约束 limit，</span><span class="token comment"># 删除以 root 为根的二叉树中的「不足节点」，返回删除完成后的二叉树根节点</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sufficientSubset</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 前序位置，接收父节点传递的 limit 约束决定叶子结点是否需要被删除</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> limit<span class="token punctuation">:</span>                <span class="token comment"># 对于叶子节点，如果低于 limit 说明需要被删除</span>                <span class="token keyword">return</span> <span class="token boolean">None</span>            <span class="token keyword">return</span> root        <span class="token comment"># 先对左右子树进行删除，接收返回值</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>sufficientSubset<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> limit <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>sufficientSubset<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> limit <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 后序位置，根据子树的删除情况决定自己是否需要被删除</span>        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 如果左右子树不满足 limit - root.val 的约束，那么就存在经过 root</span>            <span class="token comment"># 节点的路径不满足约束，也就说明 root 节点是「不足节点」，需要被删掉</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> left        root<span class="token punctuation">.</span>right <span class="token operator">=</span> right        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-48"><a href="#可视化-48" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_insufficient-nodes-in-root-to-leaf-paths" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_insufficient-nodes-in-root-to-leaf-paths" src="https://labuladong.online/algo-visualize/leetcode/insufficient-nodes-in-root-to-leaf-paths/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="2049-统计最高分的节点数目"><a href="#2049-统计最高分的节点数目" class="headerlink" title="2049. 统计最高分的节点数目"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#slug_count-nodes-with-the-highest-score">2049. 统计最高分的节点数目</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">2049. 统计最高分的节点数目</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/count-nodes-with-the-highest-score/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/count-nodes-with-the-highest-score/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵根节点为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>的&nbsp;<strong style="font-weight: 600;">二叉树</strong>&nbsp;，它总共有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;个节点，节点编号为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n - 1</code>&nbsp;。同时给你一个下标从&nbsp;<strong style="font-weight: 600;">0</strong>&nbsp;开始的整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">parents</code>&nbsp;表示这棵树，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">parents[i]</code>&nbsp;是节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;的父节点。由于节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;是根，所以&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">parents[0] == -1</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一个子树的<span>&nbsp;</span><strong style="font-weight: 600;">大小</strong>&nbsp;为这个子树内节点的数目。每个节点都有一个与之关联的&nbsp;<strong style="font-weight: 600;">分数</strong>&nbsp;。求出某个节点分数的方法是，将这个节点和与它相连的边全部<span>&nbsp;</span><strong style="font-weight: 600;">删除</strong>&nbsp;，剩余部分是若干个<span>&nbsp;</span><strong style="font-weight: 600;">非空</strong>&nbsp;子树，这个节点的<span>&nbsp;</span><strong style="font-weight: 600;">分数</strong>&nbsp;为所有这些子树<span>&nbsp;</span><strong style="font-weight: 600;">大小的乘积</strong>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回有<span>&nbsp;</span><strong style="font-weight: 600;">最高得分</strong>&nbsp;节点的<span>&nbsp;</span><strong style="font-weight: 600;">数目</strong>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="example-1" src="https://labuladong.online/algo/images/lc/uploads/2021/10/03/example-1.png" style="max-width: 100%; width: 604px; height: 266px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>parents = [-1,2,0,2,0]<b>输出：</b>3<strong style="font-weight: 600;">解释：</strong>- 节点 0 的分数为：3 * 1 = 3- 节点 1 的分数为：4 = 4- 节点 2 的分数为：1 * 1 * 2 = 2- 节点 3 的分数为：4 = 4- 节点 4 的分数为：4 = 4最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="example-2" src="https://labuladong.online/algo/images/lc/uploads/2021/10/03/example-2.png" style="max-width: 100%; width: 95px; height: 143px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>parents = [-1,2,0]<b>输出：</b>2<strong style="font-weight: 600;">解释：</strong>- 节点 0 的分数为：2 = 2- 节点 1 的分数为：2 = 2- 节点 2 的分数为：1 * 1 = 1最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == parents.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">parents[0] == -1</code></li><li>对于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i != 0</code>&nbsp;，有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= parents[i] &lt;= n - 1</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">parents</code>&nbsp;表示一棵二叉树。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/count-nodes-with-the-highest-score/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 2049. 统计最高分的节点数目</a>。</strong></details><h3 id="基本思路-55"><a href="#基本思路-55" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维，而且要用到后序位置的妙用。</p><p>在做这道题之前，建议你先去看下我给 <a href="https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree">1339. 分裂二叉树的最大乘积</a> 写的思路和解法代码，然后立马就知道这道题的思路了。</p><p>简单说，一个节点的 <strong>分数 &#x3D; 左子树节点个数 x 右子树节点个数 x 除自己外其他节点个数</strong>。</p><p>只要写个 <code>countNode</code> 函数，在后序位置可以得到左右子树的节点个数 <code>leftCount</code> 和 <code>rightCount</code>，然后除自己外其他节点个数 <code>otherCount</code> 就等于总的节点个数 <code>n</code> 减掉左右子树的节点个数再减掉当前节点，最后求个乘积就能算出当前节点的「分数」了。</p><p>当然，这道题还有个难点就是：题目给的 <code>parents</code> 数组不是我们经常见到的二叉树形式。</p><p>但问题不大，我们可以把 <code>parents</code> 数组转化成类似 <a href="https://labuladong.online/algo/data-structure-basic/graph-basic/">图论基础</a> 中讲到的邻接表结构，然后就可以像操作常规二叉树一样写算法了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/">【练习】利用后序位置解题 III</a></li></ul><h3 id="解法代码-54"><a href="#解法代码-54" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 用邻接表表示的一棵二叉树</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tree <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>scoreToCount <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">countHighestScoreNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parents<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tree <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>parents<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>countNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># 计算最大分数出现的次数</span>        maxScore <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> score <span class="token keyword">in</span> self<span class="token punctuation">.</span>scoreToCount<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxScore <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>maxScore<span class="token punctuation">,</span> score<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>scoreToCount<span class="token punctuation">[</span>maxScore<span class="token punctuation">]</span>    <span class="token comment"># 计算二叉树中的节点个数</span>    <span class="token keyword">def</span> <span class="token function">countNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 二叉树中节点总数</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">)</span>        leftCount <span class="token operator">=</span> self<span class="token punctuation">.</span>countNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        rightCount <span class="token operator">=</span> self<span class="token punctuation">.</span>countNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 后序位置，计算每个节点的「分数」</span>        otherCount <span class="token operator">=</span> n <span class="token operator">-</span> leftCount <span class="token operator">-</span> rightCount <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment"># 注意，这里要把 int 转化成 long，否则会产生溢出！！！</span>        score <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>leftCount<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">max</span><span class="token punctuation">(</span>rightCount<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">max</span><span class="token punctuation">(</span>otherCount<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 给分数 score 计数</span>        <span class="token keyword">if</span> score <span class="token keyword">in</span> self<span class="token punctuation">.</span>scoreToCount<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>scoreToCount<span class="token punctuation">[</span>score<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>scoreToCount<span class="token punctuation">[</span>score<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> leftCount <span class="token operator">+</span> rightCount <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment"># 将 parents 数组转化成常规二叉树（邻接表形式）</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parents<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span>        <span class="token comment"># 表节点 x 的左子节点为 tree[x][0]，节点 x 的右子节点为 tree[x][1]</span>        <span class="token comment"># 若 tree[x][0] 或 tree[x][1] 等于 -1 则代表空指针</span>        tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 根据 parents 数组构建二叉树（跳过 parents[0] 根节点）</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            parent_i <span class="token operator">=</span> parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> tree<span class="token punctuation">[</span>parent_i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                tree<span class="token punctuation">[</span>parent_i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token keyword">else</span><span class="token punctuation">:</span>                tree<span class="token punctuation">[</span>parent_i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-49"><a href="#可视化-49" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-post-order-iii/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_count-nodes-with-the-highest-score" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_count-nodes-with-the-highest-score" src="https://labuladong.online/algo-visualize/leetcode/count-nodes-with-the-highest-score/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h1 id="【练习】运用层序遍历解题-I"><a href="#【练习】运用层序遍历解题-I" class="headerlink" title="【练习】运用层序遍历解题 I"></a>【练习】运用层序遍历解题 I</h1><p>二叉树大部分题目都可以用递归的算法解决，但少部分题目用递归比较麻烦的话，我们可以考虑使用层序遍历的方式解决。</p><hr><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_binary-tree-level-order-traversal">102. 二叉树的层序遍历</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">102. 二叉树的层序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，返回其节点值的<span>&nbsp;</span><strong style="font-weight: 600;">层序遍历</strong><span>&nbsp;</span>。 （即逐层地，从左到右访问所有节点）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/tree1.jpg" style="max-width: 100%; width: 277px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>[[3],[9,20],[15,7]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>[[1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = []<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 2000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 102. 二叉树的层序遍历</a>。</strong></details><h3 id="基本思路-56"><a href="#基本思路-56" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这题没啥可说的，<a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的递归&#x2F;层序遍历</a> 遍历中介绍了三种层序（BFS）遍历的写法，任写一种都可以。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-55"><a href="#解法代码-55" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 记录这一层的节点值</span>            level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token comment"># for 循环控制每一层从左向右遍历</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                level<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>level<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-50"><a href="#可视化-50" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-level-order-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-level-order-traversal" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-level-order-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal">103. 二叉树的锯齿形层序遍历 🟠</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii">107. 二叉树的层序遍历 II 🟠</a></li><li><a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree">1161. 最大层内元素和 🟠</a></li><li><a href="https://leetcode.cn/problems/deepest-leaves-sum">1302. 层数最深叶子节点的和 🟠</a></li><li><a href="https://leetcode.cn/problems/even-odd-tree">1609. 奇偶树 🟠</a></li><li><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal">429. N 叉树的层序遍历 🟠</a></li><li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">637. 二叉树的层平均值 🟢</a></li><li><a href="https://leetcode.cn/problems/complete-binary-tree-inserter">919. 完全二叉树插入器 🟠</a></li><li><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree">958. 二叉树的完全性检验 🟠</a></li><li><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof">剑指 Offer 32 - I. 从上到下打印二叉树 🟠</a></li><li><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof">剑指 Offer 32 - II. 从上到下打印二叉树 II 🟢</a></li><li><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">剑指 Offer 32 - III. 从上到下打印二叉树 III 🟠</a></li></ul><h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_binary-tree-level-order-traversal-ii">107. 二叉树的层序遍历 II</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">107. 二叉树的层序遍历 II</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，返回其节点值<span>&nbsp;</span><strong style="font-weight: 600;">自底向上的层序遍历</strong><span>&nbsp;</span>。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/tree1.jpg" style="max-width: 100%; width: 277px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>[[15,7],[9,20],[3]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>[[1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = []<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 2000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 107. 二叉树的层序遍历 II</a>。</strong></details><h3 id="基本思路-57"><a href="#基本思路-57" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这题和 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a> 几乎是一样的，自顶向下的层序遍历反过来就行了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-56"><a href="#解法代码-56" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token punctuation">,</span> Optional<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 记录这一层的节点值</span>            level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token comment"># for 循环控制每一层从左向右遍历</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                level<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 把每一层添加到头部，就是自底向上的层序遍历。</span>            res<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>level<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-51"><a href="#可视化-51" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-level-order-traversal-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-level-order-traversal-ii" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-level-order-traversal-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_binary-tree-zigzag-level-order-traversal">103. 二叉树的锯齿形层序遍历</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">103. 二叉树的锯齿形层序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，返回其节点值的<span>&nbsp;</span><strong style="font-weight: 600;">锯齿形层序遍历</strong><span>&nbsp;</span>。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/tree1.jpg" style="max-width: 100%; width: 277px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>[[3],[20,9],[15,7]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>[[1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = []<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 2000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 103. 二叉树的锯齿形层序遍历</a>。</strong></details><h3 id="基本思路-58"><a href="#基本思路-58" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这题和 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a> 几乎是一样的，只要用一个布尔变量 <code>flag</code> 控制遍历方向即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-57"><a href="#解法代码-57" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 为 true 时向右，false 时向左</span>        flag <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 记录这一层的节点值</span>            level <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># for 循环控制每一层从左向右遍历</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 实现 z 字形遍历</span>                <span class="token keyword">if</span> flag<span class="token punctuation">:</span>                    level<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    level<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 切换方向</span>            flag <span class="token operator">=</span> <span class="token keyword">not</span> flag            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-52"><a href="#可视化-52" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_binary-tree-zigzag-level-order-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-zigzag-level-order-traversal" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-zigzag-level-order-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/even-odd-tree">1609. 奇偶树 🟠</a></li><li><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">剑指 Offer 32 - III. 从上到下打印二叉树 III 🟠</a></li></ul><h2 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_populating-next-right-pointers-in-each-node-ii">117. 填充每个节点的下一个右侧节点指针 II</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">117. 填充每个节点的下一个右侧节点指针 II</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">struct Node {  int val;  Node *left;  Node *right;  Node *next;}</pre><p style="line-height: 1.6; overflow-wrap: break-word;">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">NULL</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">初始状态下，所有&nbsp;next 指针都被设置为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">NULL</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/02/15/117_sample.png" style="max-width: 100%; width: 500px; height: 171px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>：root = [1,2,3,4,5,null,7]<strong style="font-weight: 600;">输出：</strong>[1,#,2,3,#,4,5,7,#]<strong style="font-weight: 600;">解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = []<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 6000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">进阶：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li></ul><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 117. 填充每个节点的下一个右侧节点指针 II</a>。</strong></details><h3 id="基本思路-59"><a href="#基本思路-59" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/algorithm-summary/">我的算法学习经验</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式。</p><p>但这题和 <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node">116. 填充每个节点的下一个右侧节点指针</a> 还不一样，输入的不是完全二叉树，所以不好直接用递归。</p><p>这题用 <a href="https://labuladong.online/algo/essential-technique/bfs-framework/">BFS 算法</a> 进行层序遍历比较直观，在 for 循环，无非就是想办法遍历所有节点，然后把这个节点和相邻节点连起来罢了。</p><p>当然，还有效率更高的方式，就是直接操作指针，不过略有些难懂，暂时不写。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li><li><a href="https://labuladong.online/algo/problem-set/bfs/">【练习】BFS 经典习题 I</a></li></ul><h3 id="解法代码-58"><a href="#解法代码-58" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 二叉树层序遍历框架</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 遍历一层</span>            pre <span class="token operator">=</span> <span class="token boolean">None</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 链接当前层所有节点的 next 指针</span>                <span class="token keyword">if</span> pre <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    pre<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur                pre <span class="token operator">=</span> cur                <span class="token comment"># 将下一层节点装入队列</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_maximum-width-of-binary-tree">662. 二叉树最大宽度</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">662. 二叉树最大宽度</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，返回树的<span>&nbsp;</span><strong style="font-weight: 600;">最大宽度</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">树的<span>&nbsp;</span><strong style="font-weight: 600;">最大宽度</strong><span>&nbsp;</span>是所有层中最大的<span>&nbsp;</span><strong style="font-weight: 600;">宽度</strong><span>&nbsp;</span>。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;">每一层的<span>&nbsp;</span><strong style="font-weight: 600;">宽度</strong><span>&nbsp;</span>被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">null</code><span>&nbsp;</span>节点，这些<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">null</code><span>&nbsp;</span>节点也计入长度。</p><p style="line-height: 1.6; overflow-wrap: break-word;">题目数据保证答案将会在&nbsp;<span>&nbsp;</span><strong style="font-weight: 600;">32 位</strong><span>&nbsp;</span>带符号整数范围内。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/05/03/width1-tree.jpg" style="max-width: 100%; width: 359px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,3,2,5,3,null,9]<strong style="font-weight: 600;">输出：</strong>4<strong style="font-weight: 600;">解释：</strong>最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg" style="max-width: 100%; width: 442px; height: 422px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,3,2,5,null,null,9,6,null,7]<strong style="font-weight: 600;">输出：</strong>7<strong style="font-weight: 600;">解释：</strong>最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/05/03/width3-tree.jpg" style="max-width: 100%; width: 289px; height: 299px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,3,2,5]<strong style="font-weight: 600;">输出：</strong>2<strong style="font-weight: 600;">解释：</strong>最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 3000]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 662. 二叉树最大宽度</a>。</strong></details><h3 id="基本思路-60"><a href="#基本思路-60" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p><strong>这道题的解题关键是要给二叉树节点按行进行编号</strong>，然后你就可以通过每一行的最左侧节点和最右侧节点的编号推算出这一行的宽度，进而算出最大宽度：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/662.png" alt="img"></p><p>而且，这样编号还可以通过父节点的编号计算得出左右子节点的编号：</p><p>假设父节点的编号是 <code>x</code>，左子节点就是 <code>2 * x</code>，右子节点就是 <code>2 * x + 1</code>。</p><p>这个特性常见于完全二叉树的题目当中，你可以去看看前文 <a href="https://labuladong.online/algo/data-structure-basic/binary-heap-basic/">图文详解二叉堆，实现优先级队列</a> 或者去做一下 <a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree">1104. 二叉树寻路</a> 这道题。</p><p>明白了这个关键点，就可以通过 BFS 或者 DFS 实现解法了，我把两种解法都写出来供你参考。</p><p>其中 DFS 的递归解法需要你透彻理解二叉树的遍历顺序，你可以先做一下 <a href="https://leetcode.cn/problems/binary-tree-right-side-view">199. 二叉树的右视图</a> 这道题。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li><li><a href="https://labuladong.online/algo/problem-set/bfs/">【练习】BFS 经典习题 I</a></li></ul><h3 id="解法代码-59"><a href="#解法代码-59" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 层序遍历思路</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 记录节点和对应编号</span>    <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>node <span class="token operator">=</span> node            self<span class="token punctuation">.</span><span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">id</span>    <span class="token keyword">def</span> <span class="token function">widthOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment"># 记录最大的宽度</span>        maxWidth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 标准 BFS 层序遍历算法</span>        q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Pair<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 从上到下遍历整棵树</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            start <span class="token operator">=</span> <span class="token number">0</span>            end <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 从左到右遍历每一行</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                curNode <span class="token operator">=</span> cur<span class="token punctuation">.</span>node                curId <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">id</span>                <span class="token comment"># 记录当前行第一个和最后一个节点的编号</span>                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    start <span class="token operator">=</span> curId                <span class="token keyword">if</span> i <span class="token operator">==</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                    end <span class="token operator">=</span> curId                <span class="token comment"># 左右子节点入队，同时记录对应节点的编号</span>                <span class="token keyword">if</span> curNode<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Pair<span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">,</span> curId <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> curNode<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Pair<span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">,</span> curId <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 用当前行的宽度更新最大宽度</span>            maxWidth <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>maxWidth<span class="token punctuation">,</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> maxWidth<span class="token comment"># 递归遍历思路</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">widthOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>firstId <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>maxWidth <span class="token operator">=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxWidth    <span class="token comment"># 记录最左侧节点的编号</span>    firstId <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    maxWidth <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># 二叉树遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>firstId<span class="token punctuation">)</span> <span class="token operator">==</span> depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 因为代码是先 traverse(root.left) 后 traverse(root.right)，</span>            <span class="token comment"># 所以第一次到达这个深度一定是最左侧的节点，记录其编号</span>            self<span class="token punctuation">.</span>firstId<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 这个深度的其他节点，负责计算更新当前深度的最大宽度</span>            self<span class="token punctuation">.</span>maxWidth <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxWidth<span class="token punctuation">,</span> <span class="token builtin">id</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>firstId<span class="token punctuation">[</span>depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token builtin">id</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token builtin">id</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-53"><a href="#可视化-53" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-width-of-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-width-of-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/maximum-width-of-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree">1261. 在受污染的二叉树中查找元素 🟠</a></li></ul><h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_find-largest-value-in-each-tree-row">515. 在每个树行中找最大值</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">515. 在每个树行中找最大值</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一棵二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请找出该二叉树中每一层的最大值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/21/largest_e1.jpg" style="max-width: 100%; height: 172px; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>root = [1,3,2,5,3,null,9]<strong style="font-weight: 600;">输出: </strong>[1,3,9]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入: </strong>root = [1,2,3]<strong style="font-weight: 600;">输出: </strong>[1,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 515. 在每个树行中找最大值</a>。</strong></details><h3 id="基本思路-61"><a href="#基本思路-61" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>首先，这题肯定可以用 BFS 算法解决，for 循环里面判断最大值就行了：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/1-1754535082182-124.jpeg" alt="img"></p><p>当然，这题也可以用 DFS 来做，前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>遍历的过程中记录对应深度的最大节点值即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-60"><a href="#解法代码-60" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestValues</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>        q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sz <span class="token operator">=</span> q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 记录这一层的最大值</span>            levelMax <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>            <span class="token comment"># for 循环控制每一层从左向右遍历</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                levelMax <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>levelMax<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>levelMax<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token keyword">class</span> <span class="token class-name">Solution_DFS</span><span class="token punctuation">:</span>    <span class="token comment"># 一定要用 array 存储，因为要用索引随机访问</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">largestValues</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 遍历二叉树</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> depth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> depth<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 记录当前行的最大值</span>            self<span class="token punctuation">.</span>res<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-54"><a href="#可视化-54" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_find-largest-value-in-each-tree-row" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_find-largest-value-in-each-tree-row" src="https://labuladong.online/algo-visualize/leetcode/find-largest-value-in-each-tree-row/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/hPov7L">剑指 Offer II 044. 二叉树每层的最大值 🟠</a></li></ul><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_average-of-levels-in-binary-tree">637. 二叉树的层平均值</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">637. 二叉树的层平均值</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个非空二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;, 以数组的形式返回每一层节点的平均值。与实际答案相差&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>-5</sup></code><span>&nbsp;</span>以内的答案可以被接受。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/03/09/avg1-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]<strong style="font-weight: 600;">输出：</strong>[3.00000,14.50000,11.00000]<strong style="font-weight: 600;">解释：</strong>第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/03/09/avg2-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,15,7]<strong style="font-weight: 600;">输出：</strong>[3.00000,14.50000,11.00000]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数量在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code><span>&nbsp;</span>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 637. 二叉树的层平均值</a>。</strong></details><h3 id="基本思路-62"><a href="#基本思路-62" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>标准的二叉树层序遍历，把 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 层序遍历二叉树</a> 的代码稍微改一改就行了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-61"><a href="#解法代码-61" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 记录当前层所有节点之和</span>            <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token builtin">sum</span> <span class="token operator">+=</span> cur<span class="token punctuation">.</span>val            <span class="token comment"># 记录当前行的平均值</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">/</span> size<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-55"><a href="#可视化-55" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_average-of-levels-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_average-of-levels-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/average-of-levels-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_check-completeness-of-a-binary-tree">958. 二叉树的完全性检验</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">958. 二叉树的完全性检验</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请你判断这棵树是否是一棵<span>&nbsp;</span><strong style="font-weight: 600;">完全二叉树</strong>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">在一棵<span>&nbsp;</span><strong style="font-weight: 600;"><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">完全二叉树</a></strong><span>&nbsp;</span>中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都尽可能靠左。最后一层（第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">h</code><span>&nbsp;</span>层）中可以包含&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2<sup>h</sup></code><span>&nbsp;</span>个节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6]<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>最后一层前的每一层都是满的（即，节点值为 {1} 和 {2,3} 的两层），且最后一层中的所有节点（{4,5,6}）尽可能靠左。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png" style="max-width: 100%;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,null,7]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>值为 7 的节点不满足条件「节点尽可能靠左」。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 958. 二叉树的完全性检验</a>。</strong></details><h3 id="基本思路-63"><a href="#基本思路-63" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-7">基本思路</a></h3><p>这题的关键是对完全二叉树特性的理解，<strong>如果按照 BFS 层序遍历的方式遍历完全二叉树，队列最后留下的应该都是空指针</strong>：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/958.jpeg" alt="img"></p><p>所以可以用 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a> 给出的层序遍历框架解决这题。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-62"><a href="#解法代码-62" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-7">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isCompleteTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        end <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> cur <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    end <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> end<span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-56"><a href="#可视化-56" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-6">可视化</a></h3><details data-v-ee1a9bd0="" id="div_check-completeness-of-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_check-completeness-of-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/check-completeness-of-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1161-最大层内元素和"><a href="#1161-最大层内元素和" class="headerlink" title="1161. 最大层内元素和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_maximum-level-sum-of-a-binary-tree">1161. 最大层内元素和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1161. 最大层内元素和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>。设根节点位于二叉树的第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>层，而根节点的子节点位于第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>层，依此类推。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请返回层内元素之和<span>&nbsp;</span><strong style="font-weight: 600;">最大</strong><span>&nbsp;</span>的那几层（可能只有一层）的层号，并返回其中&nbsp;<strong style="font-weight: 600;">最小</strong><span>&nbsp;</span>的那个。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/08/17/capture.jpeg" style="max-width: 100%; height: 175px; width: 200px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,7,0,7,-8,null,null]<strong style="font-weight: 600;">输出：</strong>2<strong style="font-weight: 600;">解释：</strong>第 1 层各元素之和为 1，第 2 层各元素之和为 7 + 0 = 7，第 3 层各元素之和为 7 + -8 = -1，所以我们返回第 2 层的层号，它的层内元素之和最大。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [989,null,10250,98693,-89388,null,null,null,-32127]<strong style="font-weight: 600;">输出：</strong>2</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1161. 最大层内元素和</a>。</strong></details><h3 id="基本思路-64"><a href="#基本思路-64" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-8">基本思路</a></h3><p>把 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a> 给出的层序遍历框架稍微变通即可解决这题。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-63"><a href="#解法代码-63" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-8">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxLevelSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 记录 BFS 走到的层数</span>        depth <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment"># 记录元素和最大的那一行和最大元素和</span>        res <span class="token operator">=</span> <span class="token number">0</span>        maxSum <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            levelSum <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 遍历这一层</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                levelSum <span class="token operator">+=</span> cur<span class="token punctuation">.</span>val                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> levelSum <span class="token operator">></span> maxSum<span class="token punctuation">:</span>                <span class="token comment"># 更新最大元素和</span>                res <span class="token operator">=</span> depth                maxSum <span class="token operator">=</span> levelSum            depth <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-57"><a href="#可视化-57" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-7">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-level-sum-of-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-level-sum-of-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/maximum-level-sum-of-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1302-层数最深叶子节点的和"><a href="#1302-层数最深叶子节点的和" class="headerlink" title="1302. 层数最深叶子节点的和"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_deepest-leaves-sum">1302. 层数最深叶子节点的和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1302. 层数最深叶子节点的和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/deepest-leaves-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/deepest-leaves-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请你返回<span>&nbsp;</span><strong style="font-weight: 600;">层数最深的叶子节点的和</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png" style="max-width: 100%; height: 265px; width: 273px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,null,6,7,null,null,null,null,8]<strong style="font-weight: 600;">输出：</strong>15</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<strong style="font-weight: 600;">输出：</strong>19</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code><span>&nbsp;</span>之间。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/deepest-leaves-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1302. 层数最深叶子节点的和</a>。</strong></details><h3 id="基本思路-65"><a href="#基本思路-65" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-9">基本思路</a></h3><p>这题用 DFS 或者 BFS 都可以，我就用 BFS 层序遍历算法吧，层序遍历算法参见 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 层序遍历二叉树</a>，这题只要把最后一层的节点值累加起来就行了。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-64"><a href="#解法代码-64" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-9">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deepestLeavesSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 累加一层的节点之和</span>                <span class="token builtin">sum</span> <span class="token operator">+=</span> cur<span class="token punctuation">.</span>val                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 现在就是最后一层的节点值和</span>        <span class="token keyword">return</span> <span class="token builtin">sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-58"><a href="#可视化-58" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-8">可视化</a></h3><details data-v-ee1a9bd0="" id="div_deepest-leaves-sum" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_deepest-leaves-sum" src="https://labuladong.online/algo-visualize/leetcode/deepest-leaves-sum/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1609-奇偶树"><a href="#1609-奇偶树" class="headerlink" title="1609. 奇偶树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#slug_even-odd-tree">1609. 奇偶树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1609. 奇偶树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/even-odd-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/even-odd-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">如果一棵二叉树满足下述几个条件，则可以称为<span>&nbsp;</span><strong style="font-weight: 600;">奇偶树</strong><span>&nbsp;</span>：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树根节点所在层下标为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>，根的子节点所在层下标为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>，根的孙节点所在层下标为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>，依此类推。</li><li><strong style="font-weight: 600;">偶数下标</strong><span>&nbsp;</span>层上的所有节点的值都是<span>&nbsp;</span><strong style="font-weight: 600;">奇</strong><span>&nbsp;</span>整数，从左到右按顺序<span>&nbsp;</span><strong style="font-weight: 600;">严格递增</strong></li><li><strong style="font-weight: 600;">奇数下标</strong><span>&nbsp;</span>层上的所有节点的值都是<span>&nbsp;</span><strong style="font-weight: 600;">偶</strong><span>&nbsp;</span>整数，从左到右按顺序<span>&nbsp;</span><strong style="font-weight: 600;">严格递减</strong></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根节点，如果二叉树为<span>&nbsp;</span><strong style="font-weight: 600;">奇偶树<span>&nbsp;</span></strong>，则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png" style="max-width: 100%; height: 229px; width: 362px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>每一层的节点值分别是：0 层：[1]1 层：[10,4]2 层：[3,7,9]3 层：[12,8,6,2]由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png" style="max-width: 100%; height: 167px; width: 363px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,4,2,3,3,7]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>每一层的节点值分别是：0 层：[5]1 层：[4,2]2 层：[3,3,7]2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png" style="max-width: 100%; height: 167px; width: 363px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,9,1,3,5,7]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>1 层上的节点值应为偶数。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 5：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>5</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/even-odd-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1609. 奇偶树</a>。</strong></details><h3 id="基本思路-66"><a href="#基本思路-66" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-10">基本思路</a></h3><p>这道题主要考察二叉树的层序遍历，你可以先做一下 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a> 和 <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal">103. 二叉树的锯齿形层序遍历</a> 这两道题，然后再做这道题。具体思路可看解法代码的注释。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/">【练习】运用层序遍历解题 I</a></li></ul><h3 id="解法代码-65"><a href="#解法代码-65" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-10">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isEvenOddTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 记录奇偶层数</span>        even <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token comment"># while 循环控制从上向下一层层遍历</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token comment"># 记录前一个节点，便于判断是否递增/递减</span>            prev <span class="token operator">=</span> <span class="token operator">-</span>sys<span class="token punctuation">.</span>maxsize <span class="token keyword">if</span> even <span class="token keyword">else</span> sys<span class="token punctuation">.</span>maxsize            <span class="token comment"># for 循环控制每一层从左向右遍历</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> even<span class="token punctuation">:</span>                    <span class="token comment"># 偶数层</span>                    <span class="token keyword">if</span> prev <span class="token operator">>=</span> cur<span class="token punctuation">.</span>val <span class="token keyword">or</span> cur<span class="token punctuation">.</span>val <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token comment"># 奇数层</span>                    <span class="token keyword">if</span> prev <span class="token operator">&lt;=</span> cur<span class="token punctuation">.</span>val <span class="token keyword">or</span> cur<span class="token punctuation">.</span>val <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                prev <span class="token operator">=</span> cur<span class="token punctuation">.</span>val                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 奇偶层数切换</span>            even <span class="token operator">=</span> <span class="token keyword">not</span> even        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-59"><a href="#可视化-59" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-i/#%E5%8F%AF%E8%A7%86%E5%8C%96-9">可视化</a></h3><details data-v-ee1a9bd0="" id="div_even-odd-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_even-odd-tree" src="https://labuladong.online/algo-visualize/leetcode/even-odd-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="919-完全二叉树插入器"><a href="#919-完全二叉树插入器" class="headerlink" title="919. 完全二叉树插入器"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#slug_complete-binary-tree-inserter">919. 完全二叉树插入器</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">919. 完全二叉树插入器</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/complete-binary-tree-inserter/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/complete-binary-tree-inserter/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">完全二叉树</strong><span>&nbsp;</span>是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p><p style="line-height: 1.6; overflow-wrap: break-word;">设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">CBTInserter</code><span>&nbsp;</span>类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">CBTInserter(TreeNode root)</code>&nbsp;使用头节点为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的给定树初始化该数据结构；</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">CBTInserter.insert(int v)</code>&nbsp; 向树中插入一个值为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val == val</code>的新节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">TreeNode</code>。使树保持完全二叉树的状态，<strong style="font-weight: 600;">并返回插入节点</strong>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">TreeNode</code>&nbsp;<strong style="font-weight: 600;">的父节点的值</strong>；</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">CBTInserter.get_root()</code><span>&nbsp;</span>将返回树的头节点。</li></ul><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/03/lc-treeinsert.jpg" style="max-width: 100%; height: 143px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>["CBTInserter", "insert", "insert", "get_root"][[[1, 2]], [3], [4], []]<strong style="font-weight: 600;">输出</strong>[null, 1, 2, [1, 2, 3, 4]]<p><strong style="font-weight: 600;">解释</strong><br>CBTInserter cBTInserter &#x3D; new CBTInserter([1, 2]);<br>cBTInserter.insert(3);  &#x2F;&#x2F; 返回 1<br>cBTInserter.insert(4);  &#x2F;&#x2F; 返回 2<br>cBTInserter.get_root(); &#x2F;&#x2F; 返回 [1, 2, 3, 4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数量范围为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 5000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;是完全二叉树</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= val &lt;= 5000</code>&nbsp;</li><li>每个测试用例最多调用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">insert</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">get_root</code>&nbsp;操作&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code>&nbsp;次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/complete-binary-tree-inserter/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 919. 完全二叉树插入器</a>。</strong></details></p><h3 id="基本思路-67"><a href="#基本思路-67" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这道题考察二叉树的层序遍历，你需要先做 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a> 再做这道题，用队列维护底部可以进行插入的节点即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bfs/">【练习】BFS 经典习题 I</a></li><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/">【练习】运用层序遍历解题 II</a></li></ul><h3 id="解法代码-66"><a href="#解法代码-66" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">class</span> <span class="token class-name">CBTInserter</span><span class="token punctuation">:</span>    <span class="token comment"># 这个队列只记录完全二叉树底部可以进行插入的节点</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>root <span class="token operator">=</span> root        <span class="token comment"># 进行普通的 BFS，目的是找到底部可插入的节点</span>        temp <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>        temp<span class="token punctuation">.</span>put<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token keyword">not</span> temp<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                temp<span class="token punctuation">.</span>put<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                temp<span class="token punctuation">.</span>put<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token comment"># 找到完全二叉树底部可以进行插入的节点</span>                self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        cur <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 进行插入</span>        <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            cur<span class="token punctuation">.</span>left <span class="token operator">=</span> node        <span class="token keyword">else</span><span class="token punctuation">:</span>            cur<span class="token punctuation">.</span>right <span class="token operator">=</span> node            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 新节点的左右节点也是可以插入的</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span> cur<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">get_root</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-60"><a href="#可视化-60" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_complete-binary-tree-inserter" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_complete-binary-tree-inserter" src="https://labuladong.online/algo-visualize/leetcode/complete-binary-tree-inserter/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#slug_leaf-similar-trees">872. 叶子相似的树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">872. 叶子相似的树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/leaf-similar-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/leaf-similar-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个&nbsp;<strong style="font-weight: 600;">叶值序列<span>&nbsp;</span></strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/07/16/tree.png" style="max-width: 100%; height: 336px; width: 400px;"></p><p style="line-height: 1.6; overflow-wrap: break-word;">举个例子，如上图所示，给定一棵叶值序列为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(6, 7, 4, 9, 8)</code>&nbsp;的树。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是&nbsp;<em>叶相似&nbsp;</em>的。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果给定的两个根结点分别为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root1</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root2</code>&nbsp;的树是叶相似的，则返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>；否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/09/03/leaf-similar-1.jpg" style="max-width: 100%; height: 237px; width: 600px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/09/03/leaf-similar-2.jpg" style="max-width: 100%; height: 110px; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [1,2,3], root2 = [1,3,2]<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定的两棵树结点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 200]</code><span>&nbsp;</span>范围内</li><li>给定的两棵树上的值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 200]</code><span>&nbsp;</span>范围内</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/leaf-similar-trees/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 872. 叶子相似的树</a>。</strong></details><h3 id="基本思路-68"><a href="#基本思路-68" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>最简单粗暴的方式就是遍历两个二叉树，把所有叶子节点都取出来，然后一个个对比。稍微有点技巧性的解法就是把递归改成栈迭代的形式。</p><p>你看这个 <code>next</code> 方法，它和二叉树的递归遍历框架很像，只不过把递归函数改成了栈操作；它和层序遍历的框架也很像，只不过把队列换成了栈，是不是挺有意思的？这个解法相当于就是用栈模拟了递归，对这棵二叉树进行前序遍历。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/">【练习】运用层序遍历解题 II</a></li></ul><h3 id="解法代码-67"><a href="#解法代码-67" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">leafSimilar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        it1 <span class="token operator">=</span> LeafIterator<span class="token punctuation">(</span>root1<span class="token punctuation">)</span>        it2 <span class="token operator">=</span> LeafIterator<span class="token punctuation">(</span>root2<span class="token punctuation">)</span>        <span class="token comment"># 逐一对比叶子节点</span>        <span class="token keyword">while</span> it1<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> it2<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> it1<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val <span class="token operator">!=</span> it2<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 最后应该都完成遍历</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> it1<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> it2<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 一个生成二叉树叶子节点的迭代器</span><span class="token keyword">class</span> <span class="token class-name">LeafIterator</span><span class="token punctuation">:</span>    <span class="token comment"># 模拟递归过程</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            cur <span class="token operator">=</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token comment"># 发现一个叶子结点</span>                <span class="token keyword">return</span> cur            <span class="token comment"># 先入栈 root.right</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip</p><p>如果让你从二叉树中的非根节点开始遍历，怎么做呢？其实可以用 map 记录子节点到父节点的映射，从而把二叉树转化成一幅图，然后再编写算法。</p><h2 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#slug_all-nodes-distance-k-in-binary-tree">863. 二叉树中所有距离为 K 的结点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">863. 二叉树中所有距离为 K 的结点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树（具有根结点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>），&nbsp;一个目标结点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;，和一个整数值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code>&nbsp;，返回到目标结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code><span>&nbsp;</span>距离为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>的所有结点的值的数组。</p><p style="line-height: 1.6; overflow-wrap: break-word;">答案可以以<span>&nbsp;</span><strong style="font-weight: 600;">任何顺序</strong><span>&nbsp;</span>返回。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2018/06/28/sketch0.png" style="max-width: 100%; height: 429px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2<strong style="font-weight: 600;">输出：</strong>[7,4,1]<strong style="font-weight: 600;">解释：</strong>所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [1], target = 1, k = 3<strong style="font-weight: 600;">输出:</strong> []</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 500]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 500</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;中所有值<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong></li><li>目标结点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;是树上的结点。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= k &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 863. 二叉树中所有距离为 K 的结点</a>。</strong></details><h3 id="基本思路-69"><a href="#基本思路-69" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这道题常规的解法就是把二叉树变成一幅「图」，然后在图中用 BFS 算法求距离 <code>target</code> 节点 <code>k</code> 步的所有节点。</p><p>关于 BFS 算法的原理，见 <a href="https://labuladong.online/algo/essential-technique/bfs-framework/">BFS 算法核心框架套路</a>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bfs/">【练习】BFS 经典习题 I</a></li><li><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/">【练习】运用层序遍历解题 II</a></li></ul><h3 id="解法代码-68"><a href="#解法代码-68" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 记录父节点：node.val -> parentNode</span>    <span class="token comment"># 题目说了树中所有节点值都是唯一的，所以可以用 node.val 代表 TreeNode</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">distanceK</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> target<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 遍历所有节点，记录每个节点的父节点</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        <span class="token comment"># 开始从 target 节点施放 BFS 算法，找到距离为 k 的节点</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>target<span class="token punctuation">)</span>        visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>target<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 记录离 target 的距离</span>        dist <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> dist <span class="token operator">==</span> k<span class="token punctuation">:</span>                    <span class="token comment"># 找到距离起点 target 距离为 k 的节点</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token comment"># 向父节点、左右子节点扩散</span>                parentNode <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>get<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> parentNode <span class="token keyword">and</span> parentNode<span class="token punctuation">.</span>val <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>parentNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parentNode<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">and</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right <span class="token keyword">and</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 向外扩展一圈</span>            dist <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> parentNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> parentNode        <span class="token comment"># 二叉树递归框架</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-61"><a href="#可视化-61" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/binary-tree-level-ii/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_all-nodes-distance-k-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_all-nodes-distance-k-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/all-nodes-distance-k-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/closest-leaf-in-a-binary-tree">742. 二叉树最近的叶节点 🟠</a></li></ul><h1 id="【练习】二叉搜索树经典例题-I"><a href="#【练习】二叉搜索树经典例题-I" class="headerlink" title="【练习】二叉搜索树经典例题 I"></a>【练习】二叉搜索树经典例题 I</h1><h2 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_recover-binary-search-tree">99. 恢复二叉搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">99. 恢复二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/recover-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/recover-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉搜索树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，该树中的<span>&nbsp;</span><strong style="font-weight: 600;">恰好</strong><span>&nbsp;</span>两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树&nbsp;</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/28/recover1.jpg" style="max-width: 100%; width: 300px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,3,null,null,2]<strong style="font-weight: 600;">输出：</strong>[3,1,null,null,2]<strong style="font-weight: 600;">解释：</strong>3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/28/recover2.jpg" style="max-width: 100%; height: 208px; width: 400px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,1,4,null,null,2]<strong style="font-weight: 600;">输出：</strong>[2,1,4,null,null,3]<strong style="font-weight: 600;">解释：</strong>2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树上节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[2, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>使用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(n)</code><span>&nbsp;</span>空间复杂度的解法很容易实现。你能想出一个只使用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(1)</code><span>&nbsp;</span>空间的解决方案吗？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/recover-binary-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 99. 恢复二叉搜索树</a>。</strong></details><h3 id="基本思路-70"><a href="#基本思路-70" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维模式。</p><p>得益于二叉搜索树左小右大的特性，一个重要性质是：二叉搜索树的中序遍历结果有序。</p><p>题目说有两个节点的值反了，也就是说中序遍历结果不再是有序的，有两个元素的位置反了。</p><p>那么我们在中序遍历的时候找到破坏有序性的这两个元素，交换它们即可。</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/1.jpg" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-69"><a href="#解法代码-69" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 分别记录这两个被交换的节点</span>    first <span class="token operator">=</span> <span class="token boolean">None</span>    second <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 判断中序遍历的有序性</span>    prev <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>inorderTraverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        temp <span class="token operator">=</span> self<span class="token punctuation">.</span>first<span class="token punctuation">.</span>val        self<span class="token punctuation">.</span>first<span class="token punctuation">.</span>val <span class="token operator">=</span> self<span class="token punctuation">.</span>second<span class="token punctuation">.</span>val        self<span class="token punctuation">.</span>second<span class="token punctuation">.</span>val <span class="token operator">=</span> temp    <span class="token keyword">def</span> <span class="token function">inorderTraverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>inorderTraverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token comment"># 中序代码位置，找出那两个节点</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token comment"># root 不符合有序性</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token comment"># 第一个错位节点是 prev</span>                self<span class="token punctuation">.</span>first <span class="token operator">=</span> self<span class="token punctuation">.</span>prev            <span class="token comment"># 第二个错位节点是 root</span>            self<span class="token punctuation">.</span>second <span class="token operator">=</span> root        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> root        self<span class="token punctuation">.</span>inorderTraverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-62"><a href="#可视化-62" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_recover-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_recover-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/recover-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_trim-a-binary-search-tree">669. 修剪二叉搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">669. 修剪二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/trim-a-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉搜索树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，同时给定最小边界<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">low</code><span>&nbsp;</span>和最大边界<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">high</code>。通过修剪二叉搜索树，使得所有节点的值在<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[low, high]</code>中。修剪树<span>&nbsp;</span><strong style="font-weight: 600;">不应该</strong>&nbsp;改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在&nbsp;<strong style="font-weight: 600;">唯一的答案</strong>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/09/09/trim1.jpg" style="max-width: 100%; height: 126px; width: 450px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,2], low = 1, high = 2<strong style="font-weight: 600;">输出：</strong>[1,null,2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/09/09/trim2.jpg" style="max-width: 100%; height: 277px; width: 450px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,0,4,null,2,null,null,1], low = 1, high = 3<strong style="font-weight: 600;">输出：</strong>[3,2,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li><li>树中每个节点的值都是<span>&nbsp;</span><strong style="font-weight: 600;">唯一</strong><span>&nbsp;</span>的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 669. 修剪二叉搜索树</a>。</strong></details><h3 id="基本思路-71"><a href="#基本思路-71" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>明确了递归函数的定义之后进行思考，如果一个节点的值没有落在 <code>[lo, hi]</code> 中，有两种情况：</p><p>1、<strong><code>root.val &lt; lo</code>，这种情况下 <code>root</code> 节点本身和 <code>root</code> 的左子树全都是小于 <code>lo</code> 的，都需要被剪掉</strong>。</p><p>2、<strong><code>root.val &gt; hi</code>，这种情况下 <code>root</code> 节点本身和 <code>root</code> 的右子树全都是大于 <code>hi</code> 的，都需要被剪掉</strong>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-70"><a href="#解法代码-70" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST</span>    <span class="token keyword">def</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">:</span>            <span class="token comment"># 直接返回 root.right</span>            <span class="token comment"># 等于删除 root 以及 root 的左子树</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> high<span class="token punctuation">:</span>            <span class="token comment"># 直接返回 root.left</span>            <span class="token comment"># 等于删除 root 以及 root 的右子树</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token comment"># 闭区间 [lo, hi] 内的节点什么都不做</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-63"><a href="#可视化-63" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_trim-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_trim-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/trim-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/split-bst">776. 拆分二叉搜索树 🟠</a></li></ul><h2 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_second-minimum-node-in-a-binary-tree">671. 二叉树中第二小的节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">671. 二叉树中第二小的节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code>&nbsp;或&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p style="line-height: 1.6; overflow-wrap: break-word;">更正式地说，即&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root.val = min(root.left.val, root.right.val)</code><span>&nbsp;</span>总成立。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给出这样的一个二叉树，你需要输出所有节点中的&nbsp;<strong style="font-weight: 600;">第二小的值<span>&nbsp;</span></strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果第二小的值不存在的话，输出 -1<span>&nbsp;</span><strong style="font-weight: 600;">。</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/15/smbt1.jpg" style="max-width: 100%; height: 210px; width: 300px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,2,5,null,null,5,7]<strong style="font-weight: 600;">输出：</strong>5<strong style="font-weight: 600;">解释：</strong>最小的值是 2 ，第二小的值是 5 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/15/smbt2.jpg" style="max-width: 100%; height: 113px; width: 200px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,2,2]<strong style="font-weight: 600;">输出：</strong>-1<strong style="font-weight: 600;">解释：</strong>最小的值是 2, 但是不存在第二小的值。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 25]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li><li>对于树中每个节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root.val == min(root.left.val, root.right.val)</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 671. 二叉树中第二小的节点</a>。</strong></details><h3 id="基本思路-72"><a href="#基本思路-72" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>这题很有意思，按照这棵二叉树的特性，根节点无疑是最小的那个元素，但问题是第二小的那个元素在哪里呢？</p><p>如果根节点的左右子节点的值不同，根节点的值就是较小的那个节点（假设是左子节点）的值，那么较大的那个节点（右子节点）的值是不是就一定是第二小的那个元素？</p><p>不一定，第二小的值也可能在左子树中，这个节点是左子树中第二小的节点：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/671_1.png" alt="img"></p><p>类似的道理，如果根节点的左右子节点相同，那么需要把左右子树的第二小元素计算出来，比较其中较小的元素，作为整棵树的第二小元素：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/671_2.png" alt="img"></p><p>如何计算子树中的第二小元素？函数 <code>findSecondMinimumValue</code> 就是干这个的，递归调用子树即可算出来。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-71"><a href="#解法代码-71" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入一棵二叉树，返回这棵二叉树中第二小的节点值</span>    <span class="token keyword">def</span> <span class="token function">findSecondMinimumValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token comment"># 左右子节点中不同于 root.val 的那个值可能是第二小的值</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val        <span class="token comment"># 如果左右子节点都等于 root.val，则去左右子树递归寻找第二小的值</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            left <span class="token operator">=</span> self<span class="token punctuation">.</span>findSecondMinimumValue<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            right <span class="token operator">=</span> self<span class="token punctuation">.</span>findSecondMinimumValue<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> right        <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> left        <span class="token comment"># 如果左右子树都找到一个第二小的值，更小的那个是整棵树的第二小元素</span>        <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-64"><a href="#可视化-64" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_second-minimum-node-in-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_second-minimum-node-in-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/second-minimum-node-in-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_find-mode-in-binary-search-tree">501. 二叉搜索树中的众数</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">501. 二叉搜索树中的众数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个含重复值的二叉搜索树（BST）的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，找出并返回 BST 中的所有<span>&nbsp;</span><a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">众数</a>（即，出现频率最高的元素）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果树中有不止一个众数，可以按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>返回。</p><p style="line-height: 1.6; overflow-wrap: break-word;">假定 BST 满足如下定义：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>结点左子树中所含节点的值<span>&nbsp;</span><strong style="font-weight: 600;">小于等于</strong><span>&nbsp;</span>当前节点的值</li><li>结点右子树中所含节点的值<span>&nbsp;</span><strong style="font-weight: 600;">大于等于</strong><span>&nbsp;</span>当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/03/11/mode-tree.jpg" style="max-width: 100%; width: 142px; height: 222px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,2,2]<strong style="font-weight: 600;">输出：</strong>[2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0]<strong style="font-weight: 600;">输出：</strong>[0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 501. 二叉搜索树中的众数</a>。</strong></details><h3 id="基本思路-73"><a href="#基本思路-73" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>BST 的中序遍历有序，在中序遍历的位置做一些判断逻辑和操作有序数组差不多，很容易找出众数。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-72"><a href="#解法代码-72" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token comment"># 当前元素的重复次数</span>        self<span class="token punctuation">.</span>curCount <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 全局的最长相同序列长度</span>        self<span class="token punctuation">.</span>maxCount <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">findMode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 执行中序遍历</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>mode    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token comment"># 中序遍历位置</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>prev <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 初始化</span>            self<span class="token punctuation">.</span>curCount <span class="token operator">=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>maxCount <span class="token operator">=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>mode<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> self<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token comment"># root.val 重复的情况</span>                self<span class="token punctuation">.</span>curCount <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>curCount <span class="token operator">==</span> self<span class="token punctuation">.</span>maxCount<span class="token punctuation">:</span>                    <span class="token comment"># root.val 是众数</span>                    self<span class="token punctuation">.</span>mode<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">elif</span> self<span class="token punctuation">.</span>curCount <span class="token operator">></span> self<span class="token punctuation">.</span>maxCount<span class="token punctuation">:</span>                    <span class="token comment"># 更新众数</span>                    self<span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>maxCount <span class="token operator">=</span> self<span class="token punctuation">.</span>curCount                    self<span class="token punctuation">.</span>mode<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># root.val 不重复的情况</span>                self<span class="token punctuation">.</span>curCount <span class="token operator">=</span> <span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>curCount <span class="token operator">==</span> self<span class="token punctuation">.</span>maxCount<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>mode<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token comment"># 别忘了更新 prev</span>        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> root        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-65"><a href="#可视化-65" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_find-mode-in-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_find-mode-in-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/find-mode-in-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_minimum-absolute-difference-in-bst">530. 二叉搜索树的最小绝对差</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">530. 二叉搜索树的最小绝对差</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉搜索树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，返回<span>&nbsp;</span><strong style="font-weight: 600;">树中任意两不同节点值之间的最小差值</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">差值是一个正数，其数值等于两值之差的绝对值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/05/bst1.jpg" style="max-width: 100%; width: 292px; height: 301px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,2,6,1,3]<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/05/bst2.jpg" style="max-width: 100%; width: 282px; height: 301px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,48,null,null,12,49]<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[2, 10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">注意：</strong>本题与 783<span>&nbsp;</span><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" class="" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a><span>&nbsp;</span>相同</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 530. 二叉搜索树的最小绝对差</a>。</strong></details><h3 id="基本思路-74"><a href="#基本思路-74" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。</p><p>记住，看到一棵 BST，你就把它理解是一个有序数组就行了，只是遍历方式不同罢了。所以这道题的思路就很简单，用中序遍历遍历一遍 BST 的所有节点得到有序结果，然后在遍历过程中计算最小差值即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-73"><a href="#解法代码-73" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token comment"># 遍历函数</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token comment"># 中序遍历位置</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>prev <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val <span class="token operator">-</span> self<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> root        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-66"><a href="#可视化-66" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_minimum-absolute-difference-in-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_minimum-absolute-difference-in-bst" src="https://labuladong.online/algo-visualize/leetcode/minimum-absolute-difference-in-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/minimum-distance-between-bst-nodes">783. 二叉搜索树节点最小距离 🟢</a></li></ul><h2 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_two-sum-iv-input-is-a-bst">653. 两数之和 IV - 输入 BST</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">653. 两数之和 IV - 输入二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉搜索树<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>和一个目标结果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code>，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/09/21/sum_tree_1.jpg" style="max-width: 100%; height: 229px; width: 400px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [5,3,6,2,4,null,7], k = 9<strong style="font-weight: 600;">输出:</strong> true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/09/21/sum_tree_2.jpg" style="max-width: 100%; height: 229px; width: 400px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [5,3,6,2,4,null,7], k = 28<strong style="font-weight: 600;">输出:</strong> false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是&nbsp;&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>.</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li><li>题目数据保证，输入的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>是一棵<span>&nbsp;</span><strong style="font-weight: 600;">有效</strong><span>&nbsp;</span>的二叉搜索树</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 653. 两数之和 IV - 输入二叉搜索树</a>。</strong></details><h3 id="基本思路-75"><a href="#基本思路-75" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>这道题的思路蛮多的，我们就利用 BST 中序遍历有序这个性质外加 <a href="https://labuladong.online/algo/practice-in-action/nsum/">一个函数秒杀 nSum 问题</a> 中的双指针思路来解决吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-74"><a href="#解法代码-74" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 转化成有序数组</span>        arr <span class="token operator">=</span> self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 有序数组中的左右双指针</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>            sum_val <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">if</span> sum_val <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                <span class="token comment"># sum 调大一点</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> sum_val <span class="token operator">></span> k<span class="token punctuation">:</span>                <span class="token comment"># sum 调小一点</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment"># 返回中序遍历结果</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-67"><a href="#可视化-67" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96-5">可视化</a></h3><details data-v-ee1a9bd0="" id="div_two-sum-iv-input-is-a-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_two-sum-iv-input-is-a-bst" src="https://labuladong.online/algo-visualize/leetcode/two-sum-iv-input-is-a-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/opLdQZ">剑指 Offer II 056. 二叉搜索树中两个节点之和 🟢</a></li></ul><h2 id="1008-前序遍历构造二叉搜索树"><a href="#1008-前序遍历构造二叉搜索树" class="headerlink" title="1008. 前序遍历构造二叉搜索树"></a><a href="https://labuladong.online/algo/problem-set/bst1/#slug_construct-binary-search-tree-from-preorder-traversal">1008. 前序遍历构造二叉搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1008. 前序遍历构造二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个整数数组，它表示BST(即<span>&nbsp;</span><strong style="font-weight: 600;">二叉搜索树</strong><span>&nbsp;</span>)的<span>&nbsp;</span><strong style="font-weight: 600;">先</strong><strong style="font-weight: 600;">序遍历</strong><span>&nbsp;</span>，构造树并返回其根。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">二叉搜索树</strong><span>&nbsp;</span>是一棵二叉树，其中每个节点，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.left</code>&nbsp;的任何后代的值<span>&nbsp;</span><strong style="font-weight: 600;">严格小于</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.right</code>&nbsp;的任何后代的值<span>&nbsp;</span><strong style="font-weight: 600;">严格大于</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">前序遍历</strong><span>&nbsp;</span>首先显示节点的值，然后遍历<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.left</code>，最后遍历<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.right</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/03/06/1266.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>preorder = [8,5,1,7,10,12]<strong style="font-weight: 600;">输出：</strong>[8,5,10,1,7,null,12]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> preorder = [1,3]<strong style="font-weight: 600;">输出:</strong> [1,null,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= preorder.length &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= preorder[i]&nbsp;&lt;= 10^8</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">preorder</code><span>&nbsp;</span>中的值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1008. 前序遍历构造二叉搜索树</a>。</strong></details><h3 id="基本思路-76"><a href="#基本思路-76" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。</p><p>前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树的花式构造</a> 和 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">二叉树的序列化和反序列化</a> 说过，生成二叉树的题目，无非就是先生成根节点，然后递归生成左右子树，最后把根节点和左右子树连接起来。<strong>具体区别在于你如何找到根节点，如何划分左右子树</strong>。</p><p>根据前序遍历的特点是，根节点在第一位，后面接着左子树和右子树；BST 的特点，左子树都比根节点的值小，右子树都比根节点的值大。</p><p>所以如何找到根节点？前序遍历的第一个就是根节点。</p><p>如何找到左右子树？比根节点小的就是左子树的节点，比根节点大的就是右子树的节点。</p><p>最后，确定清楚 <code>build</code> 函数的定义，利用这个函数递归生成 BST 即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst1/">【练习】二叉搜索树经典例题 I</a></li></ul><h3 id="解法代码-75"><a href="#解法代码-75" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bstFromPreorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 定义：将 preorder[start..end] 区间内的元素生成 BST，并返回根节点</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">></span> end<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 根据前序遍历的特点，根节点在第一位，后面接着左子树和右子树</span>        rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>start<span class="token punctuation">]</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>        <span class="token comment"># 根据 BST 的特点，左子树都比根节点的值小，右子树都比根节点的值大</span>        <span class="token comment"># p 就是左右子树的分界点</span>        p <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;=</span> end <span class="token keyword">and</span> preorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rootVal<span class="token punctuation">:</span>            p <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># [start+1, p-1] 区间内是左子树元素</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># [p, end] 区间内是右子树元素</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> p<span class="token punctuation">,</span> end<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-68"><a href="#可视化-68" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst1/#%E5%8F%AF%E8%A7%86%E5%8C%96-6">可视化</a></h3><details data-v-ee1a9bd0="" id="div_construct-binary-search-tree-from-preorder-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_construct-binary-search-tree-from-preorder-traversal" src="https://labuladong.online/algo-visualize/leetcode/construct-binary-search-tree-from-preorder-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree">255. 验证前序遍历序列二叉搜索树 🟠</a></li></ul><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://labuladong.online/algo/problem-set/bst2/#slug_convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">108. 将有序数组转换为二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>，其中元素已经按<span>&nbsp;</span><strong style="font-weight: 600;">升序</strong><span>&nbsp;</span>排列，请你将其转换为一棵<span>&nbsp;</span><span data-keyword="height-balanced">平衡</span><span>&nbsp;</span>二叉搜索树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/18/btree1.jpg" style="max-width: 100%; width: 302px; height: 222px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [-10,-3,0,5,9]<strong style="font-weight: 600;">输出：</strong>[0,-3,9,-10,null,5]<strong style="font-weight: 600;">解释：</strong>[0,-10,5,null,-3,null,9] 也将被视为正确答案：<img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/18/btree2.jpg" style="max-width: 100%; width: 302px; height: 222px;"></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/18/btree.jpg" style="max-width: 100%; width: 342px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,3]<strong style="font-weight: 600;">输出：</strong>[3,1]<strong style="font-weight: 600;">解释：</strong>[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>按<span>&nbsp;</span><strong style="font-weight: 600;">严格递增</strong><span>&nbsp;</span>顺序排列</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 108. 将有序数组转换为二叉搜索树</a>。</strong></details><h3 id="基本思路-77"><a href="#基本思路-77" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树总结篇</a> 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维模式。</p><p>二叉树的构建问题遵循固定的套路，构造整棵树可以分解成：先构造根节点，然后构建左右子树。</p><p>一个有序数组对于 BST 来说就是中序遍历结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst2/">【练习】二叉搜索树经典例题 II</a></li></ul><h3 id="解法代码-76"><a href="#解法代码-76" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 将闭区间 [left, right] 中的元素转化成 BST，返回根节点</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token operator">></span> right<span class="token punctuation">:</span>            <span class="token comment"># 区间为空</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 构造根节点</span>        <span class="token comment"># BST 节点左小右大，中间的元素就是根节点</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 递归构建左子树</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 递归构造右子树</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-69"><a href="#可视化-69" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_convert-sorted-array-to-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_convert-sorted-array-to-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/convert-sorted-array-to-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree">109. 有序链表转换二叉搜索树 🟠</a></li><li><a href="https://leetcode.cn/problems/balance-a-binary-search-tree">1382. 将二叉搜索树变平衡 🟠</a></li></ul><h2 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382. 将二叉搜索树变平衡"></a><a href="https://labuladong.online/algo/problem-set/bst2/#slug_balance-a-binary-search-tree">1382. 将二叉搜索树变平衡</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1382. 将二叉搜索树变平衡</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/balance-a-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/balance-a-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉搜索树，请你返回一棵&nbsp;<strong style="font-weight: 600;">平衡后</strong>&nbsp;的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>，我们就称这棵二叉搜索树是&nbsp;<strong style="font-weight: 600;">平衡的</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/10/balance1-tree.jpg" style="max-width: 100%; height: 319px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,null,2,null,3,null,4,null,null]<strong style="font-weight: 600;">输出：</strong>[2,1,3,null,null,null,4]<strong style="font-weight: 600;">解释：</strong>这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/10/balanced2-tree.jpg" style="max-width: 100%; height: 145px; width: 224px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [2,1,3]<strong style="font-weight: 600;">输出:</strong> [2,1,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树节点的数目在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>&nbsp;范围内。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/balance-a-binary-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1382. 将二叉搜索树变平衡</a>。</strong></details><h3 id="基本思路-78"><a href="#基本思路-78" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这题可难可简单，如果要难，就是红黑树左旋右旋那一套，不过真的没必要这么搞。</p><p>我们简单点，就是用中序遍历获取 BST 的有序结果，然后用 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 的解法代码，将这个有序数组转化成平衡 BST。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst2/">【练习】二叉搜索树经典例题 II</a></li></ul><h3 id="解法代码-77"><a href="#解法代码-77" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">balanceBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># 中序遍历获取有序数组</span>        nums <span class="token operator">=</span> self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token comment"># 从有序数组构建 BST</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 返回中序遍历结果</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token comment"># BST 构造函数，见 108. 将有序数组转换为二叉搜索树</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> lo <span class="token operator">></span> hi<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-70"><a href="#可视化-70" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_balance-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_balance-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/balance-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a><a href="https://labuladong.online/algo/problem-set/bst2/#slug_serialize-and-deserialize-bst">449. 序列化和反序列化二叉搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">449. 序列化和反序列化二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个算法来序列化和反序列化<strong style="font-weight: 600;"><span>&nbsp;</span>二叉搜索树</strong><span>&nbsp;</span>。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">编码的字符串应尽可能紧凑。</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,3]<strong style="font-weight: 600;">输出：</strong>[2,1,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = []<strong style="font-weight: 600;">输出：</strong>[]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li><li>题目数据<span>&nbsp;</span><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>输入的树是一棵二叉搜索树。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 449. 序列化和反序列化二叉搜索树</a>。</strong></details><h3 id="基本思路-79"><a href="#基本思路-79" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>在做本题之前，你需要先看前文 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">二叉树的序列化和反序列化的不同方式</a>，然后就可以很容易理解本题的思路了。</p><p>二叉树的构造算法通用思路很简单，无非就是构造根节点，然后递归构造左右子树，最后把它们接起来，<strong>关键在于如何找到根节点和左右子树的节点，不同的序列化方法，找根节点的方式也不同</strong>。</p><p>本题当然可以直接复制 <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree">297. 二叉树的序列化和反序列化</a> 的代码过来，但是显然没有利用到 BST 左小右大的特性，复杂度会更高。</p><p>对比 297 题普通二叉树的序列化，利用 BST 左小右大的特性主要可以避免序列化空指针，利用 <code>min, max</code> 边界来划定一棵子树的边界，从而提升算法效率。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst2/">【练习】二叉搜索树经典例题 II</a></li></ul><h3 id="解法代码-78"><a href="#解法代码-78" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    <span class="token comment"># 分隔符，区分每个节点的值</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sb<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># 前序遍历位置进行序列化</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> data<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 转化成前序遍历结果</span>        inorder <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span> <span class="token keyword">if</span> s<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 定义：将 nodes 中值在闭区间 [min, max] 的节点构造成一棵 BST</span>    <span class="token keyword">def</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">,</span> min_val<span class="token punctuation">,</span> max_val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> nodes<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 前序遍历位置进行反序列化</span>        <span class="token comment"># 前序遍历结果第一个节点是根节点</span>        root_val <span class="token operator">=</span> nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root_val <span class="token operator">></span> max_val <span class="token keyword">or</span> root_val <span class="token operator">&lt;</span> min_val<span class="token punctuation">:</span>            <span class="token comment"># 超过闭区间 [min, max]，则返回空指针</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        nodes<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 生成 root 节点</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>root_val<span class="token punctuation">)</span>        <span class="token comment"># 构建左右子树</span>        <span class="token comment"># BST 左子树都比根节点小，右子树都比根节点大</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> min_val<span class="token punctuation">,</span> root_val<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> root_val<span class="token punctuation">,</span> max_val<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>技巧二</p><p>如果输入的不是有序数组，而是有序链表，应该怎么构造 BST 呢？</p><h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://labuladong.online/algo/problem-set/bst2/#slug_convert-sorted-list-to-binary-search-tree">109. 有序链表转换二叉搜索树</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">109. 有序链表转换二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个单链表的头节点 &nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code>&nbsp;，其中的元素<span>&nbsp;</span><strong style="font-weight: 600;">按升序排序</strong><span>&nbsp;</span>，将其转换为<span>&nbsp;</span><span data-keyword="height-balanced">平衡</span><span>&nbsp;</span>二叉搜索树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2020/08/17/linked.jpg" style="max-width: 100%; height: 388px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> head = [-10,-3,0,5,9]<strong style="font-weight: 600;">输出:</strong> [0,-3,9,-10,null,5]<strong style="font-weight: 600;">解释:</strong> 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> head = []<strong style="font-weight: 600;">输出:</strong> []</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code>&nbsp;中的节点数在<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 2 * 10<sup>4</sup>]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 109. 有序链表转换二叉搜索树</a>。</strong></details><h3 id="基本思路-80"><a href="#基本思路-80" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>链表和数组相比的一个关键差异是无法通过索引快速访问元素，所以这题有几个思路：</p><p>1、把链表转化成数组，然后直接复用 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 的解法。</p><p>2、稍微改写 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 的解法，用 <a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">单链表的六大解题套路</a> 说到的双指针方法获取链表的中点，时间复杂度略高一些。</p><p>3、如果深刻理解二叉树算法，可以利用中序遍历的特点写出最优化的解法。</p><p>我把第 2 和第 3 种解法写一下。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst2/">【练习】二叉搜索树经典例题 II</a></li></ul><h3 id="解法代码-79"><a href="#解法代码-79" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 解法三、通过中序遍历特点写出的解法</span>    <span class="token keyword">def</span> <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inorderBuild</span><span class="token punctuation">(</span>left<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> right<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>            <span class="token keyword">if</span> left <span class="token operator">></span> right<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">None</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment"># 构造左子树</span>            leftTree <span class="token operator">=</span> inorderBuild<span class="token punctuation">(</span>left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 构造根节点</span>            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>cur <span class="token operator">=</span> self<span class="token punctuation">.</span>cur<span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token comment"># 构造右子树</span>            rightTree <span class="token operator">=</span> inorderBuild<span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>            <span class="token comment"># 将左右子树接到根节点上</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> leftTree            root<span class="token punctuation">.</span>right <span class="token operator">=</span> rightTree            <span class="token keyword">return</span> root        <span class="token builtin">len</span> <span class="token operator">=</span> <span class="token number">0</span>        p <span class="token operator">=</span> head        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            <span class="token builtin">len</span> <span class="token operator">+=</span> <span class="token number">1</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>        self<span class="token punctuation">.</span>cur <span class="token operator">=</span> head        <span class="token keyword">return</span> inorderBuild<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 解法二、通过找链表中点的方式写出的解法</span>    <span class="token keyword">def</span> <span class="token function">sortedListToBST_2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>begin<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> end<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>            <span class="token keyword">if</span> begin <span class="token operator">==</span> end<span class="token punctuation">:</span>                <span class="token comment"># 因为是左闭右开区间，所以现在已经成空集了</span>                <span class="token keyword">return</span> <span class="token boolean">None</span>            mid <span class="token operator">=</span> getMid<span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span>            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>mid<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> build<span class="token punctuation">(</span>begin<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> build<span class="token punctuation">(</span>mid<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">def</span> <span class="token function">getMid</span><span class="token punctuation">(</span>begin<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> end<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>            slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> begin<span class="token punctuation">,</span> begin            <span class="token keyword">while</span> fast <span class="token operator">!=</span> end <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">!=</span> end<span class="token punctuation">:</span>                slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span>                fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token keyword">return</span> slow        <span class="token keyword">return</span> build<span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-71"><a href="#可视化-71" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_convert-sorted-list-to-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_convert-sorted-list-to-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/convert-sorted-list-to-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>Tip</p><p>最后还有一些常考的套路题型，记住就好了。</p><h2 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a href="https://labuladong.online/algo/problem-set/bst2/#slug_binary-search-tree-iterator">173. 二叉搜索树迭代器</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">173. 二叉搜索树迭代器</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-search-tree-iterator/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-search-tree-iterator/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div>实现一个二叉搜索树迭代器类<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">BSTIterator</code><span>&nbsp;</span>，表示一个按中序遍历二叉搜索树（BST）的迭代器：<div class="original__bRMd"><div><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">BSTIterator(TreeNode root)</code><span>&nbsp;</span>初始化<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">BSTIterator</code><span>&nbsp;</span>类的一个对象。BST 的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean hasNext()</code><span>&nbsp;</span>如果向指针右侧遍历存在数字，则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int next()</code>将指针向右移动，然后返回指针处的数字。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;">注意，指针初始化为一个不存在于 BST 中的数字，所以对<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next()</code><span>&nbsp;</span>的首次调用将返回 BST 中的最小元素。</p></div></div><p style="line-height: 1.6; overflow-wrap: break-word;">你可以假设<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next()</code><span>&nbsp;</span>调用总是有效的，也就是说，当调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next()</code><span>&nbsp;</span>时，BST 的中序遍历中至少存在一个下一个数字。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2018/12/25/bst-tree.png" style="max-width: 100%; width: 189px; height: 178px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"][[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<strong style="font-weight: 600;">输出</strong>[null, 3, 7, true, 9, true, 15, true, 20, false]<p><strong style="font-weight: 600;">解释</strong><br>BSTIterator bSTIterator &#x3D; new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>bSTIterator.next();    &#x2F;&#x2F; 返回 3<br>bSTIterator.next();    &#x2F;&#x2F; 返回 7<br>bSTIterator.hasNext(); &#x2F;&#x2F; 返回 True<br>bSTIterator.next();    &#x2F;&#x2F; 返回 9<br>bSTIterator.hasNext(); &#x2F;&#x2F; 返回 True<br>bSTIterator.next();    &#x2F;&#x2F; 返回 15<br>bSTIterator.hasNext(); &#x2F;&#x2F; 返回 True<br>bSTIterator.next();    &#x2F;&#x2F; 返回 20<br>bSTIterator.hasNext(); &#x2F;&#x2F; 返回 False<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>5</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li><li>最多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>5</sup></code><span>&nbsp;</span>次<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">hasNext</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next</code><span>&nbsp;</span>操作</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">进阶：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>你可以设计一个满足下述条件的解决方案吗？<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next()</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">hasNext()</code><span>&nbsp;</span>操作均摊时间复杂度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(1)</code><span>&nbsp;</span>，并使用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(h)</code><span>&nbsp;</span>内存。其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">h</code><span>&nbsp;</span>是树的高度。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-search-tree-iterator/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 173. 二叉搜索树迭代器</a>。</strong></details></p><h3 id="基本思路-81"><a href="#基本思路-81" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>利用栈模拟递归对 BST 进行中序遍历可以认为是一种套路题型，你记住就好了，关键在于理解 <code>pushLeftBranch</code> 函数，深刻理解二叉树递归遍历的过程：</p><p><img src="/2025/08/03/er-cha-shu-suan-fa-xi-ti/1.gif" alt="img"></p><p>另外，我还总结了一套二叉树各种遍历顺序通用的递归转迭代代码框架，详见 <a href="https://labuladong.online/algo/data-structure/iterative-traversal-binary-tree/">二叉树通用迭代框架</a>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst2/">【练习】二叉搜索树经典例题 II</a></li></ul><h3 id="解法代码-80"><a href="#解法代码-80" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BSTIterator</span><span class="token punctuation">:</span>    <span class="token comment"># 模拟递归栈</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>pushLeftBranch<span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token comment"># 左侧树枝一撸到底</span>    <span class="token keyword">def</span> <span class="token function">pushLeftBranch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> p <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>pushLeftBranch<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/two-sum-bsts">1214. 查找两棵二叉搜索树之和 🟠</a></li><li><a href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees">1305. 两棵二叉搜索树中的所有元素 🟠</a></li><li><a href="https://leetcode.cn/problems/kTOapQ">剑指 Offer II 055. 二叉搜索树迭代器 🟠</a></li></ul><h2 id="1305-两棵二叉搜索树中的所有元素"><a href="#1305-两棵二叉搜索树中的所有元素" class="headerlink" title="1305. 两棵二叉搜索树中的所有元素"></a><a href="https://labuladong.online/algo/problem-set/bst2/#slug_all-elements-in-two-binary-search-trees">1305. 两棵二叉搜索树中的所有元素</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1305. 两棵二叉搜索树中的所有元素</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root2</code>&nbsp;这两棵二叉搜索树。请你返回一个列表，其中包含&nbsp;<strong style="font-weight: 600;">两棵树&nbsp;</strong>中的所有整数并按<span>&nbsp;</span><strong style="font-weight: 600;">升序</strong><span>&nbsp;</span>排序。.</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [2,1,4], root2 = [1,0,3]<strong style="font-weight: 600;">输出：</strong>[0,1,1,2,3,4]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/12/29/q2-e5-.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root1 = [1,null,8], root2 = [8,1]<strong style="font-weight: 600;">输出：</strong>[1,1,8,8]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>每棵树的节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 5000]</code><span>&nbsp;</span>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1305. 两棵二叉搜索树中的所有元素</a>。</strong></details><h3 id="基本思路-82"><a href="#基本思路-82" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>你可以直接中序遍历两个 BST 得到两个有序数组，然后把这两个有序数组合并，这个思路简单，但是空间复杂度会高一些。</p><p>比较好的办法是用 <a href="https://leetcode.cn/problems/binary-search-tree-iterator">173. 二叉搜索树迭代器</a> 中实现的 BST 迭代器，然后类似我们解决 <a href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表</a> 中的逻辑操作这两个迭代器，获得合并的有序结果。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/bst2/">【练习】二叉搜索树经典例题 II</a></li></ul><h3 id="解法代码-81"><a href="#解法代码-81" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/bst2/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getAllElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># BST 有序迭代器</span>        t1 <span class="token operator">=</span> BSTIterator<span class="token punctuation">(</span>root1<span class="token punctuation">)</span>        t2 <span class="token operator">=</span> BSTIterator<span class="token punctuation">(</span>root2<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 类似合并有序链表的算法逻辑</span>        <span class="token keyword">while</span> t1<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> t2<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> t1<span class="token punctuation">.</span>peek<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> t2<span class="token punctuation">.</span>peek<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 如果有一棵 BST 还剩元素，添加到最后</span>        <span class="token keyword">while</span> t1<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> t2<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment"># BST 有序迭代器</span><span class="token keyword">class</span> <span class="token class-name">BSTIterator</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>pushLeftBranch<span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token comment"># 左侧树枝一撸到底</span>    <span class="token keyword">def</span> <span class="token function">pushLeftBranch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>pushLeftBranch<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">bool</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stk<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 二叉树算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2025/08/03/er-cha-sou-suo-shu/"/>
      <url>/2025/08/03/er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树心法（构造篇）"><a href="#二叉搜索树心法（构造篇）" class="headerlink" title="二叉搜索树心法（构造篇）"></a>二叉搜索树心法（构造篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">95. Unique Binary Search Trees II</a></td><td align="center"><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></td><td align="center"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td><td align="center">🟠</td></tr></tbody></table><p>前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树结构基础</a></li><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的 DFS&#x2F;BFS 遍历</a></li></ul><p>之前写了两篇手把手刷 BST 算法题的文章，<a href="https://labuladong.online/algo/data-structure/bst-part1/">第一篇</a> 讲了中序遍历对 BST 的重要意义，<a href="https://labuladong.online/algo/data-structure/bst-part2/">第二篇</a> 写了 BST 的基本操作。</p><p>本文就来写手把手刷 BST 系列的第三篇，循序渐进地讲两道题，如何计算所有有效 BST。</p><p>第一道题是力扣第 96 题「<a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">96. 不同的二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/unique-binary-search-trees/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/unique-binary-search-trees/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，求恰由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点组成且节点值从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>互不相同的<span>&nbsp;</span><strong style="font-weight: 600;">二叉搜索树</strong><span>&nbsp;</span>有多少种？返回满足题意的二叉搜索树的种数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/uniquebstn3.jpg" style="max-width: 100%; width: 600px; height: 148px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 3<strong style="font-weight: 600;">输出：</strong>5</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 1<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 19</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 96. 不同的二叉搜索树</a>。</strong></details><p>函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就是一个正宗的穷举问题，那么什么方式能够正确地穷举有效 BST 的数量呢？</p><p>我们前文说过，不要小看「穷举」，这是一件看起来简单但是比较有技术含量的事情，问题的关键就是不能数漏，也不能数多，你咋整？</p><p>之前 <a href="https://labuladong.online/algo/data-structure/binary-tree-part1/">手把手刷二叉树第一期</a> 说过，二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。</p><p>举个例子，比如给算法输入 <code>n = 5</code>，也就是说用 <code>&#123;1,2,3,4,5&#125;</code> 这些数字去构造 BST。</p><p>首先，这棵 BST 的根节点总共有几种情况？</p><p>显然有 5 种情况对吧，因为每个数字都可以作为根节点。</p><p>比如说我们固定 <code>3</code> 作为根节点，这个前提下能有几种不同的 BST 呢？</p><p>根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。</p><p>所以如果固定 <code>3</code> 作为根节点，左子树节点就是 <code>&#123;1,2&#125;</code> 的组合，右子树就是 <code>&#123;4,5&#125;</code> 的组合。</p><p><strong>左子树的组合数和右子树的组合数乘积</strong>就是 <code>3</code> 作为根节点时的 BST 个数。</p><p><img src="/2025/08/03/er-cha-sou-suo-shu/1.jpeg" alt="img"></p><p>我们这是说了 <code>3</code> 为根节点这一种特殊情况，其实其他的节点也是一样的。</p><p>那你可能会问，我们可以一眼看出 <code>&#123;1,2&#125;</code> 和 <code>&#123;4,5&#125;</code> 有几种组合，但是怎么让算法进行计算呢？</p><p>其实很简单，只需要递归就行了，我们可以写这样一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：闭区间 [lo, hi] 的数字能组成 count(lo, hi) 种 BST</span><span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据这个函数的定义，结合刚才的分析，可以写出代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 计算闭区间 [1, n] 组成的 BST 个数</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment"># 计算闭区间 [lo, hi] 组成的 BST 个数</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> lo <span class="token operator">></span> hi<span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># i 的值作为根节点 root</span>            left <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            right <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            <span class="token comment"># 左右子树的组合数乘积是 BST 的总数</span>            res <span class="token operator">+=</span> left <span class="token operator">*</span> right        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 base case，显然当 <code>lo &gt; hi</code> 闭区间 <code>[lo, hi]</code> 肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p><p>这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。</p><p>前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 备忘录</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 备忘录的值初始化为 0</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment"># 定义：返回 [lo, hi] 范围内构造的不同 BST 的数量</span>    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token comment"># 查备忘录</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> mid <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            right <span class="token operator">=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            res <span class="token operator">+=</span> left <span class="token operator">*</span> right        <span class="token comment"># 将结果存入备忘录</span>        self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，这道题就完全解决了。</p><p>那么，如果给一个进阶题目，不止让你计算有几个不同的 BST，而是要你构建出所有有效的 BST，如何实现这个算法呢？</p><p>这道题就是力扣第 95 题「<a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a>」，让你构建所有 BST：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">95. 不同的二叉搜索树 II</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，请你生成并返回所有由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点组成且节点值从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>互不相同的不同<span>&nbsp;</span><strong style="font-weight: 600;">二叉搜索树</strong><em><span>&nbsp;</span></em>。可以按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>返回答案。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/18/uniquebstn3.jpg" style="max-width: 100%; width: 600px; height: 148px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 3<strong style="font-weight: 600;">输出：</strong>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>n = 1<strong style="font-weight: 600;">输出：</strong>[[1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 8</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 95. 不同的二叉搜索树 II</a>。</strong></details><p>函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> generateTrees<span class="token punctuation">(</span><span class="token builtin">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>明白了上道题构造有效 BST 的方法，这道题的思路也是一样的</strong>：</p><p>1、穷举 <code>root</code> 节点的所有可能。</p><p>2、递归构造出左右子树的所有有效 BST。</p><p>3、给 <code>root</code> 节点穷举所有左右子树的组合。</p><p>我们可以直接看代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 构造闭区间 [1, n] 组成的 BST </span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment"># 构造闭区间 [lo, hi] 组成的 BST </span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> lo <span class="token operator">></span> hi<span class="token punctuation">:</span>            <span class="token comment"># 这里需要装一个 null 元素，这样才能让下面的两个内层 for 循环都能进入，正确地创建出叶子节点</span>            <span class="token comment"># 举例来说吧，什么时候会进到这个 if 语句？当你创建叶子节点的时候，对吧。</span>            <span class="token comment"># 那么如果你这里不加 null，直接返回空列表，那么下面的内层两个 for 循环都无法进入        </span>            <span class="token comment"># 你的那个叶子节点就没有创建出来，看到了吗？所以这里要加一个 null，确保下面能把叶子节点做出来</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> res        <span class="token comment"># 1、穷举 root 节点的所有可能。</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 2、递归构造出左右子树的所有有效 BST。</span>            leftTree <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            rightTree <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            <span class="token comment"># 3、给 root 节点穷举所有左右子树的组合。</span>            <span class="token keyword">for</span> left <span class="token keyword">in</span> leftTree<span class="token punctuation">:</span>                <span class="token keyword">for</span> right <span class="token keyword">in</span> rightTree<span class="token punctuation">:</span>                    <span class="token comment"># i 作为根节点 root 的值</span>                    root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees-ii" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><details data-v-ee1a9bd0="" id="div_unique-binary-search-trees-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_unique-binary-search-trees-ii" src="https://labuladong.online/algo-visualize/leetcode/unique-binary-search-trees-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，两道题都解决了。</p><p>本文就到这里，更多经典的二叉树习题以及递归思维的训练，请参见二叉树章节中的 <a href="https://labuladong.online/algo/problem-set/bst1/">递归专项练习</a></p><h1 id="二叉搜索树心法（后序篇）"><a href="#二叉搜索树心法（后序篇）" class="headerlink" title="二叉搜索树心法（后序篇）"></a>二叉搜索树心法（后序篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/">1373. Maximum Sum BST in Binary Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和</a></td><td align="center">🔴</td></tr></tbody></table><p>前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树结构基础</a></li><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的 DFS&#x2F;BFS 遍历</a></li><li><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a></li></ul><p>本文是承接 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a> 的第五篇文章，主要讲二叉树后序位置的妙用，复述下前文关于后序遍历的描述：</p><blockquote><p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</p><p><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p></blockquote><p>其实二叉树的题目真的不难，无非就是前中后序遍历框架来回倒嘛，只要你把一个节点该做的事情安排好，剩下的抛给递归框架即可。</p><p>但是对于有的题目，不同的遍历顺序时间复杂度不同。尤其是这个后序位置的代码，有时候可以大幅提升算法效率。</p><p>我们再看看后序遍历的代码框架：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 后序代码的位置</span>    <span class="token comment"># 在这里处理当前节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看这个代码框架，你说什么情况下需要在后序位置写代码呢？</p><p><strong>如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历</strong>。</p><p>下面就讲一个经典的算法问题，可以直观地体会到后序位置的妙用。这是力扣第 1373 题「<a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">二叉搜索子树的最大键值和</a>」，函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">maxSumBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90">题目分析</a></h2><p>题目会给你输入一棵二叉树，这棵二叉树的子树中可能包含<strong>二叉搜索树</strong>对吧，请你找到<strong>节点之和最大的</strong>那棵二叉搜索树，返回它的节点值之和。</p><p>二叉搜索树（简写作 BST）的性质详见基础知识章节 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础</a>，简单说就是「左小右大」，对于每个节点，整棵左子树都比该节点的值小，整棵右子树都比该节点的值大。</p><p>比如题目给了这个例子：</p><p><img src="/2025/08/03/er-cha-sou-suo-shu/1.png" alt="img"></p><p>如果输入这棵二叉树，算法应该返回 20，也就是图中绿圈的那棵子树的节点值之和，因为它是一棵 BST，且节点之和最大。</p><p>那有的读者可能会问，输入的是一棵普通二叉树，有没有可能其中不存在 BST？</p><p>不会的，因为按照 BST 的定义，任何一个单独的节点肯定是 BST，也就是说，再不济，二叉树最下面的叶子节点肯定都是 BST。</p><p>比如说如果输入下面这棵二叉树：</p><p><img src="/2025/08/03/er-cha-sou-suo-shu/2.png" alt="img"></p><p>两个叶子节点 <code>1</code> 和 <code>2</code> 就是 BST，比较一下节点之和，算法应该返回 2。</p><p>好了，到这里，题目应该解释地很清楚了，下面我们来分析一下这道题应该怎么做。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></h2><p>刚才说了，<strong>二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么</strong>。</p><p><strong>那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢</strong>？</p><p>1、我肯定得知道左右子树是不是合法的 BST，如果下面的这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。</p><p>2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。</p><p>3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。</p><p><strong>根据以上三点，站在当前节点的视角，需要知道以下具体信息</strong>：</p><p>1、左右子树是否是 BST。</p><p>2、左子树的最大值和右子树的最小值。</p><p>3、左右子树的节点值之和。</p><p>只有知道了这几个值，我们才能满足题目的要求，现在可以尝试用伪码写出算法的大致逻辑：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 全局变量，记录 BST 最大节点之和</span>        self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">maxSumBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxSum    <span class="token comment"># 遍历二叉树</span>    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment"># ******* 前序位置 *******</span>        <span class="token comment"># 判断左右子树是不是 BST</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 计算左子树的最大值和右子树的最小值</span>            leftMax <span class="token operator">=</span> self<span class="token punctuation">.</span>findMax<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            rightMin <span class="token operator">=</span> self<span class="token punctuation">.</span>findMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 判断以 root 节点为根的树是不是 BST</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> leftMax <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> rightMin<span class="token punctuation">:</span>                <span class="token comment"># 如果条件都符合，计算当前 BST 的节点之和</span>                leftSum <span class="token operator">=</span> self<span class="token punctuation">.</span>findSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                rightSum <span class="token operator">=</span> self<span class="token punctuation">.</span>findSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                rootSum <span class="token operator">=</span> leftSum <span class="token operator">+</span> rightSum <span class="token operator">+</span> root<span class="token punctuation">.</span>val                <span class="token comment"># 计算 BST 节点的最大和</span>                self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxSum<span class="token punctuation">,</span> rootSum<span class="token punctuation">)</span>        <span class="token comment"># **************************</span>        <span class="token comment"># 二叉树遍历框架，遍历子树节点</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 计算以 root 为根的二叉树的最大值</span>    <span class="token keyword">def</span> <span class="token function">findMax</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 计算以 root 为根的二叉树的最小值</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 计算以 root 为根的二叉树的节点和</span>    <span class="token keyword">def</span> <span class="token function">findSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 判断以 root 为根的二叉树是否是 BST</span>    <span class="token keyword">def</span> <span class="token function">isBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码逻辑应该是不难理解的，代码在前序遍历的位置把之前的分析都实现了一遍。</p><p>其中有四个辅助函数比较简单，我就不具体实现了，其中只有判断合法 BST 的函数稍有技术含量，前文 <a href="https://labuladong.online/algo/data-structure/bst-part2/">二叉搜索树操作集锦</a> 写过，这里就不展开了。</p><p><strong>稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 <code>traverse</code> 函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的</strong>。</p><p>具体来说，每一个辅助方法都是二叉树遍历函数，时间复杂度是 O(N)<em>O</em>(<em>N</em>)，而 <code>traverse</code> 遍历框架会在每个节点上都把这些辅助函数调用一遍，所以总的时间复杂度是 O(N2)<em>O</em>(<em>N</em>2)。</p><p>但是根据刚才的分析，像 <code>leftMax</code>、<code>rootSum</code> 这些变量又都得算出来，否则无法完成题目的要求。</p><h2 id="思路优化"><a href="#思路优化" class="headerlink" title="思路优化"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E6%80%9D%E8%B7%AF%E4%BC%98%E5%8C%96">思路优化</a></h2><p>我们希望既算出这些变量，又避免辅助函数带来的额外复杂度，鱼和熊掌全都要，可以做到吗？</p><p>其实是可以的，<strong>只要把前序遍历变成后序遍历，让 <code>traverse</code> 函数把辅助函数做的事情顺便做掉</strong>。</p><p>你仔细想想，如果我知道了我的左右子树的最大值，那么把我的值和它们比较一下，就可以推导出以我为根的这整棵二叉树的最大值。根本没必要再遍历一遍所有节点，对吧？求最小节点的值和节点的和也是一样的道理。</p><p>这就是我在前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手带你刷二叉树（纲领篇）</a> 所讲的后序遍历位置的妙用。</p><p>当然，正如前文所讲，如果要利用函数的返回值，就不建议使用 <code>traverse</code> 这个函数名了，我们想计算最大值、最小值和所有节点之和，不妨叫这个函数 <code>findMaxMinSum</code> 好了。</p><p>其他代码不变，我们让 <code>findMaxMinSum</code> 函数做一些计算任务，返回一个大小为 4 的 int 数组，我们暂且称它为 <code>res</code>，其中：</p><p><code>res[0]</code> 记录以 <code>root</code> 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；</p><p><code>res[1]</code> 记录以 <code>root</code> 为根的二叉树所有节点中的最小值；</p><p><code>res[2]</code> 记录以 <code>root</code> 为根的二叉树所有节点中的最大值；</p><p><code>res[3]</code> 记录以 <code>root</code> 为根的二叉树所有节点值之和。</p><p>对于当前节点，如果分别对左右子树计算出了这 4 个值，只需要简单的运算，就可以推导出以当前节点为根的二叉树的这 4 个值，避免了重复遍历。</p><p>直接看代码实现吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 BST 最大节点之和</span>        self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">maxSumBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>findMaxMinSum<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxSum    <span class="token comment"># 计算以 root 为根的二叉树的最大值、最小值、节点和</span>    <span class="token keyword">def</span> <span class="token function">findMaxMinSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>                <span class="token comment"># 递归计算左右子树</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>findMaxMinSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>findMaxMinSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># ******* 后序位置 *******</span>        <span class="token comment"># 通过 left 和 right 推导返回值</span>        <span class="token comment"># 并且正确更新 maxSum 变量</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> left<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 以 root 为根的二叉树是 BST</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token comment"># 计算以 root 为根的这棵 BST 的最小值</span>            res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 计算以 root 为根的这棵 BST 的最大值</span>            res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 计算以 root 为根的这棵 BST 所有节点之和</span>            res<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val            <span class="token comment"># 更新全局变量</span>            self<span class="token punctuation">.</span>maxSum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxSum<span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 以 root 为根的二叉树不是 BST</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 其他的值都没必要计算了，因为用不到</span>                    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，这道题就解决了，<code>findMaxMinSum</code> 函数在遍历二叉树的同时顺便把之前辅助函数做的事情都做了，避免了在递归函数中调用递归函数，时间复杂度只有 O(N)。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><a href="https://labuladong.online/algo/data-structure/bst-part4/#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">最后总结</a></h2><p>你看，这就是后序遍历的妙用，相对前序遍历的解法，现在的解法不仅效率高，而且代码量少，比较优美。</p><p>这个优化属于前文 <a href="https://labuladong.online/algo/essential-technique/algorithm-summary/">算法的本质</a> 中提到的「如何聪明的穷举」的范畴。</p><p>那可能有读者问，后序遍历这么好，是不是就应该尽可能多用后序遍历？</p><p>不是，主要是看题目，看你这个问题适合「遍历」的思路还是「分解问题」的思路。为什么这道题用后序遍历有奇效呢，因为我们需要的这些变量全都可以通过子问题的结果推到出来，适合用「分解问题」的思路求解。</p><p>你计算以 <code>root</code> 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 <code>root.val</code> 计算出来？</p><p>你计算以 <code>root</code> 为根的二叉树的最大值&#x2F;最小值，是不是可以通过左右子树的最大值&#x2F;最小值和 <code>root.val</code> 比较出来？</p><p>你判断以 <code>root</code> 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？</p><p>那么充分利用子问题的答案，当然要比每次都傻乎乎遍历所有节点要高效。</p><p><strong>以我的刷题经验，我们要尽可能避免递归函数中调用其他递归函数</strong>，如果出现这种情况，大概率是代码实现有瑕疵，可以进行类似本文的优化来避免递归套递归。</p><p>本文就到这里，更多经典的二叉树习题以及递归思维的训练，请参见二叉树章节中的 <a href="https://labuladong.online/algo/intro/binary-tree-practice/">递归专项练习</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 二叉树算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo分支管理及图片显示</title>
      <link href="/2025/07/25/hexo-fen-zhi-guan-li-ji-tu-pian-xian-shi/"/>
      <url>/2025/07/25/hexo-fen-zhi-guan-li-ji-tu-pian-xian-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-分支"><a href="#Hexo-分支" class="headerlink" title="Hexo 分支"></a>Hexo 分支</h2><p>在使用 Hexo 搭建 GitHub Page 博客时，通常会遇到如何保存 Hexo 环境和博客源码的问题。一个常见的解决方案是使用 GitHub 分支来管理不同的内容。</p><h3 id="创建和管理分支"><a href="#创建和管理分支" class="headerlink" title="创建和管理分支"></a>创建和管理分支</h3><p>首先，在 GitHub 上创建一个新的仓库，例如 <em><code>username.github.io</code></em>。然后，在该仓库下创建两个分支：<em><code>master</code></em> 和 <em><code>hexo</code></em>。其中，<em><code>master</code></em> 分支用于保存 <code>Hexo</code> 生成的静态 HTML 文件，而 <em><code>hexo</code></em> 分支用于保存 <code>Hexo</code> 环境和博客的 Markdown 源码。</p><h3 id="初始化-Hexo-环境"><a href="#初始化-Hexo-环境" class="headerlink" title="初始化 Hexo 环境"></a>初始化 Hexo 环境</h3><p>在本地克隆仓库后，依次执行以下命令来初始化 Hexo 环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexohexo init<span class="token function">npm</span> <span class="token function">install</span><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，配置 Hexo 的 <em>_config.yml</em> 文件中的 <em>deploy</em> 参数，将分支设置为 <em>master</em>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span><span class="token key atrule">type</span><span class="token punctuation">:</span> git<span class="token key atrule">repo</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>username/username.github.io.git<span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span class="token comment"># 现在GitHub已经默认主分支为main</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="提交和部署"><a href="#提交和部署" class="headerlink" title="提交和部署"></a>提交和部署</h3><p>每次修改或新增博文后，依次执行以下命令将博客源码提交到 <em><code>hexo</code></em> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"更新博客"</span><span class="token function">git</span> push origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，执行 <em><code>hexo generate -d</code></em> 命令生成网站并部署到 GitHub 上的 <em>master</em> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h3><p>在完成初始配置后，日常操作只需重复上述提交和部署步骤即可。在本地修改博客内容后，通过以下命令将改动推送到 GitHub：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"更新博客"</span><span class="token function">git</span> push origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，执行以下命令发布网站到 <em>master</em> 分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="处理本地资料丢失"><a href="#处理本地资料丢失" class="headerlink" title="处理本地资料丢失"></a>处理本地资料丢失</h3><p>如果需要在其他电脑上修改博客，可以通过以下步骤恢复环境：</p><ul><li>克隆仓库到本地：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:username/username.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>重新安装 Hexo 编译环境：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo<span class="token function">npm</span> <span class="token function">install</span><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<em><code>hexo init</code></em> 命令会初始化 Hexo 环境，但会清空 <em>.git</em> 文件夹，导致版本控制信息丢失。因此，除非环境损坏，否则无需运行此命令</p><p>通过以上步骤，可以高效地管理 Hexo 环境和博客源码，确保博客内容的安全和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树心法（序列化篇</title>
      <link href="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/"/>
      <url>/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/</url>
      
        <content type="html"><![CDATA[<p>本文是承接 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a> 的第三篇文章，前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a> 带你学习了二叉树构造技巧，本文加大难度，让你对二叉树同时进行「序列化」和「反序列化」。</p><p>要说序列化和反序列化，得先从 JSON 数据格式说起。</p><p>JSON 的运用非常广泛，比如我们经常将编程语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。</p><p>这就是序列化和反序列化的目的，以某种特定格式组织数据，使得数据可以独立于编程语言。</p><p>那么假设现在有一棵用 Java 实现的二叉树，我想把它通过某些方式存储下来，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行序列化和反序列化了。</p><h2 id="零、前-中-后序和二叉树的唯一性"><a href="#零、前-中-后序和二叉树的唯一性" class="headerlink" title="零、前&#x2F;中&#x2F;后序和二叉树的唯一性"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E9%9B%B6%E3%80%81%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7">零、前&#x2F;中&#x2F;后序和二叉树的唯一性</a></h2><p>谈具体的题目之前，我们先思考一个问题：<strong>什么样的序列化的数据可以反序列化出唯一的一棵二叉树</strong>？</p><p>比如说，如果给你一棵二叉树的前序遍历结果，你是否能够根据这个结果还原出这棵二叉树呢？</p><p>答案是也许可以，也许不可以，具体要看你给的前序遍历结果是否包含空指针的信息。如果包含了空指针，那么就可以唯一确定一棵二叉树，否则就不行。</p><p>举例来说，如果我给你这样一个不包含空指针的前序遍历结果 <code>[1,2,3,4,5]</code>，那么如下两棵二叉树都是满足这个前序遍历结果的：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/dup-preorder.jpg" alt="img"></p><p>所以给定不包含空指针信息的前序遍历结果，是不能还原出唯一的一棵二叉树的。</p><p>但如果我的前序遍历结果包含空指针的信息，那么就能还原出唯一的一棵二叉树了。比如说用 <code>#</code> 表示空指针，上图左侧的二叉树的前序遍历结果就是 <code>[1,2,3,#,#,4,#,#,5,#,#]</code>，上图右侧的二叉树的前序遍历结果就是 <code>[1,2,#,3,#,#,4,5,#,#,#]</code>，它俩就区分开了。</p><p>那么估计就有聪明的小伙伴说了：二叉树心法了。</p><p>首先要夸一下这种举一反三的思维，但很不幸，正确答案是，即便你包含了空指针的信息，也只有前序和后序的遍历结果才能唯一还原二叉树，中序遍历结果做不到。</p><p>本文后面会具体探讨这个问题，这里只简单说下原因：因为前序&#x2F;后序遍历的结果中，可以确定根节点的位置，而中序遍历的结果中，根节点的位置是无法确定的。</p><p>更直观的，比如如下两棵二叉树显然拥有不同的结构，但它俩的中序遍历结果都是 <code>[#,1,#,1,#]</code>，无法区分：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/dup-inorder.jpg" alt="img"></p><p>说了这么多，总结下结论，<strong>当二叉树中节点的值不存在重复时</strong>：</p><ol><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你会给出<strong>两种</strong>遍历顺序，分两种情况：</p><p>2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。</p><p>2.2. 如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，也要分两种情况：</p><p>3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。</p><p>3.2. 如果你给出的是中序，那么你无法还原出唯一的一棵二叉树。</p></li></ol><p>我在开头提一下这些总结性的认识，可以理解性记忆，之后会遇到一些相关的题目，再回过头来看看这些总结，会有更深的理解，下面看具体的题目吧。</p><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">一、题目描述</a></h2><p>力扣第 297 题「<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a>」就是给你输入一棵二叉树的根节点 <code>root</code>，要求你实现如下一个类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>        <span class="token comment"># 把一棵二叉树序列化成字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 把字符串反序列化成二叉树</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用 <code>serialize</code> 方法将二叉树序列化成字符串，用 <code>deserialize</code> 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。</p><p>比如说输入如下这样一棵二叉树：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/1.jpg" alt="img"></p><p><code>serialize</code> 方法也许会把它序列化成字符串 <code>2,1,#,6,#,#,3,#,#</code>，其中 <code>#</code> 表示 <code>null</code> 指针，那么把这个字符串再输入 <code>deserialize</code> 方法，依然可以还原出这棵二叉树。</p><p>也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。</p><p>想象一下，二叉树是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。<strong>所谓的序列化不过就是把结构化的数据「打平」，本质就是在考察二叉树的遍历方式</strong>。</p><p>二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 <code>serialize</code> 方法和 <code>deserialize</code> 方法。</p><h2 id="二、前序遍历解法"><a href="#二、前序遍历解法" class="headerlink" title="二、前序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%BA%8C%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">二、前序遍历解法</a></h2><p>前文 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的遍历基础</a> 说过了二叉树的几种遍历方式，在前序位置收集节点，即可获得前序遍历结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 暂且用数字 -1 代表空指针 null</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token comment"># ****** 前序位置 ******</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token comment"># **********************</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>traverse</code> 函数之后，你是否可以立即想出这个 <code>res</code> 列表中元素的顺序是怎样的？比如如下二叉树（<code>#</code> 代表空指针 null），可以直观看出前序遍历做的事情：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/1.jpeg" alt="img"></p><p>那么 <code>res = [1,2,-1,4,-1,-1,3,-1,-1]</code>，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。</p><p>那么，将二叉树打平到一个字符串中也是完全一样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 代表分隔符的字符</span>SEP <span class="token operator">=</span> <span class="token string">","</span><span class="token comment"># 代表 null 空指针的字符</span>NULL <span class="token operator">=</span> <span class="token string">"#"</span><span class="token comment"># 用于拼接字符串</span>sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 将二叉树打平为字符串</span><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token comment"># ***** 前序位置 *****</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>    <span class="token comment"># *******************</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码依然是收集前序遍历结果，用 <code>,</code> 作为分隔符，用 <code>#</code> 表示空指针 null，调用完 <code>traverse</code> 函数后，<code>sb</code> 中的字符串应该是 <code>1,2,#,4,#,#,3,#,#,</code>。</p><p>至此，我们已经可以写出序列化函数 <code>serialize</code> 的代码了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 主函数，将二叉树序列化为字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sb<span class="token punctuation">)</span>    <span class="token comment"># 辅助函数，将二叉树存入 StringBuilder</span>    <span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment"># ****** 前序位置 ********</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        <span class="token comment"># ***********************</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，思考一下如何写 <code>deserialize</code> 函数，将字符串反过来构造二叉树。</p><p>首先我们可以把字符串转化成列表：</p><pre class="line-numbers language-none"><code class="language-none">data &#x3D; &quot;1,2,#,4,#,#,3,#,#,&quot;nodes &#x3D; data.split(&quot;,&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，<code>nodes</code> 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？</p><p>Tip</p><p>前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">二叉树心法（构造篇）</a> 说过，至少要得到前、中、后序遍历中的两种互相配合才能还原二叉树。那是因为前文的遍历结果没有记录空指针的信息。这里的 <code>nodes</code> 列表包含了空指针的信息，所以只使用 <code>nodes</code> 列表就可以还原二叉树。</p><p>根据我们刚才的分析，<code>nodes</code> 列表就是一棵打平的二叉树：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/1.jpeg" alt="img"></p><p>那么，反序列化过程也是一样，<strong>先确定根节点 <code>root</code>，然后遵循前序遍历的规则，递归生成左右子树即可</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 主函数，将字符串反序列化为二叉树结构</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># 将字符串转化成列表</span>        nodes <span class="token operator">=</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 辅助函数，通过 nodes 列表构造二叉树</span>    <span class="token keyword">def</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> nodes<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># ****** 前序位置 *******</span>        <span class="token comment"># 列表最左侧就是根节点</span>        first <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> first <span class="token operator">==</span> self<span class="token punctuation">.</span>NULL<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment"># *********************</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现，根据树的递归性质，<code>nodes</code> 列表的第一个元素就是一棵树的根节点，所以只要将列表的第一个元素取出作为根节点，剩下的交给递归函数去解决即可。</p><h2 id="三、后序遍历解法"><a href="#三、后序遍历解法" class="headerlink" title="三、后序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%B8%89%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">三、后序遍历解法</a></h2><p>二叉树的后序遍历框架：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment"># 后序位置的代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明白了前序遍历的解法，后序遍历就比较容易理解了。<code>serialize</code> 序列化方法非常容易实现，只需要稍微修改前文的 <code>_serialize</code>辅助方法即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 辅助函数，将二叉树存入 StringBuilder</span><span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span>    _serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    _serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token comment"># ****** 后序位置 ********</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>    <span class="token comment"># ***********************</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把对 <code>StringBuilder</code> 的拼接操作放到了后序遍历的位置，后序遍历导致结果的顺序发生变化：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/2.jpeg" alt="img"></p><p>关键点在于，如何实现后序遍历的 <code>deserialize</code> 方法呢？是不是也简单地将反序列化的关键代码无脑放到后序遍历的位置就行了呢：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 辅助函数，通过 nodes 列表构造二叉树</span><span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> nodes<span class="token punctuation">:</span>       <span class="token keyword">return</span> <span class="token boolean">None</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 后序位置</span>    first <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> first <span class="token operator">==</span> <span class="token string">'NULL'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然上述代码是错误的，变量都没声明呢，就开始用了？生搬硬套肯定是行不通的，回想刚才我们前序遍历方法中的 <code>deserialize</code> 方法，第一件事情在做什么？</p><p><strong><code>deserialize</code> 方法首先寻找 <code>root</code> 节点的值，然后递归计算左右子节点</strong>。那么我们这里也应该顺着这个基本思路走，后序遍历中，<code>root</code> 节点的值能不能找到？</p><p>再看一眼刚才的图：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/2.jpeg" alt="img"></p><p>在后序遍历结果中，<code>root</code> 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 <code>root</code>，然后递归调用生成 <code>root</code> 的左右子树。</p><p><strong>注意，根据上图，从后往前在 <code>nodes</code> 列表中取元素，一定要先构造 <code>root.right</code> 子树，后构造 <code>root.left</code> 子树</strong>。</p><p>看完整代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 主函数，将二叉树序列化为字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        sb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sb<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>            <span class="token keyword">return</span>                self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>        <span class="token comment"># ****** 后序位置 ********</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>        <span class="token comment"># ***********************</span>    <span class="token comment"># 主函数，将字符串反序列化为二叉树结构</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 将分割结果中的空字符串过滤掉</span>        nodes <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 辅助函数，通过 nodes 列表构造二叉树</span>    <span class="token keyword">def</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nodes <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 从后往前取出元素</span>        last <span class="token operator">=</span> nodes<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">if</span> last <span class="token operator">==</span> self<span class="token punctuation">.</span>NULL <span class="token keyword">or</span> last <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 先构造右子树，后构造左子树</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>_deserialize<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，后序遍历实现的序列化、反序列化方法也都实现了。</p><h2 id="四、中序遍历解法"><a href="#四、中序遍历解法" class="headerlink" title="四、中序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E5%9B%9B%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">四、中序遍历解法</a></h2><p>先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 <code>deserialize</code>。</p><p>序列化方法 <code>serialize</code> 依然容易，只要把辅助函数 <code>_serialize</code> 中的字符串的拼接操作放到中序遍历的位置就行了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 辅助函数，将二叉树存入 StringBuilder</span><span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> sb<span class="token punctuation">:</span> <span class="token string">'List[str]'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>NULL<span class="token punctuation">)</span>        sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>        <span class="token keyword">return</span>    serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sb<span class="token punctuation">)</span>    <span class="token comment"># ******* 中序位置 *******</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>    sb<span class="token punctuation">.</span>append<span class="token punctuation">(</span>SEP<span class="token punctuation">)</span>    <span class="token comment"># ***********************</span>    serialize<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，我们刚才说了，要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p><p>你看上面这段中序遍历的代码，<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p><h2 id="五、层级遍历解法"><a href="#五、层级遍历解法" class="headerlink" title="五、层级遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%BA%94%E3%80%81%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">五、层级遍历解法</a></h2><p>先写出 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树遍历基础</a> 中的层级遍历代码框架：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># 初始化队列，将 root 加入队列</span>    q <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>        sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 层级遍历代码位置</span>            cur <span class="token operator">=</span> q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># *************</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上述代码是标准的二叉树层级遍历框架</strong>，从上到下，从左到右打印每一层二叉树节点的值，可以看到，队列 <code>q</code> 中不会存在 null 指针。</p><p>不过我们在反序列化的过程中是需要记录空指针 null 的，所以可以把标准的层级遍历框架略作修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>         <span class="token keyword">return</span>    <span class="token comment"># 初始化队列，将 root 加入队列</span>    q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>        sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 层级遍历代码位置</span>            <span class="token keyword">if</span> cur <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                 <span class="token keyword">continue</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># **************</span>            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样也可以完成层级遍历，只不过我们把对空指针的检验从「将元素加入队列」的时候改成了「从队列取出元素」的时候。</p><p>那么我们完全仿照这个框架即可写出序列化方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 将二叉树序列化为字符串</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span>        <span class="token comment"># 初始化队列，将 root 加入队列</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment"># 层级遍历代码位置</span>                <span class="token keyword">if</span> cur <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>NULL<span class="token punctuation">)</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>                    <span class="token keyword">continue</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span>                <span class="token comment"># ***************</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> Codec<span class="token punctuation">.</span>SEP<span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>层级遍历序列化得出的结果如下图：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/3.jpeg" alt="img"></p><p>可以看到，每一个非空节点都会对应两个子节点，<strong>那么反序列化的思路也是用队列进行层级遍历，同时用索引 <code>index</code> 记录对应子节点的位置</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    SEP <span class="token operator">=</span> <span class="token string">","</span>    NULL <span class="token operator">=</span> <span class="token string">"#"</span>    <span class="token comment"># 将字符串反序列化为二叉树结构</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> data <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 将分割结果中的空字符串过滤掉</span>        nodes <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> data<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>SEP<span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">]</span>        <span class="token comment"># 第一个元素就是 root 的值</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 队列 q 记录父节点，将 root 加入队列</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># index 变量记录正在序列化的节点在数组中的位置</span>        index <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> q<span class="token punctuation">:</span>            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>                parent <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 为父节点构造左侧子节点</span>                left <span class="token operator">=</span> nodes<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                index <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> left <span class="token operator">!=</span> self<span class="token punctuation">.</span>NULL<span class="token punctuation">:</span>                    parent<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token comment"># 为父节点构造右侧子节点</span>                right <span class="token operator">=</span> nodes<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                index <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> right <span class="token operator">!=</span> self<span class="token punctuation">.</span>NULL<span class="token punctuation">:</span>                    parent<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                            <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难发现，这个反序列化的代码逻辑也是标准的二叉树层级遍历的代码衍生出来的。我们的函数通过 <code>nodes[index]</code> 来计算左右子节点，接到父节点上并加入队列，一层一层地反序列化出来一棵二叉树。</p><h1 id="二叉搜索树心法（特性篇）"><a href="#二叉搜索树心法（特性篇）" class="headerlink" title="二叉搜索树心法（特性篇）"></a>二叉搜索树心法（特性篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/">1038. Binary Search Tree to Greater Sum Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a></td><td align="center"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></td><td align="center">🟠</td></tr></tbody></table><p>前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树结构基础</a></li><li><a href="https://labuladong.online/algo/data-structure-basic/binary-tree-traverse-basic/">二叉树的 DFS&#x2F;BFS 遍历</a></li></ul><p>前文手把手带你刷二叉树已经写了 <a href="https://labuladong.online/algo/data-structure/binary-tree-part1/">思维篇</a>，<a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">构造篇</a>，<a href="https://labuladong.online/algo/data-structure/binary-tree-part3/">后序篇</a> 和 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">序列化篇</a>。</p><p>今天开启二叉搜索树（Binary Search Tree，后文简写 BST）的系列文章，手把手带你刷 BST。</p><p>首先，BST 的特性大家应该都很熟悉了（详见基础知识章节的 <a href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础</a>）：</p><p>1、对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。</p><p>2、对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</p><p>二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p><p><strong>从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</strong>。</p><p>也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    <span class="token comment"># 中序遍历代码位置</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么根据这个性质，我们来做两道算法题。</p><h2 id="寻找第-K-小的元素"><a href="#寻找第-K-小的元素" class="headerlink" title="寻找第 K 小的元素"></a><a href="https://labuladong.online/algo/data-structure/bst-part1/#%E5%AF%BB%E6%89%BE%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">寻找第 K 小的元素</a></h2><p>这是力扣第 230 题「<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第 K 小的元素</a>」，看下题目：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">230. 二叉搜索树中第K小的元素</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉搜索树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>，请你设计一个算法查找其中第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><strong style="font-weight: 600;">&nbsp;</strong>小的元素（从 1 开始计数）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/28/kthtree1.jpg" style="max-width: 100%; width: 212px; height: 301px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,1,4,null,2], k = 1<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/28/kthtree2.jpg" style="max-width: 100%; width: 382px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,3,6,2,4,null,null,1], k = 3<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>小的值，你将如何优化算法？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 230. 二叉搜索树中第K小的元素</a>。</strong></details><p>这个需求很常见吧，一个直接的思路就是升序排序，然后找第 <code>k</code> 个元素呗。BST 的中序遍历其实就是升序排序的结果，找第 <code>k</code> 个元素肯定不是什么难事。</p><p>按照这个思路，可以直接写出代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录结果</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 记录当前元素的排名</span>        self<span class="token punctuation">.</span>rank <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 利用 BST 的中序遍历特性</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token comment"># 中序代码位置</span>        self<span class="token punctuation">.</span>rank <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">:</span>            <span class="token comment"># 找到第 k 小的元素</span>            self<span class="token punctuation">.</span>res <span class="token operator">=</span> root<span class="token punctuation">.</span>val            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_kth-smallest-element-in-a-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_kth-smallest-element-in-a-bst" src="https://labuladong.online/algo-visualize/leetcode/kth-smallest-element-in-a-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这道题就做完了，不过呢，还是要多说几句，因为这个解法并不是最高效的解法，而是仅仅适用于这道题。</p><p>我们后文 <a href="https://labuladong.online/algo/practice-in-action/find-median-from-data-stream/">高效计算数据流的中位数</a> 中就提过今天的这个问题：</p><p>Info</p><p>如果让你实现一个在二叉搜索树中通过排名计算对应元素的方法 <code>select(int k)</code>，你会怎么设计？</p><p>如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第 <code>k</code> 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)<em>O</em>(<em>N</em>)，<code>N</code> 是 BST 的节点个数。</p><p>要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 O(logN)<em>O</em>(<em>l<strong>o</strong>g**N</em>) 的复杂度，让你算一个第 <code>k</code> 小元素，时间复杂度竟然要 O(N)<em>O</em>(<em>N</em>)，有点低效了。</p><p>所以说，计算第 <code>k</code> 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。</p><p>我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。</p><p>那么回到这个问题，想找到第 <code>k</code> 小的元素，或者说找到排名为 <code>k</code> 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p><p>比如说你让我查找排名为 <code>k</code> 的元素，当前节点知道自己排名第 <code>m</code>，那么我可以比较 <code>m</code> 和 <code>k</code> 的大小：</p><p>1、如果 <code>m == k</code>，显然就是找到了第 <code>k</code> 个元素，返回当前节点就行了。</p><p>2、如果 <code>k &lt; m</code>，那说明排名第 <code>k</code> 的元素在左子树，所以可以去左子树搜索第 <code>k</code> 个元素。</p><p>3、如果 <code>k &gt; m</code>，那说明排名第 <code>k</code> 的元素在右子树，所以可以去右子树搜索第 <code>k - m - 1</code> 个元素。</p><p>这样就可以将时间复杂度降到 O(logN)<em>O</em>(<em>l<strong>o</strong>g**N</em>) 了。</p><p>那么，如何让每一个节点知道自己的排名呢？</p><p>这就是我们之前说的，需要在二叉树节点中维护额外信息。<strong>每个节点需要记录，以自己为根的这棵二叉树有多少个节点</strong>。</p><p>也就是说，我们 <code>TreeNode</code> 中的字段应该如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token comment"># 以该节点为根的树的节点总数</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了 <code>size</code> 字段，外加 BST 节点左小右大的性质，对于每个节点 <code>node</code> 就可以通过 <code>node.left</code> 推导出 <code>node</code> 的排名，从而做到我们刚才说到的对数级算法。</p><p>当然，<code>size</code> 字段需要在增删元素的时候需要被正确维护，力扣提供的 <code>TreeNode</code> 是没有 <code>size</code> 这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。</p><h2 id="BST-转化累加树"><a href="#BST-转化累加树" class="headerlink" title="BST 转化累加树"></a><a href="https://labuladong.online/algo/data-structure/bst-part1/#bst-%E8%BD%AC%E5%8C%96%E7%B4%AF%E5%8A%A0%E6%A0%91">BST 转化累加树</a></h2><p>力扣第 538 题和 1038 题都是这道题，完全一样，你可以把它们一块做掉。看下题目：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">538. 把二叉搜索树转换为累加树</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/convert-bst-to-greater-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出二叉<strong style="font-weight: 600;"><span>&nbsp;</span>搜索<span>&nbsp;</span></strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">node.val</code>&nbsp;的值之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;">提醒一下，二叉搜索树满足下列约束条件：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点的左子树仅包含键<strong style="font-weight: 600;"><span>&nbsp;</span>小于<span>&nbsp;</span></strong>节点键的节点。</li><li>节点的右子树仅包含键<strong style="font-weight: 600;"><span>&nbsp;</span>大于</strong><span>&nbsp;</span>节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong>本题和 1038:&nbsp;<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a><span>&nbsp;</span>相同</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/05/03/tree.png" style="max-width: 100%; height: 364px; width: 534px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<strong style="font-weight: 600;">输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,null,1]<strong style="font-weight: 600;">输出：</strong>[1,null,1]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,2]<strong style="font-weight: 600;">输出：</strong>[3,3,2]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,2,4,1]<strong style="font-weight: 600;">输出：</strong>[7,9,4,10]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li><li>每个节点的值介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup></code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code>&nbsp;之间。</li><li>树中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong><span>&nbsp;</span>。</li><li>给定的树为二叉搜索树。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 538. 把二叉搜索树转换为累加树</a>。</strong></details><p>题目应该不难理解，比如图中的节点 5，转化成累加树的话，比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8&#x3D;26。</p><p>我们需要把 BST 转化成累加树，函数签名如下：</p><pre class="line-numbers language-none"><code class="language-none">def convertBST(root: TreeNode) -&gt; TreeNode:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照二叉树的通用思路，需要思考每个节点应该做什么，但是这道题上很难想到什么思路。</p><p>BST 的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？</p><p>这是不行的。对于一个节点来说，确实右子树都是比它大的元素，但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。</p><p><strong>此路不通，我们不妨换一个思路，还是利用 BST 的中序遍历特性</strong>。</p><p>刚才我们说了 BST 的中序遍历代码可以升序打印节点的值，那如果我想降序打印节点的值怎么办？</p><p>很简单，只要把递归顺序改一下，先遍历右子树，后遍历左子树就行了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># 先递归遍历右子树</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 中序遍历代码位置</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token comment"># 后递归遍历左子树</span>    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 <code>sum</code>，然后把 <code>sum</code> 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗</strong>？</p><p>看下代码就明白了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 记录累加和</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">def</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 维护累加和</span>            self<span class="token punctuation">.</span><span class="token builtin">sum</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>val            <span class="token comment"># 将 BST 转化成累加树</span>            root<span class="token punctuation">.</span>val <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">sum</span>            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_convert-bst-to-greater-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_convert-bst-to-greater-tree" src="https://labuladong.online/algo-visualize/leetcode/convert-bst-to-greater-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这道题就解决了，核心还是 BST 的中序遍历特性，只不过我们修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。</p><p>简单总结下吧，BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。</p><h1 id="二叉搜索树心法（基操篇）"><a href="#二叉搜索树心法（基操篇）" class="headerlink" title="二叉搜索树心法（基操篇）"></a>二叉搜索树心法（基操篇）</h1><p>本文讲解的例题</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></td><td align="center"><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td><td align="center">🟢</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></td><td align="center"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></td><td align="center">🟠</td></tr></tbody></table><p>我们前文 <a href="https://labuladong.online/algo/data-structure/bst-part1/">二叉搜索树心法（特性篇）</a> 介绍了 BST 的基本特性，还利用二叉搜索树「中序遍历有序」的特性来解决了几道题目，本文来实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中「删」和「判断合法性」略微复杂。</p><p>BST 的基础操作主要依赖「左小右大」的特性，可以在二叉树中做类似二分搜索的操作，寻找一个元素的效率很高。比如下面这就是一棵合法的二叉树：</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/0.png" alt="img"></p><p>对于 BST 相关的问题，你可能会经常看到类似下面这样的代码逻辑：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">BST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">:</span>        <span class="token comment"># 找到目标，做点什么</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>        BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> target<span class="token punctuation">:</span>        BST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。接下来看下 BST 这种结构的基础操作是如何实现的。</p><h2 id="一、判断-BST-的合法性"><a href="#一、判断-BST-的合法性" class="headerlink" title="一、判断 BST 的合法性"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E4%B8%80%E3%80%81%E5%88%A4%E6%96%AD-bst-%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7">一、判断 BST 的合法性</a></h2><p>力扣第 98 题「<a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a>」就是让你判断输入的 BST 是否合法：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">98. 验证二叉搜索树</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/validate-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/validate-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，判断其是否是一个有效的二叉搜索树。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">有效</strong><span>&nbsp;</span>二叉搜索树定义如下：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点的左<span data-keyword="subtree">子树</span>只包含<strong style="font-weight: 600;"><span>&nbsp;</span>小于<span>&nbsp;</span></strong>当前节点的数。</li><li>节点的右子树只包含<span>&nbsp;</span><strong style="font-weight: 600;">大于</strong><span>&nbsp;</span>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/01/tree1.jpg" style="max-width: 100%; width: 302px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,3]<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/12/01/tree2.jpg" style="max-width: 100%; width: 422px; height: 292px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,1,4,null,null,3,6]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点数目范围在<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup><span>&nbsp;</span>&lt;= Node.val &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 98. 验证二叉搜索树</a>。</strong></details><p>注意，这里是有坑的哦。按照 BST 左小右大的特性，每个节点想要判断自己是否是合法的 BST 节点，要做的事不就是比较自己和左右孩子吗？感觉应该这样写代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># root 的左边应该更小</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment"># root 的右边应该更大</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的<strong>所有</strong>节点，下面这个二叉树显然不是 BST，因为节点 <code>7</code> 的左子树中有一个节点 <code>8</code>，但是我们的算法会把它判定为合法 BST：</p><p>7418910</p><p><strong>错误的原因在于，对于每一个节点 <code>root</code>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，<code>root</code> 的整个左子树都要小于 <code>root.val</code>，整个右子树都要大于 <code>root.val</code></strong>。</p><p>问题是，对于某一个节点 <code>root</code>，他只能管得了自己的左右子节点，怎么把 <code>root</code> 的约束传递给左右子树呢？请看正确的代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment"># 定义：该函数返回 root 为根的子树的所有节点是否满足 max.val > root.val > min.val</span>    <span class="token keyword">def</span> <span class="token function">_isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># base case</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment"># 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span>        <span class="token keyword">if</span> <span class="token builtin">min</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> <span class="token builtin">min</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> <span class="token builtin">max</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">>=</span> <span class="token builtin">max</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 根据定义，限定左子树的最大值是 root.val，右子树的最小值是 root.val</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>_isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_validate-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_validate-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/validate-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧。</p><h2 id="在-BST-中搜索元素"><a href="#在-BST-中搜索元素" class="headerlink" title="在 BST 中搜索元素"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E5%9C%A8-bst-%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%85%83%E7%B4%A0">在 BST 中搜索元素</a></h2><p>力扣第 700 题「<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a>」就是让你在 BST 中搜索值为 <code>target</code> 的节点，函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是在一棵普通的二叉树中寻找，可以这样写代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> root    <span class="token comment"># 当前节点没找到就递归地去左右子树寻找</span>    left <span class="token operator">=</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    right <span class="token operator">=</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有二叉树。那么应该如何充分利用 BST 的特殊性，把「左小右大」的特性用上？</p><p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 <code>target</code> 和 <code>root.val</code> 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：在以 root 为根的 BST 中搜索值为 target 的节点，返回该节点</span><span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>    <span class="token comment"># 如果二叉树为空，直接返回</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token comment"># 去左子树搜索</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token comment"># 去右子树搜索</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token comment"># 当前节点就是目标值</span>    <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_search-in-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_search-in-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/search-in-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="在-BST-中插入一个数"><a href="#在-BST-中插入一个数" class="headerlink" title="在 BST 中插入一个数"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E5%9C%A8-bst-%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0">在 BST 中插入一个数</a></h2><p>对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p>因为 BST 一般不会存在值重复的节点，所以我们一般不会在 BST 中插入已存在的值。<strong>下面的代码都默认不会向 BST 中插入已存在的值</strong>。</p><p>上一个问题，我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。</p><p><strong>一旦涉及「改」，就类似二叉树的构造问题，函数要返回 <code>TreeNode</code> 类型，并且要对递归调用的返回值进行接收</strong>。</p><p>力扣第 701 题「<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a>」就是这个问题：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">701. 二叉搜索树中的插入操作</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉搜索树（BST）的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;和要插入树中的值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">value</code>&nbsp;，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据<span>&nbsp;</span><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>，新值和原始二叉搜索树中的任意节点值都不同。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回<span>&nbsp;</span><strong style="font-weight: 600;">任意有效的结果</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/05/insertbst.jpg" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,2,7,1,3], val = 5<strong style="font-weight: 600;">输出：</strong>[4,2,7,1,3,5]<strong style="font-weight: 600;">解释：</strong>另一个满足题目要求可以通过的树是：<img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/10/05/bst.jpg" style="max-width: 100%;"></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [40,20,60,10,30,50,70], val = 25<strong style="font-weight: 600;">输出：</strong>[40,20,60,10,30,50,70,null,null,25]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,2,7,1,3,null,null,null,null,null,null], val = 5<strong style="font-weight: 600;">输出：</strong>[4,2,7,1,3,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数将在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,&nbsp;10<sup>4</sup>]</code>的范围内。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>8</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>8</sup></code></li><li>所有值&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;是&nbsp;<strong style="font-weight: 600;">独一无二</strong>&nbsp;的。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>8</sup>&nbsp;&lt;= val &lt;= 10<sup>8</sup></code></li><li><strong style="font-weight: 600;">保证</strong>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code>&nbsp;在原始BST中不存在。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 701. 二叉搜索树中的插入操作</a>。</strong></details><p>直接看解法代码吧，可以结合注释和可视化面板的来理解：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：在以 root 为根的 BST 中插入 val 节点，返回插入后的根节点</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>            <span class="token comment"># 找到空位置插入新节点</span>            <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 去右子树找插入位置</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token comment"># 去左子树找插入位置</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> val<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>insertIntoBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token comment"># 返回 root，上层递归会接收返回值作为子节点</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_insert-into-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_insert-into-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/insert-into-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="三、在-BST-中删除一个数"><a href="#三、在-BST-中删除一个数" class="headerlink" title="三、在 BST 中删除一个数"></a><a href="https://labuladong.online/algo/data-structure/bst-part2/#%E4%B8%89%E3%80%81%E5%9C%A8-bst-%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%95%B0">三、在 BST 中删除一个数</a></h2><p>力扣第 450 题「<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a>」就是让你在 BST 中删除一个值为 <code>key</code> 的节点：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">450. 删除二叉搜索树中的节点</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/delete-node-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/delete-node-in-a-bst/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉搜索树的根节点<span>&nbsp;</span><strong style="font-weight: 600;">root<span>&nbsp;</span></strong>和一个值<span>&nbsp;</span><strong style="font-weight: 600;">key</strong>，删除二叉搜索树中的&nbsp;<strong style="font-weight: 600;">key&nbsp;</strong>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一般来说，删除节点可分为两个步骤：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2020/09/04/del_node_1.jpg" style="max-width: 100%; width: 800px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [5,3,6,2,4,null,7], key = 3<strong style="font-weight: 600;">输出：</strong>[5,4,6,2,null,null,7]<strong style="font-weight: 600;">解释：</strong>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。<img src="https://labuladong.online/algo/images/lc/uploads/2020/09/04/del_node_supp.jpg" style="max-width: 100%; width: 350px;"></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [5,3,6,2,4,null,7], key = 0<strong style="font-weight: 600;">输出:</strong> [5,3,6,2,4,null,7]<strong style="font-weight: 600;">解释:</strong> 二叉树不包含值为 0 的节点</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [], key = 0<strong style="font-weight: 600;">输出:</strong> []</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数的范围&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 10<sup>4</sup>]</code>.</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li><li>节点值唯一</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;是合法的二叉搜索树</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= key &lt;= 10<sup>5</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong><span>&nbsp;</span>要求算法时间复杂度为&nbsp;O(h)，h 为树的高度。</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 450. 删除二叉搜索树中的节点</a>。</strong></details><p>这个问题稍微复杂，跟插入操作类似，先「找」再「改」，先把框架写出来再说：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">:</span>        <span class="token comment"># 找到啦，进行删除</span>    <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> key<span class="token punctuation">:</span>        <span class="token comment"># 去左子树找</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>        <span class="token comment"># 去右子树找</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>找到目标节点了，比方说是节点 <code>A</code>，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p><p><strong>情况 1</strong>：<code>A</code> 恰好是末端节点，两个子节点都为空，那么它可以直接被删除。</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/bst_deletion_case_1.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;</span><span class="token operator">&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>情况 2</strong>：<code>A</code> 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/bst_deletion_case_2.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 排除了情况 <span class="token number">1</span> 之后<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>情况 3</strong>：<code>A</code> 有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code> 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p><p><img src="/2025/07/24/er-cha-shu-xin-fa-xu-lie-hua-pian/bst_deletion_case_3.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;</span><span class="token operator">&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">//</span> 找到右子树的最小节点    TreeNode minNode <span class="token operator">=</span> getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 把 root 改成 minNode    root<span class="token punctuation">.</span>val <span class="token operator">=</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token operator">//</span> 转而去删除 minNode    root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种情况分析完毕，填入框架，简化一下代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：在以 root 为根的 BST 中删除值为 key 的节点，返回完成删除后的根节点</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">:</span>            <span class="token comment"># 这两个 if 把情况 1 和 2 都正确处理了</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root<span class="token punctuation">.</span>right            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root<span class="token punctuation">.</span>left            <span class="token comment"># 处理情况 3</span>            <span class="token comment"># 获得右子树最小的节点</span>            minNode <span class="token operator">=</span> self<span class="token punctuation">.</span>getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment"># 删除右子树最小的节点</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment"># 用右子树最小的节点替换 root 节点</span>            minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left            minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right            root <span class="token operator">=</span> minNode        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> key<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># BST 最左边的就是最小的</span>        <span class="token keyword">while</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left        <span class="token keyword">return</span> node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_delete-node-in-a-bst" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_delete-node-in-a-bst" src="https://labuladong.online/algo-visualize/leetcode/delete-node-in-a-bst/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，删除操作就完成了。注意一下，上述代码在处理情况 3 时通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 处理情况 <span class="token number">3</span><span class="token operator">//</span> 获得右子树最小的节点TreeNode minNode <span class="token operator">=</span> getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 删除右子树最小的节点root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 用右子树最小的节点替换 root 节点minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>root <span class="token operator">=</span> minNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有的读者可能会疑惑，替换 <code>root</code> 节点为什么这么麻烦，直接改 <code>val</code> 字段不就行了？看起来还更简洁易懂：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 处理情况 <span class="token number">3</span><span class="token operator">//</span> 获得右子树最小的节点TreeNode minNode <span class="token operator">=</span> getMin<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 删除右子树最小的节点root<span class="token punctuation">.</span>right <span class="token operator">=</span> deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">//</span> 用右子树最小的节点替换 root 节点root<span class="token punctuation">.</span>val <span class="token operator">=</span> minNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅对于这道算法题来说是可以的，但这样操作并不完美，我们一般不会通过修改节点内部的值来交换节点。因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。</p><p>最后简单总结一下吧，通过这篇文章，我们总结出了如下几个技巧：</p><p>1、如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p><p>2、掌握 BST 的增删查改方法。</p><p>3、递归修改数据结构时，需要对递归调用的返回值进行接收，并返回修改后的节点。</p>]]></content>
      
      
      <categories>
          
          <category> 二叉树算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/28/pip-pei-zhi/"/>
      <url>/2025/06/28/pip-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>如果想永久使用清华镜像，可以修改 pip 配置文件：</p><p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【练习】单调队列的通用实现及经典习题</title>
      <link href="/2025/06/14/lian-xi-dan-diao-dui-lie-de-tong-yong-shi-xian-ji-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-dan-diao-dui-lie-de-tong-yong-shi-xian-ji-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】单调队列的通用实现及经典习题"><a href="#【练习】单调队列的通用实现及经典习题" class="headerlink" title="【练习】单调队列的通用实现及经典习题"></a>【练习】单调队列的通用实现及经典习题</h1><h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0">通用实现</a></h2><p>我先提供一个单调队列结构的通用实现，这里涉及 Java 的泛型，<code>E</code> 就代表任意类型，<code>E extends Comparable&lt;E&gt;</code> 的意思是这个类型 <code>E</code> 需要实现 <code>Comparable</code> 接口，即类型 <code>E</code> 是可比较的，比如 <code>Integer, String</code> 这种实现了 <code>compareTo</code> 方法的类型。原因也很好理解，因为你要求队列中元素的最值嘛，所以元素当然得是有大小之分（可比较）的。</p><p>我们原先的简陋实现包含了 <code>max</code> 方法的实现，其原理是在底层维护了一个队列 <code>maxq</code>，维护这个队列中从尾部到头部的元素单调递增。</p><p>那么实现 <code>min</code> 方法也是类似的，可以<strong>在底层再维护一个 <code>minq</code> 队列</strong>，维护队列中元素从尾部到头部的元素单调递减，这样头部第一个元素就是所有元素中的最小值了。</p><p>当然，由于 <code>push</code> 方法在添加元素的同时还可能会删除元素，所以 <code>maxq</code> 和 <code>minq</code> 中都没有保存所有元素。如果想实现标准的 <code>pop</code> 方法以及 <code>size</code> 方法，<strong>我们还得再额外维护一个标准队列 <code>q</code></strong>，这个 <code>q</code> 存储所有存在于队列中的元素，不维护单调性。</p><p>综上，可以得到 <code>MonotonicQueue</code> 的通用实现，具体逻辑看注释：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> TypeVar<span class="token punctuation">,</span> GenericE <span class="token operator">=</span> TypeVar<span class="token punctuation">(</span><span class="token string">'E'</span><span class="token punctuation">)</span><span class="token comment"># 单调队列的实现，可以高效维护最大值和最小值</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">(</span>Generic<span class="token punctuation">[</span>E<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 常规队列，存储所有元素</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> E<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> E<span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> E<span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> E<span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">assert</span> deleteVal <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这个通用实现内部维护了三个队列，且涉及到 Java 的泛型，所以在刷题平台上执行的效率不会高，如果你追求效率的话，可以根据具体的题目简化单调队列的实现，从而提升效率。下面看几道单调队列的经典应用。</p><h2 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列 + 滑动窗口"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">单调队列 + 滑动窗口</a></h2><p>单调队列可以和 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口</a> 算法结合，在窗口滑动的过程中快速计算窗口内部的最值。</p><hr><h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit">1438. 绝对差不超过限制的最长连续子数组</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1438. 绝对差不超过限制的最长连续子数组</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>，和一个表示限制的整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">limit</code><em><span>&nbsp;</span>。</em></p><p style="line-height: 1.6; overflow-wrap: break-word;">如果不存在满足条件的子数组，则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [8,2,4,7], limit = 4<strong style="font-weight: 600;">输出：</strong>2 <strong style="font-weight: 600;">解释：</strong>所有子数组如下：[8] 最大绝对差 |8-8| = 0 &lt;= 4.[8,2] 最大绝对差 |8-2| = 6 &gt; 4. [8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.[2] 最大绝对差 |2-2| = 0 &lt;= 4.[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.[4] 最大绝对差 |4-4| = 0 &lt;= 4.[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.[7] 最大绝对差 |7-7| = 0 &lt;= 4. 因此，满足题意的最长子数组的长度为 2 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [10,1,2,4,7,2], limit = 5<strong style="font-weight: 600;">输出：</strong>4 <strong style="font-weight: 600;">解释：</strong>满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [4,2,2,2,4,4,2,2], limit = 0<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums[i] &lt;= 10^9</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= limit &lt;= 10^9</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1438. 绝对差不超过限制的最长连续子数组</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>很明显这道题需要用到前文讲的 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口技巧核心框架详解</a>：</p><p>当窗口内绝对值之差不超过 <code>limit</code> 时扩大窗口，当新加入窗口的元素使得绝对值之差超过 <code>limit</code> 时开始收缩窗口，窗口的最大宽度即最长子数组的长度。</p><p>但有个问题，当窗口进新元素时，我可以更新窗口中的最大值和最小值，但当窗口收缩时，如何更新最大值和最小值呢？难道要遍历一遍窗口中的所有元素吗？这就用到单调队列结构了，这里需要一个通用的 <code>MonotonicQueue</code> 类，用来高效判断窗口中的最大值和最小值。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token number">0</span>        windowSize <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 滑动窗口模板</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 扩大窗口，更新窗口最值</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            windowSize <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> window<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> window<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> limit<span class="token punctuation">:</span>                <span class="token comment"># 缩小窗口，更新窗口最值</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                windowSize <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token comment"># 在窗口收缩判断完之后才更新答案</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> windowSize<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 常规队列，存储所有元素</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" src="https://labuladong.online/algo-visualize/leetcode/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="862-和至少为-K-的最短子数组"><a href="#862-和至少为-K-的最短子数组" class="headerlink" title="862. 和至少为 K 的最短子数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_shortest-subarray-with-sum-at-least-k">862. 和至少为 K 的最短子数组</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">862. 和至少为 K 的最短子数组</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>，找出<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>中和至少为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">最短非空子数组</strong><span>&nbsp;</span>，并返回该子数组的长度。如果不存在这样的<span>&nbsp;</span><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>是数组中<span>&nbsp;</span><strong style="font-weight: 600;">连续</strong><span>&nbsp;</span>的一部分。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1], k = 1<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,2], k = 4<strong style="font-weight: 600;">输出：</strong>-1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [2,-1,2], k = 3<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= 10<sup>9</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 862. 和至少为 K 的最短子数组</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这题的难度是比较大的，难点在于同时结合了 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法</a>、<a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 和 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列</a> 几个知识点，建议你先理解这三篇文章的要义，否则看不懂这题的解法。</p><p>首先，想要快速记录子数组的和，需要 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 预计算一个 <code>preSum</code> 数组，然后在这个 <code>preSum</code> 数组上施展 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法</a> 寻找一个差值大于等于 <code>k</code> 且宽度最小的「窗口」，这个窗口的大小就是题目想要的结果。</p><p>这里面还有个问题，当滑动窗口扩大时，新进入窗口的元素 <code>preSum[right]</code> 需要知道窗口中最小的那个元素是多少，和最小的那个元素相减才能得到尽可能大的子数组和。</p><p>如何快速判断窗口中的最值？这就需要单调队列结构出马了，直接看解法代码吧。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">shortestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 看题目的数据范围，前缀和数组中元素可能非常大，所以用 long 类型</span>        preSum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        preSum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 计算 nums 的前缀和数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment"># 单调队列结构辅助滑动窗口算法</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        right <span class="token operator">=</span> <span class="token number">0</span>        left <span class="token operator">=</span> <span class="token number">0</span>        length <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 开始执行滑动窗口算法框架</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 扩大窗口，元素入队</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>preSum<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 若新进入窗口的元素和窗口中的最小值之差大于等于 k，</span>            <span class="token comment"># 说明得到了符合条件的子数组，缩小窗口，使子数组长度尽可能小</span>            <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> window<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> preSum<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">-</span> window<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> k<span class="token punctuation">:</span>                <span class="token comment"># 更新答案</span>                length <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> right <span class="token operator">-</span> left<span class="token punctuation">)</span>                <span class="token comment"># 缩小窗口</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> length<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 常规队列，存储所有元素</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum">209. 长度最小的子数组 🟠</a></li><li><a href="https://leetcode.cn/problems/2VG8Kg">剑指 Offer II 008. 和大于等于 target 的最短子数组 🟠</a></li></ul><hr><h2 id="单调队列-环形数组"><a href="#单调队列-环形数组" class="headerlink" title="单调队列 + 环形数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84">单调队列 + 环形数组</a></h2><p>单调队列还可以在环形数组的场景下排上用场。之前 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈原理</a> 中讲了只要把数组的长度 <code>n</code> 加倍就可以模拟环形数组，但如果让你在环形数组中计算子数组的元素和就需要单调队列辅助了，因为你要保证子数组的长度不能超过 <code>n</code>。</p><hr><h2 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_maximum-sum-circular-subarray">918. 环形子数组的最大和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">918. 环形子数组的最大和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个长度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>的<strong style="font-weight: 600;">环形整数数组</strong>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;，返回<em>&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;的非空<span>&nbsp;</span><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>的最大可能和&nbsp;</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">环形数组</strong><em>&nbsp;</em>意味着数组的末端将会与开头相连呈环状。形式上，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code><span>&nbsp;</span>的下一个元素是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[(i + 1) % n]</code><span>&nbsp;</span>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code>&nbsp;的前一个元素是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[(i - 1 + n) % n]</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">子数组</strong><span>&nbsp;</span>最多只能包含固定缓冲区&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;中的每个元素一次。形式上，对于子数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i], nums[i + 1], ..., nums[j]</code>&nbsp;，不存在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt;= k1, k2 &lt;= j</code>&nbsp;其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k1 % n == k2 % n</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,-2,3,-2]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>从子数组 [3] 得到最大和 3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [5,-3,5]<strong style="font-weight: 600;">输出：</strong>10<strong style="font-weight: 600;">解释：</strong>从子数组 [5,5] 得到最大和 5 + 5 = 10</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [3,-2,2,-3]<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == nums.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-3 * 10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 918. 环形子数组的最大和</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>诚然，这道题有很巧妙的方法，你可以搜索一下「Kadane 算法」来解决这道题。不过为了举一反三地运用我之前讲过的算法技巧，我就结合 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列结构</a> 和前文 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 写一个更通用的解法。</p><p>首先，这道题和 <a href="https://leetcode.cn/problems/maximum-subarray">53. 最大子序和</a> 非常类似，区别在于本题的数组是环形的，所以上一题的动态规划思路和前缀和思路都不能直接套用过来。不过前文 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈结构详解</a> 中讲过处理环形数组的方法，其实就是把原数组大小扩大一倍，这样就能模拟出环形的效果了。</p><p>那么本题也可以把 <code>nums</code> 数组扩大一倍，计算前缀和数组 <code>preSum</code>，借助一个定长为 <code>nums.length</code> 的单调队列来计算环形数组中的最大子数组和。具体实现直接看代码吧。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubarraySumCircular</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 模拟环状的 nums 数组</span>        preSum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        preSum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 计算环状 nums 的前缀和</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span>        <span class="token comment"># 记录答案</span>        maxSum <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 维护一个滑动窗口，以便根据窗口中的最小值计算最大子数组和</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        window<span class="token punctuation">.</span>push<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxSum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> window<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 维护窗口的大小为 nums 数组的大小</span>            <span class="token keyword">if</span> window<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">:</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> maxSum<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 常规队列，存储所有元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_maximum-sum-circular-subarray" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_maximum-sum-circular-subarray" src="https://labuladong.online/algo-visualize/leetcode/maximum-sum-circular-subarray/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><hr><h2 id="单调队列-动态规划（选学）"><a href="#单调队列-动态规划（选学）" class="headerlink" title="单调队列 + 动态规划（选学）"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%89%E5%AD%A6">单调队列 + 动态规划（选学）</a></h2><p>动态规划很多时候会用到嵌套 for 循环计算最值，如果是计算一个窗口中的最值，可以利用单调队列结构维护最值，从而消除一层 for 循环，降低时间复杂度。</p><hr><h2 id="1696-跳跃游戏-VI"><a href="#1696-跳跃游戏-VI" class="headerlink" title="1696. 跳跃游戏 VI"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_jump-game-vi">1696. 跳跃游戏 VI</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1696. 跳跃游戏 VI</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/jump-game-vi/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/jump-game-vi/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始的整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一开始你在下标<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>处。每一步，你最多可以往前跳<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>步，但你不能跳出数组的边界。也就是说，你可以从下标<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>跳到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[i + 1， min(n - 1, i + k)]</code><span>&nbsp;</span><strong style="font-weight: 600;">包含</strong><span>&nbsp;</span>两个端点的任意位置。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你的目标是到达数组最后一个位置（下标为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n - 1</code><span>&nbsp;</span>），你的<span>&nbsp;</span><strong style="font-weight: 600;">得分</strong><span>&nbsp;</span>为经过的所有数字之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回你能得到的<span>&nbsp;</span><strong style="font-weight: 600;">最大得分</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>nums = [<strong style="font-weight: 600;">1</strong>,<strong style="font-weight: 600;">-1</strong>,-2,<strong style="font-weight: 600;">4</strong>,-7,<strong style="font-weight: 600;">3</strong>], k = 2<b>输出：</b>7<b>解释：</b>你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [<strong style="font-weight: 600;">10</strong>,-5,-2,<strong style="font-weight: 600;">4</strong>,0,<strong style="font-weight: 600;">3</strong>], k = 3<b>输出：</b>17<b>解释：</b>你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>nums = [1,-5,-20,4,-1,3,-6,-3], k = 2<b>输出：</b>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/jump-game-vi/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1696. 跳跃游戏 VI</a>。</strong></details><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这题和 <a href="https://leetcode.cn/problems/constrained-subsequence-sum">1425. 带限制的子序列和</a> 非常像：</p><p>1425 题是让你求最大子序列和，子序列中每两个元素之间的间隔不能超过 <code>k</code>；这道题其实也是让你求元素间隔不超过 <code>k</code> 的最大子序列和，只不过又多了些限制，即子序列的第一个元素必须是 <code>nums[0]</code>，最后一个元素必须是 <code>nums[-1]</code>。</p><p>你可以想办法复用第 1425 题的解法，不过我这里按照标准的 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划解题框架</a> 来逐步优化，最后通过 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列结构</a> 中给出的单调队列通用实现来优化动态规划解法的效率。</p><p>需要注意的是，本题使用标准的动态规划解法也会超时，这并不是动态规划的锅，而是本题给的数据规模太大，需要更先进的数据结构（单调队列）来优化状态转移的效率。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 第一步，暴力递归解法（超时）</span><span class="token keyword">class</span> <span class="token class-name">Solution1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>    <span class="token comment"># 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span>    <span class="token comment"># 能跳到 nums[p]，必然是从 nums[p-k..p-1] 中的某个位置跳来的</span>    <span class="token comment"># 故状态转移方程为：dp[p] = max(nums[p-k..p-1]) + nums[p]</span>    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> p <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 实现状态转移方程</span>        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">-</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">+=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span class="token comment"># 第二步，带备忘录的递归解法（超时）</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token comment"># 备忘录</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># 备忘录初始化为最小值</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>    <span class="token comment"># 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span>    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> p <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token comment"># 查备忘录，避免冗余计算</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token comment"># 实现状态转移方程，结果存入备忘录</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">-</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>memo<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token comment"># 第三步，自顶向下的递归改为自底向上的迭代解法（超时）</span><span class="token keyword">class</span> <span class="token class-name">Solution3</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 定义：到达 nums[p] 的最大分数为 dp[p]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># dp 数组初始化为最小值</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 状态转移</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p <span class="token operator">-</span> i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>p <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 第四步，利用单调队列结构消除内层循环（通过）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxResult</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 定义：到达 nums[p] 的最大分数为 dp[p]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># dp 数组初始化为最小值</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 状态转移</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>            <span class="token comment"># 维护窗口装着 dp[p-1..p-k]</span>            <span class="token keyword">if</span> window<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 常规队列，存储所有元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_jump-game-vi" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_jump-game-vi" src="https://labuladong.online/algo-visualize/leetcode/jump-game-vi/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1425-带限制的子序列和"><a href="#1425-带限制的子序列和" class="headerlink" title="1425. 带限制的子序列和"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#slug_constrained-subsequence-sum">1425. 带限制的子序列和</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1425. 带限制的子序列和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/constrained-subsequence-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/constrained-subsequence-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;和一个整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code>&nbsp;，请你返回<span>&nbsp;</span><strong style="font-weight: 600;">非空</strong>&nbsp;子序列元素和的最大值，子序列需要满足：子序列中每两个<span>&nbsp;</span><strong style="font-weight: 600;">相邻</strong>&nbsp;的整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[j]</code>&nbsp;，它们在原数组中的下标&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;满足&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt; j</code>&nbsp;且<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j - i &lt;= k</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [10,2,-10,5,20], k = 2<strong style="font-weight: 600;">输出：</strong>37<strong style="font-weight: 600;">解释：</strong>子序列为 [10, 2, 5, 20] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [-1,-2,-3], k = 1<strong style="font-weight: 600;">输出：</strong>-1<strong style="font-weight: 600;">解释：</strong>子序列必须是非空的，所以我们选择最大的数字。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [10,-2,-10,-5,20], k = 2<strong style="font-weight: 600;">输出：</strong>23<strong style="font-weight: 600;">解释：</strong>子序列为 [10, -2, -5, 20] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10^4&nbsp;&lt;= nums[i] &lt;= 10^4</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/constrained-subsequence-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1425. 带限制的子序列和</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>如果你看过后文 <a href="https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/">最长递增子序列问题详解</a>，那么这道题的思路应该是很简单的：</p><p><strong>设计一个 <code>dp</code> 数组，<code>dp[i]</code> 表示以 <code>nums[i]</code> 为结尾的最大子序列之和，然后题目要求的答案就是 <code>max(dp[..])</code></strong>。</p><p>由于题目说两个序列之间的间隔不能超过 <code>k</code>，所以 <code>dp[i]</code> 的值就可以根据 <code>dp[i-k..i-1]</code> 的值推导出来，那么状态转移逻辑就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        maxVal <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxVal <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想到这一步其实已经可以写出动态规划解法代码了，但由于测试数据的规模较大，这个 <code>O(KN)</code> 的算法会超时。</p><p>我们注意到内层的 for 循环实际上就是在计算 <code>dp[i-k..i-1]</code> 的最大值，随着 <code>i</code> 的增加，<code>dp[i-k..i-1]</code> 就像一个滑动前进的窗口，这个场景不需要傻乎乎用 for 循环遍历求最值，前文讲到的 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">单调队列</a> 可以高效实现这个过程，将整个算法的复杂度降低到 <code>O(N)</code>。</p><p>我将给出经过单调队列优化的解法代码和未经优化的解法代码，注意单调队列在其中起到的作用。</p><blockquote><p>PS：<code>MonotonicQueue</code> 的通用实现见 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列设计与实现</a></p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-queue/">【练习】单调队列的通用实现及经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 经过单调队列优化的动态规划解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constrainedSubsetSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 定义：dp[i] 表示以 nums[i] 结尾的子序列的最大和</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 单调队列辅助计算 dp[i-k..i-1] 的最大值</span>        window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>        window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 状态转移方程</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 维护滑动窗口的大小为 k</span>            <span class="token keyword">if</span> window<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>                window<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            window<span class="token punctuation">.</span>push<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment"># dp 数组中的最大值就是结果</span>        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment"># 下面给出的是单调队列的通用实现，运行速度可能较慢，你可以自行简化提升速度</span><span class="token comment"># 单调队列的详细解析见</span><span class="token comment"># https://labuladong.online/algo/problem-set/monotonic-queue/</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 常规队列，存储所有元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素降序排列的单调队列，头部是最大值</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 元素升序排列的单调队列，头部是最小值</span>        self<span class="token punctuation">.</span>minq <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 维护常规队列，直接在队尾插入元素</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 maxq，将小于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>maxq <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment"># 维护 minq，将大于 elem 的元素全部删除</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>minq <span class="token keyword">and</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> elem<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># maxq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># minq 的头部是最大元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 从标准队列头部弹出需要删除的元素</span>        deleteVal <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deleteVal <span class="token operator">==</span> self<span class="token punctuation">.</span>minq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>minq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> deleteVal    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 标准队列的大小即是当前队列的大小</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span class="token comment"># 未经优化的动态规划解法，超时</span><span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constrainedSubsetSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment"># 定义：dp[i] 表示以 nums[i] 结尾的子序列的最大和</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># base case，以 nums[0] 结尾的子序列只有它本身</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># 状态转移方程</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            maxVal <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                maxVal <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># dp[i] 的值可以根据 dp[i-k..i-1] 的最大值推导出来</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxVal <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># dp 数组中的最大值就是结果</span>        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列结构解决滑动窗口问题</title>
      <link href="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/"/>
      <url>/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列结构解决滑动窗口问题"><a href="#单调队列结构解决滑动窗口问题" class="headerlink" title="单调队列结构解决滑动窗口问题"></a>单调队列结构解决滑动窗口问题</h1><p>前文用 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈解决三道算法问题</a> 介绍了单调栈这种特殊数据结构，本文写一个类似的数据结构「单调队列」。</p><p>也许这种数据结构的名字你没听过，其实没啥难的，就是一个「队列」，只是使用了一点巧妙的方法，使得队列中的元素全都是单调递增（或递减）的。</p><p>为啥要发明「单调队列」这种结构呢，主要是为了解决下面这个场景：</p><p><strong>给你一个数组 <code>window</code>，已知其最值为 <code>A</code>，如果给 <code>window</code> 中添加一个数 <code>B</code>，那么比较一下 <code>A</code> 和 <code>B</code> 就可以立即算出新的最值；但如果要从 <code>window</code> 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 <code>A</code>，就需要遍历 <code>window</code> 中的所有元素重新寻找新的最值</strong>。</p><p>这个场景很常见，但不用单调队列似乎也可以，比如 <a href="https://labuladong.online/algo/data-structure-basic/binary-heap-basic/">优先级队列（二叉堆）</a> 就是专门用来动态寻找最值的，我创建一个大（小）顶堆，不就可以很快拿到最大（小）值了吗？</p><p>如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的<strong>时间顺序</strong>，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。</p><p>所以，现在需要一种新的队列结构，既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，这就是「单调队列」结构。</p><p>「单调队列」这个数据结构主要用来辅助解决滑动窗口相关的问题，前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口核心框架</a> 把滑动窗口算法作为双指针技巧的一部分进行了讲解，但有些稍微复杂的滑动窗口问题不能只靠两个指针来解决，需要上更先进的数据结构。</p><p>比方说，你注意看前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口核心框架</a> 讲的几道题目，每当窗口扩大（<code>right++</code>）和窗口缩小（<code>left++</code>）时，你单凭移出和移入窗口的元素即可决定是否更新答案。</p><p>但本文开头说的那个判断一个窗口中最值的例子，你无法单凭移出窗口的那个元素更新窗口的最值，除非重新遍历所有元素，但这样的话时间复杂度就上来了，这是我们不希望看到的。</p><p>我们来看看力扣第 239 题「<a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a>」，就是一道标准的滑动窗口问题：</p><p>给你输入一个数组 <code>nums</code> 和一个正整数 <code>k</code>，有一个大小为 <code>k</code> 的窗口在 <code>nums</code> 上从左至右滑动，请你输出每次窗口中 <code>k</code> 个元素的最大值。</p><p>函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如说力扣给出的一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>解释：滑动窗口的位置                最大值<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>               <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">3</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">3</span> <span class="token number">1</span>  <span class="token number">3</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span><span class="token punctuation">]</span> <span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">5</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span>  <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">6</span>  <span class="token number">7</span>       <span class="token number">5</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">5</span>  <span class="token number">3</span>  <span class="token number">6</span><span class="token punctuation">]</span> <span class="token number">7</span>       <span class="token number">6</span> <span class="token number">1</span>  <span class="token number">3</span>  <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">5</span> <span class="token punctuation">[</span><span class="token number">3</span>  <span class="token number">6</span>  <span class="token number">7</span><span class="token punctuation">]</span>      <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们就借助单调队列结构，用 O(1)<em>O</em>(1) 时间算出每个滑动窗口中的最大值，使得整个算法在线性时间完成。</p><h3 id="一、搭建解题框架"><a href="#一、搭建解题框架" class="headerlink" title="一、搭建解题框架"></a><a href="https://labuladong.online/algo/data-structure/monotonic-queue/#%E4%B8%80%E3%80%81%E6%90%AD%E5%BB%BA%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6">一、搭建解题框架</a></h3><p>在介绍「单调队列」这种数据结构的 API 之前，先来对比一下 <a href="https://labuladong.online/algo/data-structure-basic/queue-stack-basic/">普通的队列</a> 的标准 API 和单调队列实现的 API：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 普通队列的 API</span><span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">:</span>    <span class="token comment"># enqueue 操作，在队尾加入元素 n</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># dequeue 操作，删除队头元素</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token comment"># 单调队列的 API</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 在队尾添加元素 n</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 返回当前队列中的最大值</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 队头元素如果是 n，删除它</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，单调队列这几个 API 的实现方法肯定跟一般的 Queue 不一样，不过我们暂且不管，而且认为这几个操作的时间复杂度都是 O(1)，先把这道「滑动窗口」问题的解答框架搭出来：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    window <span class="token operator">=</span> MonotonicQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 先将窗口前 k - 1 填满</span>            window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 窗口开始向前滑动</span>            <span class="token comment"># 移入新元素</span>            window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 将当前窗口中的最大元素记入结果</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment"># 移出最后的元素</span>            window<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 将 List 类型转化成 int[] 数组作为返回值</span>    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/1-1749878196844-7.png" alt="img"></p><p>这个思路很简单吧，下面我们开始重头戏，单调队列的实现。</p><h3 id="二、实现单调队列数据结构"><a href="#二、实现单调队列数据结构" class="headerlink" title="二、实现单调队列数据结构"></a><a href="https://labuladong.online/algo/data-structure/monotonic-queue/#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">二、实现单调队列数据结构</a></h3><p>观察滑动窗口的过程就能发现，实现「单调队列」必须使用一种数据结构支持在头部和尾部进行插入和删除，很明显 <a href="https://labuladong.online/algo/data-structure-basic/linkedlist-basic/">双链表</a> 是满足这个条件的。</p><p>「单调队列」的核心思路和「单调栈」类似，<code>push</code> 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用双端队列，支持头部和尾部增删元素</span>        <span class="token comment"># 维护其中的元素自尾部到头部单调递增</span>        self<span class="token punctuation">.</span>maxq <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 在尾部添加一个元素 n，维护 maxq 的单调性质</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 将前面小于自己的元素都删除</span>        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxq<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以想象，加入数字的大小代表人的体重，体重大的会把前面体重不足的压扁，直到遇到更大的量级才停住。</p><p><img src="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/3-1749878196844-9.png" alt="img"></p><p>如果每个元素被加入时都这样操作，最终单调队列中的元素大小就会保持一个<strong>单调递减</strong>的顺序，因此我们的 <code>max</code> 方法就很好写了，只要把队头元素返回即可；<code>pop</code> 方法也是操作队头，如果队头元素是待删除元素 <code>n</code>，那么就删除它：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 为了节约篇幅，省略上文给出的代码部分...</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 队头的元素肯定是最大的</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> self<span class="token punctuation">.</span>maxq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>maxq<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pop</code> 方法之所以要判断 <code>n == maxq.getFirst()</code>，是因为我们想删除的队头元素 <code>n</code> 可能已经在 <code>push</code> 的过程中被「压扁」了，可能已经不存在了，这种情况就不用删除了：</p><p><img src="/2025/06/14/dan-diao-dui-lie-jie-gou-jie-jue-hua-dong-chuang-kou-wen-ti/2-1749878196844-11.png" alt="img"></p><p>至此，单调队列设计完毕，看下完整的解题代码：</p><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class MonotonicQueue:    def __init__(self):        self.maxq &#x3D; []        def push(self, n):        # 将小于 n 的元素全部删除        while self.maxq and self.maxq[-1] &lt; n:             self.maxq.pop()        # 然后将 n 加入尾部        self.maxq.append(n)        def max(self):        return self.maxq[0]        def pop(self, n):        if n &#x3D;&#x3D; self.maxq[0]:            self.maxq.pop(0)class Solution(object):    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        window &#x3D; MonotonicQueue()        res &#x3D; []                for i in range(len(nums)):            if i &lt; k - 1:                # 先填满窗口的前 k - 1                window.push(nums[i])            else:                 # 窗口向前滑动，加入新数字                window.push(nums[i])                # 记录当前窗口的最大值                res.append(window.max())                # 移出旧数字                window.pop(nums[i - k + 1])        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一点细节问题不要忽略，在实现 <code>MonotonicQueue</code> 时，我们使用了 Java 的 <code>LinkedList</code>，因为链表结构支持在头部和尾部快速增删元素；而在解法代码中的 <code>res</code> 则使用的 <code>ArrayList</code> 结构，因为后续会按照索引取元素，所以数组结构更合适。其他语言的实现也要注意这些细节。</p><p>关于单调队列 API 的时间复杂度，读者可能有疑惑：<code>push</code> 操作中含有 while 循环，最坏情况下的时间复杂度应该 O(N)<em>O</em>(<em>N</em>) 呀，再加上一层 for 循环，本算法的时间复杂度应该是 O(N2)<em>O</em>(<em>N</em>2) 才对吧？</p><p>这里就用到了 <a href="https://labuladong.online/algo/essential-technique/complexity-analysis/">算法时空复杂度分析指南</a> 中讲到的摊还分析：</p><p>单独看 <code>push</code> 操作，最坏时间复杂度确实是 O(N)<em>O</em>(<em>N</em>)，但是平均时间复杂度是 O(1)<em>O</em>(1)。我们一般用平均复杂度而不是最坏时间复杂度来衡量 API 接口，所以这个算法整体的时间复杂度是 O(N)<em>O</em>(<em>N</em>)，而不是 O(N2)<em>O</em>(<em>N</em>2)。</p><p>也可以这样从整体上分析：整个算法做的事情就是把 <code>nums</code> 中的每个元素加入和移出 <code>window</code> <strong>至多一次</strong>，不可能把同一个元素多次移入移出 <code>window</code>，所以整体的时间复杂度是 O(N)<em>O</em>(<em>N</em>)。</p><p>空间复杂度很容易分析，就是窗口的大小 O(k)<em>O</em>(<em>k</em>)。</p><h3 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="拓展延伸"></a><a href="https://labuladong.online/algo/data-structure/monotonic-queue/#%E6%8B%93%E5%B1%95%E5%BB%B6%E4%BC%B8">拓展延伸</a></h3><p>最后，我提出几个问题请大家思考：</p><p>1、本文给出的 <code>MonotonicQueue</code> 类只实现了 <code>max</code> 方法，你是否能够再额外添加一个 <code>min</code> 方法，在 O(1)<em>O</em>(1) 的时间返回队列中所有元素的最小值？</p><p>2、本文给出的 <code>MonotonicQueue</code> 类的 <code>pop</code> 方法还需要接收一个参数，这不那么优雅，而且有悖于标准队列的 API，请你修复这个缺陷。</p><p>3、请你实现 <code>MonotonicQueue</code> 类的 <code>size</code> 方法，返回单调队列中元素的个数（注意，由于每次 <code>push</code> 方法都可能从底层的 <code>q</code> 列表中删除元素，所以 <code>q</code> 中的元素个数并不是单调队列的元素个数）。</p><p>也就是说，你是否能够实现单调队列的通用实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 单调队列的通用实现，可以高效维护最大值和最小值</span><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token string">'Comparable'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 标准队列 API，从队头弹出元素，符合先进先出的顺序</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Comparable'</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 标准队列 API，返回队列中的元素个数</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 单调队列特有 API，O(1) 时间计算队列中元素的最大值</span>    <span class="token keyword">def</span> <span class="token function">max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Comparable'</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 单调队列特有 API，O(1) 时间计算队列中元素的最小值</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Comparable'</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我将在 <a href="https://labuladong.online/algo/problem-set/monotonic-queue/">单调队列通用实现及应用</a> 中给出单调队列的通用实现和经典习题。更多数据结构设计类题目参见 <a href="https://labuladong.online/algo/problem-set/ds-design/">数据结构设计经典习题</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】单调栈的几种变体及经典习题</title>
      <link href="/2025/06/14/lian-xi-dan-diao-zhan-de-ji-chong-bian-ti-ji-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-dan-diao-zhan-de-ji-chong-bian-ti-ji-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈模板的变体"><a href="#单调栈模板的变体" class="headerlink" title="单调栈模板的变体"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%98%E4%BD%93">单调栈模板的变体</a></h2><h3 id="下一个更大的元素"><a href="#下一个更大的元素" class="headerlink" title="下一个更大的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0">下一个更大的元素</a></h3><p>上篇文章 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈的实现</a> 带你使用单调栈解决了「下一个更大元素」的问题，比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们实现了这样一个函数解决这个问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更大元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 存放答案的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 因为是求 nums[i] 后面的元素，所以倒着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 后面较小的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的更大元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个更大或相等的元素"><a href="#下一个更大或相等的元素" class="headerlink" title="下一个更大或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">下一个更大或相等的元素</a></h3><p>本文给出这个问题的一些变体，比如说让你计算 <code>nums[i]</code> 的下一个大于等于 <code>nums[i]</code> 的元素怎么算？比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实很简单，把上面这段代码中 while 循环的 <code>&lt;=</code> 号改成 <code>&lt;</code> 号即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更大或相等的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把这里改成 &lt; 号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的大于等于 nums[i] 的元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个更小的元素"><a href="#下一个更小的元素" class="headerlink" title="下一个更小的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">下一个更小的元素</a></h3><p>再变一变，如果让你计算 <code>nums[i]</code> 的下一个小于 <code>nums[i]</code> 的元素，怎么算？比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也很简单，把之前实现的 <code>nextGreaterElement</code> 中 while 循环的 <code>&lt;=</code> 条件改成 <code>&gt;=</code> 条件即可得出下一个更小的元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更小的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLessElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 存放答案的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 倒着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 后面较大的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的更小元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个更小或相等的元素"><a href="#下一个更小或相等的元素" class="headerlink" title="下一个更小或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">下一个更小或相等的元素</a></h3><p>如果让你计算 <code>nums[i]</code> 的下一个小于或等于 <code>nums[i]</code> 的元素，怎么算？比如下面这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类似的，把 <code>nextLessElement</code> 函数的 while 循环中的 <code>&gt;=</code> 改成 <code>&gt;</code> 即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的下一个更小或相等的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLessOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 存放答案的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 倒着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 后面较大的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 身后的更小或相等元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上一个更大元素"><a href="#上一个更大元素" class="headerlink" title="上一个更大元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0">上一个更大元素</a></h3><p>之前的 4 个例子都是计算 <code>nums[i]</code> 的下一个更大&#x2F;更小元素，现在请你计算 <code>nums[i]</code> 的上一个更大元素，你会不会？比如这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意之前我们的 for 循环都是从数组的尾部开始往栈里添加元素，这样栈顶元素就是 <code>nums[i]</code> 之后的元素。所以只要我们从数组的头部开始往栈里添加元素，栈顶的元素就是 <code>nums[i]</code> 之前的元素，即可计算 <code>nums[i]</code> 的上一个更大元素。</p><p>代码实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更大元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 因为是求 nums[i] 前面的元素，所以正着往栈里放</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 删掉 nums[i] 前面较小的元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更大元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似之前的几种实现，基于这个函数还可以求出 <code>nums[i]</code> 的上一个更大或相等的元素、上一个更小的元素、上一个更小或相等的元素，只要改一改 while 循环的符号即可，下面一一列出具体实现。</p><h3 id="上一个更大或相等的元素"><a href="#上一个更大或相等的元素" class="headerlink" title="上一个更大或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">上一个更大或相等的元素</a></h3><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更大或相等元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevGreaterOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 注意不等号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更大或相等元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上一个更小的元素"><a href="#上一个更小的元素" class="headerlink" title="上一个更小的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">上一个更小的元素</a></h3><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更小的元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevLessElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把 nums[i] 之前的较大元素删除</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更小元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上一个更小或相等的元素"><a href="#上一个更小或相等的元素" class="headerlink" title="上一个更小或相等的元素"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%B0%8F%E6%88%96%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0">上一个更小或相等的元素</a></h3><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>返回：res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 计算 nums 中每个元素的上一个更小或相等元素</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">prevLessOrEqualElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> stk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 注意不等号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 现在栈顶就是 nums[i] 前面的更小或相等元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stk<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>至此，单调栈的几种标准模板就列举完了，他们之间有很多共性，理解性记忆就好，不用死记硬背。在实际算法题中不会直接考察你这些标准场景，但是稍加思考就可以抽象成这些标准场景</strong>。</p><p>下面带大家做几道习题练习一下单调栈模板的使用。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E4%B9%A0%E9%A2%98">习题</a></h2><h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_next-greater-node-in-linked-list">1019. 链表中的下一个更大节点</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1019. 链表中的下一个更大节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个长度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;的链表&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code></p><p style="line-height: 1.6; overflow-wrap: break-word;">对于列表中的每个节点，查找下一个<span>&nbsp;</span><strong style="font-weight: 600;">更大节点</strong><span>&nbsp;</span>的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值<span>&nbsp;</span><strong style="font-weight: 600;">严格大于</strong><span>&nbsp;</span>它的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer</code><span>&nbsp;</span>，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer[i]</code><span>&nbsp;</span>是第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>个节点(<span>&nbsp;</span><strong style="font-weight: 600;">从1开始</strong><span>&nbsp;</span>)的下一个更大的节点的值。如果第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>个节点没有下一个更大的节点，设置&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer[i] = 0</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/05/linkedlistnext1.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [2,1,5]<strong style="font-weight: 600;">输出：</strong>[5,5,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/08/05/linkedlistnext2.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [2,7,4,3,5]<strong style="font-weight: 600;">输出：</strong>[7,0,5,5,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>链表中节点数为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1019. 链表中的下一个更大节点</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这道题输入的是一条单链表，我们把它转化成数组，方便用索引访问即可直接套用 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈模板</a> 中的 <code>nextGreaterElement</code> 函数逻辑。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def nextLargerNodes(self, head: ListNode) -&gt; List[int]:        # 把单链表转化成数组，方便通过索引访问        nums &#x3D; []        p &#x3D; head        while p:            nums.append(p.val)            p &#x3D; p.next                # 存放答案的数组        res &#x3D; [0] * len(nums)        stk &#x3D; []                # 单调栈模板，求下一个更大元素，从后往前遍历        for i in range(len(nums) - 1, -1, -1):            while stk and stk[-1] &lt;&#x3D; nums[i]:                stk.pop()            # 本题要求没有下一个更大元素时返回 0            res[i] &#x3D; 0 if not stk else stk[-1]            stk.append(nums[i])                return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_next-greater-node-in-linked-list" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_next-greater-node-in-linked-list" src="https://labuladong.online/algo-visualize/leetcode/next-greater-node-in-linked-list/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1944-队列中可以看到的人数"><a href="#1944-队列中可以看到的人数" class="headerlink" title="1944. 队列中可以看到的人数"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_number-of-visible-people-in-a-queue">1944. 队列中可以看到的人数</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1944. 队列中可以看到的人数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/number-of-visible-people-in-a-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">有&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;个人排成一个队列，<strong style="font-weight: 600;">从左到右</strong>&nbsp;编号为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n - 1</code>&nbsp;。给你以一个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">heights</code>&nbsp;，每个整数<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">heights[i]</code>&nbsp;表示第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个人的高度。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一个人能<span>&nbsp;</span><strong style="font-weight: 600;">看到</strong><span>&nbsp;</span>他右边另一个人的条件是这两人之间的所有人都比他们两人<span>&nbsp;</span><strong style="font-weight: 600;">矮</strong>&nbsp;。更正式的，第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个人能看到第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;个人的条件是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt; j</code>&nbsp;且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回一个长度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code>&nbsp;的数组<em>&nbsp;</em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">answer[i]</code><em>&nbsp;</em>是第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个人在他右侧队列中能&nbsp;<strong style="font-weight: 600;">看到</strong>&nbsp;的&nbsp;<strong style="font-weight: 600;">人数</strong>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/05/29/queue-plane.jpg" style="max-width: 100%; width: 600px; height: 247px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>heights = [10,6,8,5,11,9]<b>输出：</b>[3,1,2,1,1,0]<strong style="font-weight: 600;">解释：</strong>第 0 个人能看到编号为 1 ，2 和 4 的人。第 1 个人能看到编号为 2 的人。第 2 个人能看到编号为 3 和 4 的人。第 3 个人能看到编号为 4 的人。第 4 个人能看到编号为 5 的人。第 5 个人谁也看不到因为他右边没人。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><b>输入：</b>heights = [5,1,2,3,10]<b>输出：</b>[4,1,1,1,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == heights.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">heights</code>&nbsp;中所有数<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1944. 队列中可以看到的人数</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这道题显然要用到 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈技巧</a>：靠左的高个子可以把靠右相邻的矮个子都「挤掉」，相当于计算下一个更大元素，即 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种模板实现</a> 中的 <code>nextGreaterElement</code> 函数。</p><p>只不过这道题不是问你下一个更大元素是多少，而是问你当前元素和下一个更大元素之间的元素个数，直接看解法代码吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canSeePersonsCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># int[] 记录 &#123;身高，小于等于该身高的人数&#125; 二元组</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 记录右侧比自己矮的人</span>            count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 单调栈模板，计算下一个更大或相等元素（身高）</span>            <span class="token keyword">while</span> stk <span class="token keyword">and</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 不仅可以看到比自己矮的人，如果后面存在更高的的人，也可以看到这个高人</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count <span class="token keyword">if</span> <span class="token keyword">not</span> stk <span class="token keyword">else</span> count <span class="token operator">+</span> <span class="token number">1</span>            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_number-of-visible-people-in-a-queue" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_number-of-visible-people-in-a-queue" src="https://labuladong.online/algo-visualize/leetcode/number-of-visible-people-in-a-queue/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="1475-商品折扣后的最终价格"><a href="#1475-商品折扣后的最终价格" class="headerlink" title="1475. 商品折扣后的最终价格"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_final-prices-with-a-special-discount-in-a-shop">1475. 商品折扣后的最终价格</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1475. 商品折扣后的最终价格</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices</code>&nbsp;，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices[i]</code>&nbsp;是商店里第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;件商品的价格。</p><p style="line-height: 1.6; overflow-wrap: break-word;">商店里正在进行促销活动，如果你要买第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;件商品，那么你可以得到与<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices[j]</code><span>&nbsp;</span>相等的折扣，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;是满足&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j &gt; i</code>&nbsp;且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">prices[j] &lt;= prices[i]</code>&nbsp;的&nbsp;<strong style="font-weight: 600;">最小下标</strong>&nbsp;，如果没有满足条件的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>&nbsp;，你将没有任何折扣。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回一个数组，数组中第&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;个元素是折扣后你购买商品<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code>&nbsp;最终需要支付的价格。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>prices = [8,4,6,2,3]<strong style="font-weight: 600;">输出：</strong>[4,2,4,2,3]<strong style="font-weight: 600;">解释：</strong>商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。商品 3 和 4 都没有折扣。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>prices = [1,2,3,4,5]<strong style="font-weight: 600;">输出：</strong>[1,2,3,4,5]<strong style="font-weight: 600;">解释：</strong>在这个例子中，所有商品都没有折扣。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>prices = [10,1,1,6]<strong style="font-weight: 600;">输出：</strong>[9,0,1,6]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= prices.length &lt;= 500</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= prices[i] &lt;= 10^3</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1475. 商品折扣后的最终价格</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这道题就用到了 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种模板实现</a> 中讲到的一个单调栈模板：计算下一个更小或相等的元素。我是为了运用模板，所以把解法分成了两个函数，效率可能会降低一些，你完全可以优化这个解法的形式，使之更高效。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def finalPrices(self, prices: List[int]) -&gt; List[int]:        n &#x3D; len(prices)        res &#x3D; [0] * n        # 下一个小于等于 price[i] 的价格就是优惠券折扣        next_element &#x3D; self.nextLessOrEqualElement(prices)        for i in range(len(prices)):            # 如果存在优惠券，则减少相应的价格            if next_element[i] !&#x3D; -1:                res[i] &#x3D; prices[i] - next_element[i]            else:                res[i] &#x3D; prices[i]        return res    # 单调栈模板：计算 nums 中每个元素的下一个更小或相等的元素    def nextLessOrEqualElement(self, nums: List[int]) -&gt; List[int]:        n &#x3D; len(nums)        # 存放答案的数组        res &#x3D; [-1] * n        s &#x3D; []        # 倒着往栈里放        for i in range(n - 1, -1, -1):            # 删掉 nums[i] 后面较大的元素            while s and s[-1] &gt; nums[i]:                s.pop()            # 现在栈顶就是 nums[i] 身后的更小或相等元素            res[i] &#x3D; s[-1] if s else -1            s.append(nums[i])        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_final-prices-with-a-special-discount-in-a-shop" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_final-prices-with-a-special-discount-in-a-shop" src="https://labuladong.online/algo-visualize/leetcode/final-prices-with-a-special-discount-in-a-shop/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_online-stock-span">901. 股票价格跨度</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">901. 股票价格跨度</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/online-stock-span/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/online-stock-span/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个算法收集某些股票的每日报价，并返回该股票当日价格的<span>&nbsp;</span><strong style="font-weight: 600;">跨度</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">当日股票价格的<span>&nbsp;</span><strong style="font-weight: 600;">跨度</strong><span>&nbsp;</span>被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;">例如，如果未来 7 天股票的价格是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[100,80,60,70,60,75,85]</code>，那么股票跨度将是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1,1,1,2,1,4,6]</code><span>&nbsp;</span>。</p></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">StockSpanner</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">StockSpanner()</code><span>&nbsp;</span>初始化类对象。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int next(int price)</code><span>&nbsp;</span>给出今天的股价<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">price</code><span>&nbsp;</span>，返回该股票当日价格的<span>&nbsp;</span><strong style="font-weight: 600;">跨度</strong><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>：["StockSpanner", "next", "next", "next", "next", "next", "next", "next"][[], [100], [80], [60], [70], [60], [75], [85]]<strong style="font-weight: 600;">输出</strong>：[null, 1, 1, 1, 2, 1, 4, 6]<p><strong style="font-weight: 600;">解释：</strong><br>StockSpanner stockSpanner &#x3D; new StockSpanner();<br>stockSpanner.next(100); &#x2F;&#x2F; 返回 1<br>stockSpanner.next(80);  &#x2F;&#x2F; 返回 1<br>stockSpanner.next(60);  &#x2F;&#x2F; 返回 1<br>stockSpanner.next(70);  &#x2F;&#x2F; 返回 2<br>stockSpanner.next(60);  &#x2F;&#x2F; 返回 1<br>stockSpanner.next(75);  &#x2F;&#x2F; 返回 4 ，因为截至今天的最后 4 个股价 (包括今天的股价 75) 都小于或等于今天的股价。<br>stockSpanner.next(85);  &#x2F;&#x2F; 返回 6<br></pre>&nbsp;<p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= price &lt;= 10<sup>5</sup></code></li><li>最多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">next</code><span>&nbsp;</span>方法<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code><span>&nbsp;</span>次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/online-stock-span/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 901. 股票价格跨度</a>。</strong></details></p><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这道题显然要用到 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈技巧</a>：当加入 <code>price</code> 时，把所有小于等于 <code>price</code> 的价格都「挤掉」，相当于计算前一个更大元素，即 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种模板实现</a> 中的 <code>prevGreaterElement</code> 函数。</p><p>比如已经入栈的价格序列是 <code>[40, 30, 20, 10]</code>，那么如果执行 <code>next(25)</code>，价格序列变成 <code>[40, 30, 25]</code>，20 和 10 都会被「挤掉」，算上 25 本身，函数返回 2 + 1 &#x3D; 3。</p><p><strong>但还有个问题，这个 3 应该作为「权重」和 25 一同存储在栈中</strong>。因为之后 25 还可能被挤掉，比如说执行 <code>next(26)</code>，价格序列就变成了 <code>[40, 30, 26]</code>，但这种情况下之前的 20 和 10 显然也应该被挤掉，函数应该返回 3 + 1 &#x3D; 4。具体解法看代码吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class StockSpanner:    # int[] 记录 &#123;价格，小于等于该价格的天数&#125; 二元组    def __init__(self):        self.stk &#x3D; []    def next(self, price: int) -&gt; int:        # 算上当天        count &#x3D; 1        # 单调栈模板        while self.stk and price &gt;&#x3D; self.stk[-1][0]:            # 挤掉价格低于 price 的记录            prev &#x3D; self.stk.pop()            # 计算小于等于 price 的天数            count +&#x3D; prev[1]        self.stk.append([price, count])        return count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_remove-k-digits">402. 移掉 K 位数字</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">402. 移掉 K 位数字</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/remove-k-digits/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/remove-k-digits/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个以字符串表示的非负整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">num</code><span>&nbsp;</span>和一个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>，移除这个数中的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><em><span>&nbsp;</span></em>位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>num = "1432219", k = 3<strong style="font-weight: 600;">输出：</strong>"1219"<strong style="font-weight: 600;">解释：</strong>移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>num = "10200", k = 1<strong style="font-weight: 600;">输出：</strong>"200"<strong style="font-weight: 600;">解释：</strong>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3 ：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>num = "10", k = 2<strong style="font-weight: 600;">输出：</strong>"0"<strong style="font-weight: 600;">解释：</strong>从原数字移除所有的数字，剩余为空就是 0 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= num.length &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">num</code><span>&nbsp;</span>仅由若干位数字（0 - 9）组成</li><li>除了<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>本身之外，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">num</code><span>&nbsp;</span>不含任何前导零</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/remove-k-digits/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 402. 移掉 K 位数字</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>如果想让结果尽可能小，那么清除数字分两步：</p><p>1、先删除 <code>num</code> 中的若干数字，使得 <code>num</code> 从左到右每一位都单调递增。比如 <code>14329</code> 转化成 <code>129</code>，这需要使用到 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈技巧</a>。</p><p>2、<code>num</code> 中的每一位变成单调递增的之后，如果 <code>k</code> 还大于 0（还可以继续删除）的话，则删除尾部的数字，比如 <code>129</code> 删除成 <code>12</code>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def removeKdigits(self, num: str, k: int) -&gt; str:        stk &#x3D; []        for c in num:            # 单调栈代码模板            while stk and k &gt; 0 and c &lt; stk[-1]:                stk.pop()                k -&#x3D; 1            # 防止 0 作为数字的开头            if not stk and c &#x3D;&#x3D; &#39;0&#39;:                continue            stk.append(c)        # 此时栈中元素单调递增，若 k 还没用完的话删掉栈顶元素        final_stack &#x3D; stk[:-k] if k else stk        # 将栈中字符转化成字符串        # 出栈顺序和字符串顺序是反的        result &#x3D; &#39;&#39;.join(final_stack).lstrip(&#39;0&#39;)        # 若最后没剩下数字，就是 0        return result if result else &#39;0&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_remove-k-digits" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_remove-k-digits" src="https://labuladong.online/algo-visualize/leetcode/remove-k-digits/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="853-车队"><a href="#853-车队" class="headerlink" title="853. 车队"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_car-fleet">853. 车队</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">853. 车队</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/car-fleet/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/car-fleet/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在一条单行道上，有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>辆车开往同一目的地。目的地是几英里以外的&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给定两个整数数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">position</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">speed</code>&nbsp;，长度都是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">position[i]</code>&nbsp;是第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>辆车的位置，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">speed[i]</code>&nbsp;是第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>辆车的速度(单位是英里/小时)。</p><p style="line-height: 1.6; overflow-wrap: break-word;">一辆车永远不会超过前面的另一辆车，但它可以追上去，并以较慢车的速度在另一辆车旁边行驶。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">车队<span>&nbsp;</span></strong>是指并排行驶的一辆或几辆汽车。车队的速度是车队中<span>&nbsp;</span><strong style="font-weight: 600;">最慢</strong><span>&nbsp;</span>的车的速度。</p><p style="line-height: 1.6; overflow-wrap: break-word;">即便一辆车在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code><span>&nbsp;</span>才赶上了一个车队，它们仍然会被视作是同一个车队。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回到达目的地的车队数量 。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><div class="example-block"><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输入：</b>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输出：</b>3</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">解释：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>从 10（速度为 2）和 8（速度为 4）开始的车会组成一个车队，它们在 12 相遇。车队在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>&nbsp;形成。</li><li>从 0（速度为 1）开始的车不会追上其它任何车，所以它自己是一个车队。</li><li>从 5（速度为 1） 和 3（速度为 3）开始的车组成一个车队，在 6 相遇。车队以速度 1 移动直到它到达&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>。</li></ul></div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><div class="example-block"><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输入：</b></span><span class="example-io">target = 10, position = [3], speed = [3]</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输出：</b></span><span class="example-io">1</span></p><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">解释：</strong></p>只有一辆车，因此只有一个车队。</div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><div class="example-block"><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输入：</b></span><span class="example-io">target = 100, position = [0,2,4], speed = [4,2,1]</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><span class="example-io"><b>输出：</b></span><span class="example-io">1</span></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">解释：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>从 0（速度为 4） 和 2（速度为 2）开始的车组成一个车队，在 4&nbsp;相遇。从 4 开始的车（速度为 1）移动到了 5。</li><li>然后，在 4（速度为 2）的车队和在 5（速度为 1）的车成为一个车队，在 6 相遇。车队以速度 1 移动直到它到达&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">target</code>。</li></ul></div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == position.length == speed.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt; target &lt;= 10<sup>6</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= position[i] &lt; target</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">position</code>&nbsp;中每个值都<span>&nbsp;</span><strong style="font-weight: 600;">不同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/car-fleet/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 853. 车队</a>。</strong></details><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>这题考察「单调栈」结构的使用。是否能够形成车队，取决于下述规律：</p><p><strong>如果车 <code>x</code> 排在 车 <code>y</code> 后面，且 <code>x</code> 到达终点所需时间比 <code>y</code> 少，则 <code>x</code> 必然会被 <code>y</code> 卡住，形成车队</strong>。</p><p>所以本题的思路是先根据每辆车的起始位置 <code>position</code> 排序，然后计算出时间数组 <code>time</code>。</p><p>假设计算出的 <code>time</code> 数组为 <code>[12, 3, 7, 1, 2]</code>，那么观察数组的单调性变化，最后肯定会形成三个车队，他们到达终点的时间分别是 12, 7, 2。</p><p>可以利用单调栈结构模拟得出结果，不过效率稍微低一些。也可以倒序遍历数组得出递增子序列，子序列的长度即答案。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON">class Solution:    def carFleet(self, target: int, position: List[int], speed: List[int]) -&gt; int:        n &#x3D; len(position)        cars &#x3D; []        for i in range(n):            cars.append([position[i], speed[i]])        # 按照初始位置，从小到大排序        cars.sort(key&#x3D;lambda x: x[0])        # 计算每辆车到达终点的时间        time &#x3D; []        for i in range(n):            car &#x3D; cars[i]            time.append((target - car[0]) &#x2F; car[1])                # 使用单调栈计算车队的数量        # (This part is commented out in the original Java code, so it&#39;s also commented out here)        # stk &#x3D; []        # for t in time:        #     while stk and t &gt;&#x3D; stk[-1]:        #         stk.pop()        #     stk.append(t)        # return len(stk)        # 避免使用栈模拟，倒序遍历取递增序列就是答案        res &#x3D; 0        max_time &#x3D; 0        for i in range(n - 1, -1, -1):            if time[i] &gt; max_time:                max_time &#x3D; time[i]                res +&#x3D; 1        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-4"><a href="#可视化-4" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-4">可视化</a></h3><details data-v-ee1a9bd0="" id="div_car-fleet" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_car-fleet" src="https://labuladong.online/algo-visualize/leetcode/car-fleet/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#slug_shortest-unsorted-continuous-subarray">581. 最短无序连续子数组</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">581. 最短无序连续子数组</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>，你需要找出一个<span>&nbsp;</span><strong style="font-weight: 600;">连续子数组</strong><span>&nbsp;</span>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你找出符合题意的<span>&nbsp;</span><strong style="font-weight: 600;">最短</strong><span>&nbsp;</span>子数组，并输出它的长度。</p><div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [2,6,4,8,10,9,15]<strong style="font-weight: 600;">输出：</strong>5<strong style="font-weight: 600;">解释：</strong>你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1,2,3,4]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [1]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你可以设计一个时间复杂度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(n)</code><span>&nbsp;</span>的解决方案吗？</p></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 581. 最短无序连续子数组</a>。</strong></details><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p>最简单的解法是排序，排序之后很容易看出来哪一部分子数组乱序了。这里主要介绍一下单调栈的解法。</p><p>单调递增栈会筛选出递增的元素序列，换句话说，每加入一个新元素 <code>x</code>，就会弹出栈顶大于 <code>x</code> 的其他元素，直到栈顶元素小于 <code>x</code> 为止。</p><p>反过来，单调递减栈会筛选出递减的元素序列，换句话说，每加入一个新元素 <code>x</code>，就会弹出栈顶小于 <code>x</code> 的其他元素，直到栈顶元素大于 <code>x</code> 为止。</p><p>综上，如果正序遍历 <code>nums</code>，维护一个递增栈，那么弹出的元素就是乱序的元素；如果反向遍历 <code>nums</code>，维护一个递减栈，那么弹出的元素就是乱序的元素。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/monotonic-stack/">【练习】单调栈的几种变体及经典习题</a></li></ul><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/monotonic-stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-PYTHON" data-language="PYTHON"><code class="language-PYTHON"># 排序解法class Solution:    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:        temp &#x3D; sorted(nums)        left &#x3D; float(&#39;inf&#39;)        right &#x3D; float(&#39;-inf&#39;)        for i in range(len(nums)):            if temp[i] !&#x3D; nums[i]:                left &#x3D; i                break        for i in range(len(nums) - 1, -1, -1):            if temp[i] !&#x3D; nums[i]:                right &#x3D; i                break        if left &#x3D;&#x3D; float(&#39;inf&#39;) and right &#x3D;&#x3D; float(&#39;-inf&#39;):            # nums 本来就是有序的            return 0        return right - left + 1# 单调栈解法class Solution2:    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:        n &#x3D; len(nums)        left &#x3D; float(&#39;inf&#39;)        right &#x3D; float(&#39;-inf&#39;)        # 递增栈，存储元素索引        incr_stk &#x3D; []        for i in range(n):            while incr_stk and nums[incr_stk[-1]] &gt; nums[i]:                # 弹出的元素都是乱序元素，其中最小的索引就是乱序子数组的左边界                left &#x3D; min(left, incr_stk.pop())            incr_stk.append(i)        # 递减栈，存储元素索引        decr_stk &#x3D; []        for i in range(n - 1, -1, -1):            while decr_stk and nums[decr_stk[-1]] &lt; nums[i]:                # 弹出的元素都是乱序元素，其中最大的索引就是乱序子数组的右边界                right &#x3D; max(right, decr_stk.pop())            decr_stk.append(i)        if left &#x3D;&#x3D; float(&#39;inf&#39;) and right &#x3D;&#x3D; float(&#39;-inf&#39;):            # 说明单调栈没有弹出任何元素，即 nums 本来就是有序的            return 0        return right - left + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈算法模板解决三道例题</title>
      <link href="/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/"/>
      <url>/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="单调栈算法模板解决三道例题"><a href="#单调栈算法模板解决三道例题" class="headerlink" title="单调栈算法模板解决三道例题"></a>单调栈算法模板解决三道例题</h1><blockquote><p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」等。本文讲解单调栈的算法模版解决「下一个更大元素」相关问题，并且探讨处理「循环数组」的策略。</p></blockquote><h2 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF">单调栈模板</a></h2><p>现在给你出这么一道题：输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calculateGreaterElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如说，输入一个数组 <code>nums = [2,1,2,4,3]</code>，你返回数组 <code>[4,2,4,-1,-1]</code>。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p><p>这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 O(n2)<em>O</em>(<em>n</em>2)。</p><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的下一个更大元素呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><p><img src="/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/1.jpeg" alt="img"></p><p>这个情景很好理解吧？带着这个抽象的情景，先来看下代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calculateGreaterElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># 存放答案的数组</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n    s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 倒着往栈里放</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 判定个子高矮</span>        <span class="token keyword">while</span> s <span class="token keyword">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 矮个起开，反正也被挡着了。。。</span>            s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># nums[i] 身后的更大元素</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s <span class="token keyword">else</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是单调栈解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。</p><p>这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n2)<em>O</em>(<em>n</em>2)，但是实际上这个算法的复杂度只有 O(n)<em>O</em>(<em>n</em>)。</p><p>分析它的时间复杂度，要从整体来看：总共有 <code>n</code> 个元素，每个元素都被 <code>push</code> 入栈了一次，而最多会被 <code>pop</code> 一次，没有任何冗余操作。所以总的计算规模是和元素规模 <code>n</code> 成正比的，也就是 O(n)<em>O</em>(<em>n</em>) 的复杂度。</p><h2 id="问题变形"><a href="#问题变形" class="headerlink" title="问题变形"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#%E9%97%AE%E9%A2%98%E5%8F%98%E5%BD%A2">问题变形</a></h2><p>单调栈的代码实现比较简单，下面来看一些具体题目。</p><h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#_496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i">496. 下一个更大元素 I</a></h3><p>首先来一个简单的变形，力扣第 496 题「<a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">496. 下一个更大元素 I</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/next-greater-element-i/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/next-greater-element-i/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;"><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code>&nbsp;中数字&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code>&nbsp;的<span>&nbsp;</span><strong style="font-weight: 600;">下一个更大元素</strong><span>&nbsp;</span>是指&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code>&nbsp;在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>中对应位置<span>&nbsp;</span><strong style="font-weight: 600;">右侧</strong><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">第一个</strong><span>&nbsp;</span>比&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><strong style="font-weight: 600;">&nbsp;</strong>大的元素。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你两个<strong style="font-weight: 600;"><span>&nbsp;</span>没有重复元素</strong><span>&nbsp;</span>的数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>，下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始计数，其中<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code>&nbsp;是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code>&nbsp;的子集。</p><p style="line-height: 1.6; overflow-wrap: break-word;">对于每个<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= i &lt; nums1.length</code><span>&nbsp;</span>，找出满足<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1[i] == nums2[j]</code><span>&nbsp;</span>的下标<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code><span>&nbsp;</span>，并且在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>确定<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2[j]</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">下一个更大元素</strong><span>&nbsp;</span>。如果不存在下一个更大元素，那么本次查询的答案是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回一个长度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1.length</code><span>&nbsp;</span>的数组<em><span>&nbsp;</span></em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ans</code><em><span>&nbsp;</span></em>作为答案，满足<em><span>&nbsp;</span></em><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ans[i]</code><em><span>&nbsp;</span></em>是如上所述的<span>&nbsp;</span><strong style="font-weight: 600;">下一个更大元素</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums1 = [4,1,2], nums2 = [1,3,4,2].<strong style="font-weight: 600;">输出：</strong>[-1,3,-1]<strong style="font-weight: 600;">解释：</strong>nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 = [1,3,<strong style="font-weight: 600;">4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 = [<em><strong style="font-weight: 600;">1</strong></em>,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 = [1,3,4,<em><strong style="font-weight: 600;">2</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums1 = [2,4], nums2 = [1,2,3,4].<strong style="font-weight: 600;">输出：</strong>[3,-1]<strong style="font-weight: 600;">解释：</strong>nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 = [1,<em><strong style="font-weight: 600;">2</strong></em>,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 = [1,2,3,<em><strong style="font-weight: 600;">4</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code>和<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code>中所有整数<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums1</code><span>&nbsp;</span>中的所有整数同样出现在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums2</code><span>&nbsp;</span>中</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你可以设计一个时间复杂度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">O(nums1.length + nums2.length)</code><span>&nbsp;</span>的解决方案吗？</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 496. 下一个更大元素 I</a>。</strong></details><p>这道题给你输入两个数组 <code>nums1</code> 和 <code>nums2</code>，让你求 <code>nums1</code> 中的元素在 <code>nums2</code> 中的下一个更大元素，函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其实和把我们刚才的代码改一改就可以解决这道题了，因为题目说 <code>nums1</code> 是 <code>nums2</code> 的子集，那么我们先把 <code>nums2</code> 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 <code>nums1</code> 中的元素去查表即可：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 nums2 中每个元素的下一个更大元素</span>        greater <span class="token operator">=</span> self<span class="token punctuation">.</span>calculateGreaterElement<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        <span class="token comment"># 转化成映射：元素 x -> x 的下一个最大元素</span>        greaterMap <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            greaterMap<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> greater<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> greaterMap<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">calculateGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 见上文</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_next-greater-element-i" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_next-greater-element-i" src="https://labuladong.online/algo-visualize/leetcode/next-greater-element-i/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#_739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6">739. 每日温度</a></h3><p>再看看力扣第 739 题「<a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a>」：</p><p>给你一个数组 <code>temperatures</code>，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0。函数签名如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>temperatures<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如说给你输入 <code>temperatures = [73,74,75,71,69,76]</code>，你返回 <code>[1,1,3,2,1,0]</code>。因为第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温，后面的同理。</p><p>这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。</p><p>相同的思路，直接调用单调栈的算法模板，稍作改动就可以，直接上代码吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> temperatures<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temperatures<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n        <span class="token comment"># 这里放元素索引，而不是元素</span>        s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 单调栈模板</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s <span class="token keyword">and</span> temperatures<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 得到索引间距</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s <span class="token keyword">else</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> i            <span class="token comment"># 将索引入栈，而不是元素</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单调栈讲解完毕，下面开始另一个重点：如何处理「循环数组」。</p><h2 id="如何处理环形数组"><a href="#如何处理环形数组" class="headerlink" title="如何处理环形数组"></a><a href="https://labuladong.online/algo/data-structure/monotonic-stack/#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84">如何处理环形数组</a></h2><p>同样是求下一个更大元素，现在假设给你的数组是个环形的，如何处理？力扣第 503 题「<a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a>」就是这个问题：输入一个「环形数组」，请你计算其中每个元素的下一个更大元素。</p><p>比如输入 <code>[2,1,2,4,3]</code>，你应该返回 <code>[4,2,4,-1,4]</code>，因为拥有了环形属性，<strong>最后一个元素 3 绕了一圈后找到了比自己大的元素 4</strong>。</p><p>如果你看过基础知识章节的 <a href="https://labuladong.online/algo/data-structure-basic/cycle-array/">环形数组技巧</a> 应该比较熟悉，我们一般是通过 % 运算符求模（余数），来模拟环形特效：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># 在环形数组中转圈</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span>    index <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 <code>[2,1,2,4,3]</code>，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。</p><p><strong>对于这种需求，常用套路就是将数组长度翻倍</strong>：</p><p><img src="/2025/06/14/dan-diao-zhan-suan-fa-mo-ban-jie-jue-san-dao-li-ti/2.jpeg" alt="img"></p><p>这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。</p><p>有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，<strong>我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果</strong>。直接看代码吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token comment"># 用数组模拟栈</span>        s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 数组长度加倍模拟环形数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 索引 i 要求模，其他的和模板一样</span>            <span class="token keyword">while</span> s <span class="token keyword">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s <span class="token keyword">else</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_next-greater-element-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_next-greater-element-ii" src="https://labuladong.online/algo-visualize/leetcode/next-greater-element-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，就可以巧妙解决环形数组的问题，时间复杂度 O(N)<em>O</em>(<em>N</em>)。</p><p>最后提出一些问题吧，本文提供的单调栈模板是 <code>nextGreaterElement</code> 函数，可以计算每个元素的下一个更大元素，但如果题目让你计算上一个更大元素，或者计算上一个更大或相等的元素，应该如何修改对应的模板呢？而且在实际应用中，题目不会直接让你计算下一个（上一个）更大（小）的元素，你如何把问题转化成单调栈相关的问题呢？</p><p>我会在 <a href="https://labuladong.online/algo/problem-set/monotonic-stack/">单调栈的几种变体及习题</a> 对比单调栈的几种其他形式，并在 给出单调栈的经典例题。更多数据结构设计类题目参见 <a href="https://labuladong.online/algo/problem-set/ds-design/">数据结构设计经典习题</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】队列的经典习题</title>
      <link href="/2025/06/14/lian-xi-dui-lie-de-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-dui-lie-de-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】队列的经典习题"><a href="#【练习】队列的经典习题" class="headerlink" title="【练习】队列的经典习题"></a>【练习】队列的经典习题</h1><h2 id="考察先进先出性质"><a href="#考察先进先出性质" class="headerlink" title="考察先进先出性质"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%80%83%E5%AF%9F%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E6%80%A7%E8%B4%A8">考察先进先出性质</a></h2><p>队列常见考点主要是元素「先进先出」的顺序特性，比如维护队列内的元素在「时序上」的某些性质，下面是几道例题，队列充当「滑动窗口」的作用。</p><h2 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_number-of-recent-calls">933. 最近的请求次数</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">933. 最近的请求次数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/number-of-recent-calls/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/number-of-recent-calls/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">写一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">RecentCounter</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">RecentCounter()</code><span>&nbsp;</span>初始化计数器，请求数为 0 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int ping(int t)</code><span>&nbsp;</span>在时间<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>添加一个新请求，其中<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>表示以毫秒为单位的某个时间，并返回过去<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">3000</code><span>&nbsp;</span>毫秒内发生的所有请求数（包括新请求）。确切地说，返回在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[t-3000, t]</code><span>&nbsp;</span>内发生的请求数。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">保证</strong><span>&nbsp;</span>每次对<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ping</code><span>&nbsp;</span>的调用都使用比之前更大的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["RecentCounter", "ping", "ping", "ping", "ping"][[], [1], [100], [3001], [3002]]<strong style="font-weight: 600;">输出：</strong>[null, 1, 2, 3, 3]<p><strong style="font-weight: 600;">解释：</strong><br>RecentCounter recentCounter &#x3D; new RecentCounter();<br>recentCounter.ping(1);     &#x2F;&#x2F; requests &#x3D; [<strong style="font-weight: 600;">1</strong>]，范围是 [-2999,1]，返回 1<br>recentCounter.ping(100);   &#x2F;&#x2F; requests &#x3D; [<strong style="font-weight: 600;">1</strong>, <strong style="font-weight: 600;">100</strong>]，范围是 [-2900,100]，返回 2<br>recentCounter.ping(3001);  &#x2F;&#x2F; requests &#x3D; [<strong style="font-weight: 600;">1</strong>, <strong style="font-weight: 600;">100</strong>, <strong style="font-weight: 600;">3001</strong>]，范围是 [1,3001]，返回 3<br>recentCounter.ping(3002);  &#x2F;&#x2F; requests &#x3D; [1, <strong style="font-weight: 600;">100</strong>, <strong style="font-weight: 600;">3001</strong>, <strong style="font-weight: 600;">3002</strong>]，范围是 [2,3002]，返回 3<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= t &lt;= 10<sup>9</sup></code></li><li>保证每次对<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ping</code><span>&nbsp;</span>调用所使用的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">t</code><span>&nbsp;</span>值都<span>&nbsp;</span><strong style="font-weight: 600;">严格递增</strong></li><li>至多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">ping</code><span>&nbsp;</span>方法<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10<sup>4</sup></code><span>&nbsp;</span>次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/number-of-recent-calls/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 933. 最近的请求次数</a>。</strong></details></p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这题很简单，和 <a href="https://leetcode.cn/problems/moving-average-from-data-stream">346. 数据流中的移动平均值</a> 有点类似，要求动态维护队列中的元素。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">class</span> <span class="token class-name">RecentCounter</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> t <span class="token operator">-</span> <span class="token number">3000</span><span class="token punctuation">:</span>            <span class="token comment"># t 是递增的，所以可以从队头删除 3000 毫秒之前的请求</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/design-hit-counter">362. 敲击计数器 🟠</a></li><li><a href="https://leetcode.cn/problems/H8086Q">剑指 Offer II 042. 最近请求次数 🟢</a></li></ul><h2 id="队列相关的设计题"><a href="#队列相关的设计题" class="headerlink" title="队列相关的设计题"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98">队列相关的设计题</a></h2><p>队列相关的设计题也是一大重点，但不算很难，下面是几道例题。</p><h2 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_design-circular-queue">622. 设计循环队列</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">622. 设计循环队列</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/design-circular-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/design-circular-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p style="line-height: 1.6; overflow-wrap: break-word;">循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你的实现应该支持如下操作：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isEmpty()</code>: 检查循环队列是否为空。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isFull()</code>: 检查循环队列是否已满。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); &nbsp;// 返回 truecircularQueue.enQueue(2); &nbsp;// 返回 truecircularQueue.enQueue(3); &nbsp;// 返回 truecircularQueue.enQueue(4); &nbsp;// 返回 false，队列已满circularQueue.Rear(); &nbsp;// 返回 3circularQueue.isFull(); &nbsp;// 返回 truecircularQueue.deQueue(); &nbsp;// 返回 truecircularQueue.enQueue(4); &nbsp;// 返回 truecircularQueue.Rear(); &nbsp;// 返回 4</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>所有的值都在 0&nbsp;至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/design-circular-queue/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 622. 设计循环队列</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这道题考察的是普通队列的实现，底层可以用链表或数组实现，用链表实现比较简单，用数组的话要用到环形数组的技巧。具体可以参见 <a href="https://labuladong.online/algo/data-structure-basic/linked-queue-stack/">用链表实现队列&#x2F;栈</a> 和 <a href="https://labuladong.online/algo/data-structure-basic/array-queue-stack/">用数组实现环形队列</a> 两篇文章。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token comment"># 底层用数组实现队列</span><span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">:</span>    INIT_CAP <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_cap<span class="token operator">=</span>INIT_CAP<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> init_cap        self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 不传参数，默认大小为 INIT_CAP</span>    <span class="token comment"># Initializer with default capacity</span>    <span class="token comment"># 增</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> e        self<span class="token punctuation">.</span>last <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 删</span>    <span class="token keyword">def</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Queue underflow'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>        old_val <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>first <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> old_val    <span class="token keyword">def</span> <span class="token function">resize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_cap<span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> new_cap        <span class="token comment"># first ----- last</span>        <span class="token comment"># --- last    first ---</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>first <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>last <span class="token operator">=</span> self<span class="token punctuation">.</span>size        self<span class="token punctuation">.</span>data <span class="token operator">=</span> temp    <span class="token comment"># 查</span>    <span class="token keyword">def</span> <span class="token function">peek_first</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Queue underflow'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">peek_last</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Queue underflow'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token keyword">class</span> <span class="token class-name">MyCircularQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> ArrayQueue<span class="token punctuation">(</span>k<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>max_cap <span class="token operator">=</span> k    <span class="token keyword">def</span> <span class="token function">enQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>max_cap<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>enqueue<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">deQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>dequeue<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">Front</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>peek_first<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">Rear</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>peek_last<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">isFull</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>size <span class="token operator">==</span> self<span class="token punctuation">.</span>max_cap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_design-circular-deque">641. 设计循环双端队列</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">641. 设计循环双端队列</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/design-circular-deque/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/design-circular-deque/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计实现双端队列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyCircularDeque</code><span>&nbsp;</span>类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyCircularDeque(int k)</code>&nbsp;：构造函数,双端队列最大为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean insertLast()</code>&nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean deleteFront()</code>&nbsp;：从双端队列头部删除一个元素。 如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean deleteLast()</code>&nbsp;：从双端队列尾部删除一个元素。如果操作成功返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int getFront()</code>&nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code>&nbsp;。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int getRear()</code>&nbsp;：获得双端队列的最后一个元素。&nbsp;如果双端队列为空，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean isEmpty()</code>&nbsp;：若双端队列为空，则返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>&nbsp;。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean isFull()</code>&nbsp;：若双端队列满了，则返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code>&nbsp;，否则返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"][[3], [1], [2], [3], [4], [], [], [], [4], []]<strong style="font-weight: 600;">输出</strong>[null, true, true, true, false, 2, true, true, true, 4]<p><strong style="font-weight: 600;">解释</strong><br>MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3<br>circularDeque.insertLast(1);        &#x2F;&#x2F; 返回 true<br>circularDeque.insertLast(2);        &#x2F;&#x2F; 返回 true<br>circularDeque.insertFront(3);        &#x2F;&#x2F; 返回 true<br>circularDeque.insertFront(4);        &#x2F;&#x2F; 已经满了，返回 false<br>circularDeque.getRear();  &#x2F;&#x2F; 返回 2<br>circularDeque.isFull();        &#x2F;&#x2F; 返回 true<br>circularDeque.deleteLast();        &#x2F;&#x2F; 返回 true<br>circularDeque.insertFront(4);        &#x2F;&#x2F; 返回 true<br>circularDeque.getFront();&#x2F;&#x2F; 返回 4<br>&nbsp;</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= k &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= value &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">insertFront</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">insertLast</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">deleteFront</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">deleteLast</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getFront</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getRear</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isEmpty</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">isFull</code>&nbsp; 调用次数不大于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2000</code>&nbsp;次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/design-circular-deque/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 641. 设计循环双端队列</a>。</strong></details></p><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>这道题考察的是双端队列的实现，底层可以用链表或数组实现，用链表实现比较简单，用数组的话要用到 <a href="https://labuladong.online/algo/data-structure-basic/cycle-array/">环形数组</a> 的技巧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyArrayDeque</span><span class="token punctuation">:</span>    INIT_CAP <span class="token operator">=</span> <span class="token number">2</span>    <span class="token comment"># 不传参数，默认大小为 INIT_CAP</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> init_cap<span class="token operator">=</span>INIT_CAP<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> init_cap        <span class="token comment"># last 是下一次应该添加元素的索引</span>        <span class="token comment"># first----last, [first, last)</span>        <span class="token comment"># 比如 first = 1，last = 3，size = 2</span>        self<span class="token punctuation">.</span>first <span class="token operator">=</span> self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 从头部获取元素</span>    <span class="token keyword">def</span> <span class="token function">getFirst</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"getFirst from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>    <span class="token comment"># 从尾部获取元素</span>    <span class="token keyword">def</span> <span class="token function">getLast</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"getLast from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># 从头部插入元素</span>    <span class="token keyword">def</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 情况一：first----last</span>        <span class="token comment"># 情况二：---last  first---</span>        <span class="token comment"># 左移 first，所以 first == 0 是一种特殊情况</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 插入元素</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> e        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 从尾部插入元素</span>    <span class="token keyword">def</span> <span class="token function">addLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 插入元素</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> e        self<span class="token punctuation">.</span>last <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 从头部删除元素</span>    <span class="token keyword">def</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"removeFirst from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>        old_val <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>first <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> old_val    <span class="token comment"># 从尾部删除元素</span>    <span class="token keyword">def</span> <span class="token function">removeLast</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> IndexError<span class="token punctuation">(</span><span class="token string">"removeLast from empty deque"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 情况一：first----last</span>        <span class="token comment"># 情况二：---last  first---</span>        <span class="token comment"># 左移 last，当 last == 0 的时候是特殊情况</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>last <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>last <span class="token operator">-=</span> <span class="token number">1</span>        old_val <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span>        <span class="token comment"># 删除元素</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> old_val    <span class="token keyword">def</span> <span class="token function">getSize</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">resize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_cap<span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> new_cap        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>first <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>last <span class="token operator">=</span> self<span class="token punctuation">.</span>size        self<span class="token punctuation">.</span>data <span class="token operator">=</span> temp<span class="token keyword">class</span> <span class="token class-name">MyCircularDeque</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cap <span class="token operator">=</span> k        self<span class="token punctuation">.</span><span class="token builtin">list</span> <span class="token operator">=</span> MyArrayDeque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Adds an item at the front of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">insertFront</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getSize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>addFirst<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Adds an item at the rear of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">insertLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getSize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>addLast<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Deletes an item from the front of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">deleteFront</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>removeFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Deletes an item from the rear of Deque. Return true if the operation is successful.</span>    <span class="token keyword">def</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>removeLast<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># Get the front item from the deque.</span>    <span class="token keyword">def</span> <span class="token function">getFront</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Get the last item from the deque.</span>    <span class="token keyword">def</span> <span class="token function">getRear</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getLast<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Checks whether the circular deque is empty or not.</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Checks whether the circular deque is full or not.</span>    <span class="token keyword">def</span> <span class="token function">isFull</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>getSize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>cap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1670-设计前中后队列"><a href="#1670-设计前中后队列" class="headerlink" title="1670. 设计前中后队列"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_design-front-middle-back-queue">1670. 设计前中后队列</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1670. 设计前中后队列</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/design-front-middle-back-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/design-front-middle-back-queue/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">请你设计一个队列，支持在前，中，后三个位置的<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>操作。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你完成<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FrontMiddleBack</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FrontMiddleBack()</code><span>&nbsp;</span>初始化队列。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pushFront(int val)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>添加到队列的<span>&nbsp;</span><strong style="font-weight: 600;">最前面</strong><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pushMiddle(int val)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>添加到队列的<span>&nbsp;</span><strong style="font-weight: 600;">正中间</strong><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pushBack(int val)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>添加到队里的<span>&nbsp;</span><strong style="font-weight: 600;">最后面</strong><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int popFront()</code><span>&nbsp;</span>将<span>&nbsp;</span><strong style="font-weight: 600;">最前面</strong><span>&nbsp;</span>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int popMiddle()</code><span>&nbsp;</span>将<span>&nbsp;</span><b>正中间</b><span>&nbsp;</span>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int popBack()</code><span>&nbsp;</span>将<span>&nbsp;</span><strong style="font-weight: 600;">最后面</strong><span>&nbsp;</span>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">请注意当有<span>&nbsp;</span><strong style="font-weight: 600;">两个</strong><span>&nbsp;</span>中间位置的时候，选择靠前面的位置进行操作。比方说：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">6</code><span>&nbsp;</span>添加到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2, 3, 4, 5]</code><span>&nbsp;</span>的中间位置，结果数组为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2,<span>&nbsp;</span><strong style="font-weight: 600;">6</strong>, 3, 4, 5]</code><span>&nbsp;</span>。</li><li>从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2,<span>&nbsp;</span><strong style="font-weight: 600;">3</strong>, 4, 5, 6]</code><span>&nbsp;</span>的中间位置弹出元素，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">3</code><span>&nbsp;</span>，数组变为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 2, 4, 5, 6]</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"][[], [1], [2], [3], [4], [], [], [], [], []]<strong style="font-weight: 600;">输出：</strong>[null, null, null, null, null, 1, 3, 4, 2, -1]<p><strong style="font-weight: 600;">解释：</strong><br>FrontMiddleBackQueue q &#x3D; new FrontMiddleBackQueue();<br>q.pushFront(1);   &#x2F;&#x2F; [<strong style="font-weight: 600;">1</strong>]<br>q.pushBack(2);    &#x2F;&#x2F; [1, <strong style="font-weight: 600;">2</strong>]<br>q.pushMiddle(3);  &#x2F;&#x2F; [1, <strong style="font-weight: 600;">3</strong>, 2]<br>q.pushMiddle(4);  &#x2F;&#x2F; [1, <strong style="font-weight: 600;">4</strong>, 3, 2]<br>q.popFront();     &#x2F;&#x2F; 返回 1 -&gt; [4, 3, 2]<br>q.popMiddle();    &#x2F;&#x2F; 返回 3 -&gt; [4, 2]<br>q.popMiddle();    &#x2F;&#x2F; 返回 4 -&gt; [2]<br>q.popBack();      &#x2F;&#x2F; 返回 2 -&gt; []<br>q.popFront();     &#x2F;&#x2F; 返回 -1 -&gt; [] （队列为空）<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= val &lt;= 10<sup>9</sup></code></li><li>最多调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1000</code><span>&nbsp;</span>次<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pushFront</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pushMiddle</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pushBack</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">popFront</code>，<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">popMiddle</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">popBack</code><span>&nbsp;</span>。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/design-front-middle-back-queue/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1670. 设计前中后队列</a>。</strong></details></p><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>这题有点难度，主要是细节不好把控。常规的队列只能在首尾进行操作，想在中间操作队列，需要在底层把队列切分成 <code>left, right</code> 两个列表，但这里的细节问题就是元素为奇数时两个链表中元素的分配问题。</p><p>直接看代码吧，注释很详细。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/ds-design/">【练习】更多经典设计习题</a></li><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">FrontMiddleBackQueue</span><span class="token punctuation">:</span>    <span class="token comment"># 用两个列表表示队列的左右两部分，一遍从中间操作元素</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>left <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>right <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 维护左边少右边多的状态，每次增删元素之后都要执行一次</span>    <span class="token keyword">def</span> <span class="token function">balance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 右边最多比左边多一个元素</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 右边多，匀一个给左边</span>            self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 左边多，匀一个给右边</span>            self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pushFront</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pushMiddle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 如果有偶数个元素时，pushMiddle 优先向右边添加</span>            self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">pushBack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">popFront</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment"># 如果只有 1 个元素，popFront 的时候，要去右边删除</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        e <span class="token operator">=</span> self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e        <span class="token keyword">def</span> <span class="token function">popMiddle</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            e <span class="token operator">=</span> self<span class="token punctuation">.</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果有奇数个元素时，popMiddle 优先从右边删除</span>            e <span class="token operator">=</span> self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e        <span class="token keyword">def</span> <span class="token function">popBack</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        e <span class="token operator">=</span> self<span class="token punctuation">.</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e        <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2073-买票需要的时间"><a href="#2073-买票需要的时间" class="headerlink" title="2073. 买票需要的时间"></a><a href="https://labuladong.online/algo/problem-set/queue/#slug_time-needed-to-buy-tickets">2073. 买票需要的时间</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">2073. 买票需要的时间</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/time-needed-to-buy-tickets/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个人前来排队买票，其中第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>人站在队伍<span>&nbsp;</span><strong style="font-weight: 600;">最前方</strong><span>&nbsp;</span>，第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(n - 1)</code><span>&nbsp;</span>人站在队伍<span>&nbsp;</span><strong style="font-weight: 600;">最后方</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始的整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tickets</code><span>&nbsp;</span>，数组长度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>，其中第<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>人想要购买的票数为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tickets[i]</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">每个人买票都需要用掉<span>&nbsp;</span><strong style="font-weight: 600;">恰好 1 秒</strong><span>&nbsp;</span>。一个人<span>&nbsp;</span><strong style="font-weight: 600;">一次只能买一张票</strong><span>&nbsp;</span>，如果需要购买更多票，他必须走到&nbsp;<span>&nbsp;</span><strong style="font-weight: 600;">队尾</strong><span>&nbsp;</span>重新排队（<strong style="font-weight: 600;">瞬间<span>&nbsp;</span></strong>发生，不计时间）。如果一个人没有剩下需要买的票，那他将会<span>&nbsp;</span><strong style="font-weight: 600;">离开</strong><span>&nbsp;</span>队伍。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回位于位置<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code>（下标从<span>&nbsp;</span><strong style="font-weight: 600;">0</strong><span>&nbsp;</span>开始）的人完成买票需要的时间（以秒为单位）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tickets = [2,3,2], k = 2<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong> - 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tickets = [5,1,1,1], k = 0<strong style="font-weight: 600;">输出：</strong>8<strong style="font-weight: 600;">解释：</strong>- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。- 接下来的 4 轮，只有位置 0 的人在买票。位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == tickets.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= tickets[i] &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= k &lt; n</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 2073. 买票需要的时间</a>。</strong></details><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>既然是排队问题，你用一个队列模拟整个买票过程，然后数一数过了多少秒就行了，不过时间空间复杂度就高了。</p><p>稍微思考一下可以想到更高效的方式：</p><p>首先，第 <code>k</code> 个人离开的时间，其实就是从开始到这个人买完票之后，卖出的总票数。</p><p>那么第 <code>k</code> 个人买完票之后，总共卖了多少票呢？</p><p>排在 <code>k</code> 之前的人最多买了 <code>tickets[k]</code> 张票；而排在 <code>k</code> 之后的人最多买了 <code>tickets[k] - 1</code> 张票。为什么说「最多」呢，因为有的人可能需要的票比较少，买完就直接走了。</p><p>综上，思路就出来了，看代码理解吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/queue/">【练习】队列的经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/queue/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">timeRequiredToBuy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tickets<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>tickets<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">:</span>                <span class="token comment"># 前面的人最多买了 tickets[k] 张票</span>                res <span class="token operator">+=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>tickets<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> tickets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 后面的人最多买了 tickets[k] - 1 张票</span>                res <span class="token operator">+=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>tickets<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tickets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】括号类问题汇总</title>
      <link href="/2025/06/14/lian-xi-gua-hao-lei-wen-ti-hui-zong/"/>
      <url>/2025/06/14/lian-xi-gua-hao-lei-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】括号类问题汇总"><a href="#【练习】括号类问题汇总" class="headerlink" title="【练习】括号类问题汇总"></a>【练习】括号类问题汇总</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://labuladong.online/algo/problem-set/parentheses/#_20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7">20. 有效的括号</a></h2><p>对括号的有效性判断多次在笔试中出现，现实中也很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 <code>[]()&#123;&#125;</code>，判断起来有一点难度。</p><p>来看一看力扣第 20 题「<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a>」，输入一个字符串，其中包含 <code>[]()&#123;&#125;</code> 六种括号，请你判断这个字符串组成的括号是否有效：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">20. 有效的括号</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个只包括<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#123;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#125;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'['</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">']'</code>&nbsp;的字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>，判断字符串是否有效。</p><p style="line-height: 1.6; overflow-wrap: break-word;">有效字符串需满足：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()[]{}"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(]"<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>仅由括号<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'()[]&#123;&#125;'</code><span>&nbsp;</span>组成</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 20. 有效的括号</a>。</strong></details><p>解决这个问题之前，我们先降低难度，思考一下，<strong>如果只有一种括号 <code>()</code></strong>，应该如何判断字符串组成的括号是否有效呢？</p><p>假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：</p><p><strong>每个右括号 <code>)</code> 的左边必须有一个左括号 <code>(</code> 和它匹配</strong>。</p><p>比如说字符串 <code>()))((</code> 中，中间的两个右括号<strong>左边</strong>就没有左括号匹配，所以这个括号组合是无效的。</p><p>那么根据这个思路，我们可以写出算法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 待匹配的左括号数量</span>    left <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 遇到右括号</span>            left <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 右括号太多</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token comment"># 是否所有的左括号都被匹配了</span>    <span class="token keyword">return</span> left <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 <code>left1</code>，<code>left2</code>，<code>left3</code> 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。</p><p>但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 <code>(())</code> 是有效的，但是多种括号的情况下， <code>[(])</code> 显然是无效的。</p><p>仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。</p><p>我们这道题就用一个名为 <code>left</code> 的栈代替之前思路中的 <code>left</code> 变量，<strong>遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">str</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> <span class="token string">'(&#123;['</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是左括号，入栈</span>                left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是右括号</span>                <span class="token keyword">if</span> left <span class="token keyword">and</span> self<span class="token punctuation">.</span>leftOf<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> left<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token comment"># 和最近的左括号不匹配</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 是否所有的左括号都被匹配了</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> left    <span class="token keyword">def</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#125;'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'&#123;'</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'('</span>        <span class="token keyword">return</span> <span class="token string">'['</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details data-v-ee1a9bd0="" id="div_valid-parentheses" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_valid-parentheses" src="https://labuladong.online/algo-visualize/leetcode/valid-parentheses/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>接下来讲另外两个常见的问题，如何通过最小的插入次数将括号变成有效的？</p><h2 id="921-使括号有效的最小添加"><a href="#921-使括号有效的最小添加" class="headerlink" title="921. 使括号有效的最小添加"></a><a href="https://labuladong.online/algo/problem-set/parentheses/#_921-%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%BB%E5%8A%A0">921. 使括号有效的最小添加</a></h2><p>先来个简单的，力扣第 921 题「<a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">使括号有效的最少添加</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">921. 使括号有效的最少添加</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">只有满足下面几点之一，括号字符串才是有效的：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>它是一个空字符串，或者</li><li>它可以被写成&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">AB</code>&nbsp;（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code>&nbsp;与&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">B</code>&nbsp;连接）, 其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">B</code>&nbsp;都是有效字符串，或者</li><li>它可以被写作&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(A)</code>，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">A</code>&nbsp;是有效字符串。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个括号字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s = "()))"</code><span>&nbsp;</span>，你可以插入一个开始括号为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"(()))"</code><span>&nbsp;</span>或结束括号为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"())))"</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">返回<span>&nbsp;</span><em>为使结果字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>有效而必须添加的最少括号数</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "())"<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "((("<strong style="font-weight: 600;">输出：</strong>3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 1000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>只包含&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>&nbsp;字符。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 921. 使括号有效的最少添加</a>。</strong></details><p>这其实和前文的判断括号有效性非常类似，我们直接看代码：</p><p>这段代码就是最终解法，<strong>核心思路是以左括号为基准，通过维护对右括号的需求数 <code>need</code>，来计算最小的插入次数</strong>。需要注意两个地方：</p><p><strong>1、当 <code>need == -1</code> 的时候意味着什么</strong>？</p><p>因为只有遇到右括号 <code>)</code> 的时候才会 <code>need--</code>，<code>need == -1</code> 意味着右括号太多了，所以需要插入左括号。</p><p>比如说 <code>s = &quot;))&quot;</code> 这种情况，需要插入 2 个左括号，使得 <code>s</code> 变成 <code>&quot;()()&quot;</code>，才是一个有效括号串。</p><p><strong>2、算法为什么返回 <code>res + need</code></strong>？</p><p>因为 <code>res</code> 记录的左括号的插入次数，<code>need</code> 记录了右括号的需求，当 for 循环结束后，若 <code>need</code> 不为 0，那么就意味着右括号还不够，需要插入。</p><p>比如说 <code>s = &quot;))(&quot;</code> 这种情况，插入 2 个左括号之后，还要再插入 1 个右括号，使得 <code>s</code> 变成 <code>&quot;()()()&quot;</code>，才是一个有效括号串。</p><p>以上就是这道题的思路，接下来我们看一道进阶题目，如果左右括号不是 1:1 配对，会出现什么问题呢？</p><h2 id="1541-平衡括号串的最少插入"><a href="#1541-平衡括号串的最少插入" class="headerlink" title="1541. 平衡括号串的最少插入"></a><a href="https://labuladong.online/algo/problem-set/parentheses/#_1541-%E5%B9%B3%E8%A1%A1%E6%8B%AC%E5%8F%B7%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5">1541. 平衡括号串的最少插入</a></h2><p>这是力扣第 1541 题「<a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">平衡括号字符串的最少插入次数</a>」：</p><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1541. 平衡括号字符串的最少插入次数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个括号字符串&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;，它只包含字符&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>&nbsp;。一个括号字符串被称为平衡的当它满足：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>任何左括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>&nbsp;必须对应两个连续的右括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'))'</code>&nbsp;。</li><li>左括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>&nbsp;必须在对应的连续两个右括号&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'))'</code>&nbsp;之前。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">比方说&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"())"</code>，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"())(())))"</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"(())())))"</code>&nbsp;都是平衡的，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">")()"</code>，&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"()))"</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"(()))"</code>&nbsp;都是不平衡的。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回让<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;平衡的最少插入次数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(()))"<strong style="font-weight: 600;">输出：</strong>1<strong style="font-weight: 600;">解释：</strong>第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "())"<strong style="font-weight: 600;">输出：</strong>0<strong style="font-weight: 600;">解释：</strong>字符串已经平衡了。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "))())("<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(((((("<strong style="font-weight: 600;">输出：</strong>12<strong style="font-weight: 600;">解释：</strong>添加 12 个 ')' 得到平衡字符串。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 5：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = ")))))))"<strong style="font-weight: 600;">输出：</strong>5<strong style="font-weight: 600;">解释：</strong>在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 10^5</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code>&nbsp;只包含&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1541. 平衡括号字符串的最少插入次数</a>。</strong></details><p>现在假设 1 个左括号需要匹配 2 个右括号才叫做有效的括号组合，那么给你输入一个括号串 <code>s</code>，请问你如何计算使得 <code>s</code> 有效的最小插入次数呢？</p><p><strong>核心思路还是和刚才一样，通过一个 <code>need</code> 变量记录对右括号的需求数，根据 <code>need</code> 的变化来判断是否需要插入</strong>。</p><p>第一步，我们按照刚才的思路正确维护 <code>need</code> 变量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">minInsertions</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>     <span class="token comment"># need 记录需右括号的需求量</span>    res <span class="token operator">=</span> <span class="token number">0</span>     need <span class="token operator">=</span> <span class="token number">0</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 一个左括号对应两个右括号</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>             need <span class="token operator">+=</span> <span class="token number">2</span>         <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>             need <span class="token operator">-=</span> <span class="token number">1</span>     <span class="token keyword">return</span> res <span class="token operator">+</span> need<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在想一想，当 <code>need</code> 为什么值的时候，我们可以确定需要进行插入？</p><p><strong>首先，类似第一题，当 <code>need == -1</code> 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号</strong>。</p><p>比如说当 <code>s = &quot;)&quot;</code>，我们肯定需要插入一个左括号让 <code>s = &quot;()&quot;</code>，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    need<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// 说明右括号太多了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 需要插入一个左括号</span>        res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 同时，对右括号的需求变为 1</span>        need <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号</strong>。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。</p><p>所以遇到左括号时要做如下判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    need <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 插入一个右括号</span>        res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 对右括号的需求减一</span>        need<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，我们可以写出正确的代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minInsertions</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># need 记录需右括号的需求量</span>        res <span class="token operator">=</span> <span class="token number">0</span>        need <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 一个左括号对应两个右括号</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>                need <span class="token operator">+=</span> <span class="token number">2</span>                <span class="token keyword">if</span> need <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 插入一个右括号</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>                    need <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>                need <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token comment"># 说明右括号太多了</span>                <span class="token keyword">if</span> need <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 需要插入一个左括号</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token comment"># 同时，对右括号的需求变为 1</span>                    need <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res <span class="token operator">+</span> need<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/06/14/lian-xi-gua-hao-lei-wen-ti-hui-zong/5.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【练习】栈的经典习题</title>
      <link href="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/"/>
      <url>/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="【练习】栈的经典习题"><a href="#【练习】栈的经典习题" class="headerlink" title="【练习】栈的经典习题"></a>【练习】栈的经典习题</h1><h2 id="考察先进后出性质"><a href="#考察先进后出性质" class="headerlink" title="考察先进后出性质"></a>考察先进后出性质</h2><p>对于栈这种数据结构的考察，主要考察先进后出特点的运用，比如表达式运算、括号合法性检测等问题，下面列出几个使用栈的经典场景。</p><h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_simplify-path">71. 简化路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">71. 简化路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/simplify-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/simplify-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">path</code><span>&nbsp;</span>，表示指向某一文件或目录的 Unix 风格<span>&nbsp;</span><strong style="font-weight: 600;">绝对路径<span>&nbsp;</span></strong>（以<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>开头），请你将其转化为更加简洁的规范路径。</p><p class="MachineTrans-lang-zh-CN" style="line-height: 1.6; overflow-wrap: break-word;">在 Unix 风格的文件系统中，一个点（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">.</code>）表示当前目录本身；此外，两个点 （<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'//'</code>）都被视为单个斜杠<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>。 对于此问题，任何其他格式的点（例如，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'...'</code>）均被视为文件/目录名称。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请注意，返回的<span>&nbsp;</span><strong style="font-weight: 600;">规范路径</strong><span>&nbsp;</span>必须遵循下述格式：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>始终以斜杠<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>开头。</li><li>两个目录名之间必须只有一个斜杠<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>。</li><li>最后一个目录名（如果存在）<strong style="font-weight: 600;">不能<span>&nbsp;</span></strong>以<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'.'</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'..'</code>）。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">返回简化后得到的<span>&nbsp;</span><strong style="font-weight: 600;">规范路径</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/home/"<strong style="font-weight: 600;">输出：</strong>"/home"<strong style="font-weight: 600;">解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/../"<strong style="font-weight: 600;">输出：</strong>"/"<strong style="font-weight: 600;">解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/home//foo/"<strong style="font-weight: 600;">输出：</strong>"/home/foo"<strong style="font-weight: 600;">解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>path = "/a/./b/../../c/"<strong style="font-weight: 600;">输出：</strong>"/c"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= path.length &lt;= 3000</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">path</code><span>&nbsp;</span>由英文字母，数字，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'.'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'_'</code><span>&nbsp;</span>组成。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">path</code><span>&nbsp;</span>是一个有效的 Unix 风格绝对路径。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/simplify-path/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 71. 简化路径</a>。</strong></details><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</a></h3><p>这题比较简单，利用栈先进后出的特性处理上级目录 <code>..</code>，最后组装化简后的路径即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">simplifyPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        parts <span class="token operator">=</span> path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 借助栈计算最终的文件夹路径</span>        <span class="token keyword">for</span> part <span class="token keyword">in</span> parts<span class="token punctuation">:</span>            <span class="token keyword">if</span> part <span class="token operator">==</span> <span class="token string">""</span> <span class="token keyword">or</span> part <span class="token operator">==</span> <span class="token string">"."</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> part <span class="token operator">==</span> <span class="token string">".."</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> stk<span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>part<span class="token punctuation">)</span>        <span class="token comment"># 栈中存储的文件夹组成路径</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">while</span> stk<span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> res        <span class="token keyword">return</span> res <span class="token keyword">if</span> res <span class="token keyword">else</span> <span class="token string">"/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></h3><details data-v-ee1a9bd0="" id="div_simplify-path" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_simplify-path" src="https://labuladong.online/algo-visualize/leetcode/simplify-path/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_reorder-list">143. 重排链表</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">143. 重排链表</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/reorder-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/reorder-list/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个单链表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">L</code><em><span>&nbsp;</span></em>的头节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">head</code><span>&nbsp;</span>，单链表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">L</code><span>&nbsp;</span>表示为：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">L<sub>0</sub> → L<sub>1</sub> → … → L<sub>n - 1</sub> → L<sub>n</sub></pre><p style="line-height: 1.6; overflow-wrap: break-word;">请将其重新排列后变为：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">L<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n - 1</sub> → L<sub>2</sub> → L<sub>n - 2</sub> → …</pre><p style="line-height: 1.6; overflow-wrap: break-word;">不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/1626420311-PkUiGI-image.png" style="max-width: 100%; width: 240px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [1,2,3,4]<strong style="font-weight: 600;">输出：</strong>[1,4,2,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/1626420320-YUiulT-image.png" style="max-width: 100%; width: 320px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>head = [1,2,3,4,5]<strong style="font-weight: 600;">输出：</strong>[1,5,2,4,3]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>链表的长度范围为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 5 * 10<sup>4</sup>]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/reorder-list/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 143. 重排链表</a>。</strong></details><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">基本思路</a></h3><p>这题的难点在于：一个单链表只能从头部向尾部遍历节点，无法从尾部开始向头部遍历节点。</p><p>那么我们可以利用「栈」先进后出的结构特点，按从头到尾的顺序让链表节点入栈，那么出栈顺序就是反过来从尾到头了。</p><p>有了这个栈，算法的大致逻辑如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">//</span> 链表尾部的节点    ListNode lastNode <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 按题目要求拼接    ListNode <span class="token builtin">next</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> lastNode<span class="token punctuation">;</span>    lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，处理单链表时细节问题比较多，注意操作指针时的顺序，避免操作失误形成环形链表，直接看我的代码注释吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 先把所有节点装进栈里，得到倒序结果</span>        p <span class="token operator">=</span> head        <span class="token keyword">while</span> p <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>        p <span class="token operator">=</span> head        <span class="token keyword">while</span> p <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 链表尾部的节点</span>            lastNode <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token builtin">next</span> <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token keyword">if</span> lastNode <span class="token operator">==</span> <span class="token builtin">next</span> <span class="token keyword">or</span> lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">==</span> <span class="token builtin">next</span><span class="token punctuation">:</span>                <span class="token comment"># 结束条件，链表节点数为奇数或偶数时均适用</span>                lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>                <span class="token keyword">break</span>            p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> lastNode            lastNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token builtin">next</span>            p <span class="token operator">=</span> <span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-1"><a href="#可视化-1" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-1">可视化</a></h3><details data-v-ee1a9bd0="" id="div_reorder-list" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_reorder-list" src="https://labuladong.online/algo-visualize/leetcode/reorder-list/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/LGjMqU">剑指 Offer II 026. 重排链表 🟠</a></li></ul><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_valid-parentheses">20. 有效的括号</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">20. 有效的括号</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/valid-parentheses/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个只包括<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'('</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">')'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#123;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'&#125;'</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'['</code>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">']'</code>&nbsp;的字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>，判断字符串是否有效。</p><p style="line-height: 1.6; overflow-wrap: break-word;">有效字符串需满足：</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "()[]{}"<strong style="font-weight: 600;">输出：</strong>true</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>s = "(]"<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= s.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">s</code><span>&nbsp;</span>仅由括号<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'()[]&#123;&#125;'</code><span>&nbsp;</span>组成</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/valid-parentheses/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 20. 有效的括号</a>。</strong></details><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">基本思路</a></h3><p>栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。</p><p>括号的有效性判断在笔试中和现实中都很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 <code>[]()&#123;&#125;</code>，判断起来有一点难度。</p><p>解决这个问题之前，我们先降低难度，思考一下，<strong>如果只有一种括号 <code>()</code></strong>，应该如何判断字符串组成的括号是否有效呢？</p><p>假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：</p><p><strong>每个右括号 <code>)</code> 的左边必须有一个左括号 <code>(</code> 和它匹配</strong>。</p><p>比如说字符串 <code>()))((</code> 中，中间的两个右括号<strong>左边</strong>就没有左括号匹配，所以这个括号组合是无效的。</p><p>那么根据这个思路，我们可以写出算法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 待匹配的左括号数量</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 遇到右括号</span>            left<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 右括号太多</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 是否所有的左括号都被匹配了</span>    <span class="token keyword">return</span> left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 <code>left1</code>，<code>left2</code>，<code>left3</code> 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。</p><p>但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 <code>(())</code> 是有效的，但是多种括号的情况下， <code>[(])</code> 显然是无效的。</p><p>仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。</p><p>我们这道题就用一个名为 <code>left</code> 的栈代替之前思路中的 <code>left</code> 变量，<strong>遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</strong>。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">str</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> <span class="token string">'(&#123;['</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是左括号，入栈</span>                left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 字符 c 是右括号</span>                <span class="token keyword">if</span> left <span class="token keyword">and</span> self<span class="token punctuation">.</span>leftOf<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> left<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token comment"># 和最近的左括号不匹配</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment"># 是否所有的左括号都被匹配了</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> left    <span class="token keyword">def</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#125;'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'&#123;'</span>        <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'('</span>        <span class="token keyword">return</span> <span class="token string">'['</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-2"><a href="#可视化-2" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-2">可视化</a></h3><details data-v-ee1a9bd0="" id="div_valid-parentheses" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_valid-parentheses" src="https://labuladong.online/algo-visualize/leetcode/valid-parentheses/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_evaluate-reverse-polish-notation">150. 逆波兰表达式求值</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">150. 逆波兰表达式求值</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个字符串数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tokens</code><span>&nbsp;</span>，表示一个根据&nbsp;<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">逆波兰表示法</a><span>&nbsp;</span>表示的算术表达式。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你计算该表达式。返回一个表示表达式值的整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>有效的算符为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'+'</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'-'</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'*'</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是<span>&nbsp;</span><strong style="font-weight: 600;">向零截断</strong><span>&nbsp;</span>。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用<span>&nbsp;</span><strong style="font-weight: 600;">32 位</strong><span>&nbsp;</span>整数表示。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tokens = ["2","1","+","3","*"]<strong style="font-weight: 600;">输出：</strong>9<strong style="font-weight: 600;">解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tokens = ["4","13","5","/","+"]<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]<strong style="font-weight: 600;">输出：</strong>22<strong style="font-weight: 600;">解释：</strong>该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">tokens[i]</code>&nbsp;是一个算符（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"+"</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"-"</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"*"</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"/"</code>），或是在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-200, 200]</code><span>&nbsp;</span>内的一个整数</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">逆波兰表达式：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;">逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>平常使用的算式则是一种中缀表达式，如<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">( 1 + 2 ) * ( 3 + 4 )</code><span>&nbsp;</span>。</li><li>该算式的逆波兰表达式写法为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">( ( 1 2 + ) ( 3 4 + ) * )</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">逆波兰表达式主要有以下两个优点：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>去掉括号后表达式无歧义，上式即便写成<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 2 + 3 4 + *<span>&nbsp;</span></code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 150. 逆波兰表达式求值</a>。</strong></details><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">基本思路</a></h3><p>逆波兰表达式发明出来就是为了方便计算机运用「栈」进行表达式运算的，其运算规则如下：</p><p>按顺序遍历逆波兰表达式中的字符，如果是数字，则放入栈；如果是运算符，则将栈顶的两个元素拿出来进行运算，再将结果放入栈。对于减法和除法，运算顺序别搞反了，栈顶第二个数是被除（减）数。</p><p>所以这题很简单，直接按照运算规则借助栈计算表达式结果即可。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> token <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>            <span class="token keyword">if</span> token <span class="token keyword">in</span> <span class="token string">"+-*/"</span><span class="token punctuation">:</span>                <span class="token comment"># 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈</span>                a <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>                <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span>                <span class="token comment"># 对于减法和除法，顺序别搞反了，第二个数是被除（减）数</span>                <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span>                <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">:</span>                    stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>b <span class="token operator">/</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># Ensure the result is an integer</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 是个数字，直接入栈即可</span>                stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 最后栈中剩下一个数字，即是计算结果</span>        <span class="token keyword">return</span> stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化-3"><a href="#可视化-3" class="headerlink" title="可视化"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%8F%AF%E8%A7%86%E5%8C%96-3">可视化</a></h3><details data-v-ee1a9bd0="" id="div_evaluate-reverse-polish-notation" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_evaluate-reverse-polish-notation" src="https://labuladong.online/algo-visualize/leetcode/evaluate-reverse-polish-notation/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/8Zf90G">剑指 Offer II 036. 后缀表达式 🟠</a></li></ul><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_implement-stack-using-queues">225. 用队列实现栈</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">225. 用队列实现栈</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/implement-stack-using-queues/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/implement-stack-using-queues/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">empty</code>）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MyStack</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void push(int x)</code><span>&nbsp;</span>将元素 x 压入栈顶。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int pop()</code><span>&nbsp;</span>移除并返回栈顶元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int top()</code><span>&nbsp;</span>返回栈顶元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean empty()</code><span>&nbsp;</span>如果栈是空的，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>你只能使用队列的标准操作 —— 也就是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push to back</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">peek/pop from front</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">size</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">is empty</code>&nbsp;这些操作。</li><li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["MyStack", "push", "push", "top", "pop", "empty"][[], [1], [2], [], [], []]<strong style="font-weight: 600;">输出：</strong>[null, null, null, 2, 2, false]<p><strong style="font-weight: 600;">解释：</strong><br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= x &lt;= 9</code></li><li>最多调用<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>次<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">empty</code></li><li>每次调用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>都保证栈不为空</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">进阶：</strong>你能否仅用一个队列来实现栈。</p></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/implement-stack-using-queues/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 225. 用队列实现栈</a>。</strong></details></p><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">基本思路</a></h3><p>底层用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。</p><p>底层队列只能向队尾添加元素，所以栈的 <code>pop</code> API 相当于要从队尾取元素：</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/5.jpg" alt="img"></p><p>那么最简单的思路就是，把队尾元素前面的所有元素重新塞到队尾，让队尾元素排到队头，这样就可以取出了：</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/6.jpg" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/data-structure/stack-queue/">队列实现栈以及栈实现队列</a></li><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 将元素 x 压入栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># x 是队列的队尾，是栈的栈顶</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> x    <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top_elem    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>        <span class="token comment"># 留下队尾 2 个元素</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 记录新的队尾元素</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 删除之前的队尾元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 判断栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232. 用栈实现队列 🟢</a></li><li><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">剑指 Offer 09. 用两个栈实现队列 🟢</a></li></ul><h2 id="388-文件的最长绝对路径"><a href="#388-文件的最长绝对路径" class="headerlink" title="388. 文件的最长绝对路径"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_longest-absolute-file-path">388. 文件的最长绝对路径</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">388. 文件的最长绝对路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/longest-absolute-file-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/longest-absolute-file-path/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/28/mdir.jpg" style="max-width: 100%; height: 142px; width: 300px;"></p><p style="line-height: 1.6; overflow-wrap: break-word;">这里将<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">dir</code><span>&nbsp;</span>作为根目录中的唯一目录。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">dir</code><span>&nbsp;</span>包含两个子目录<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir2</code><span>&nbsp;</span>。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir1</code><span>&nbsp;</span>包含文件<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">file1.ext</code><span>&nbsp;</span>和子目录<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subsubdir1</code>；<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subdir2</code><span>&nbsp;</span>包含子目录<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">subsubdir2</code>，该子目录下包含文件<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">file2.ext</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">在文本格式中，如下所示(⟶表示制表符)：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">dir⟶ subdir1⟶ ⟶ file1.ext⟶ ⟶ subsubdir1⟶ subdir2⟶ ⟶ subsubdir2⟶ ⟶ ⟶ file2.ext</pre><p style="line-height: 1.6; overflow-wrap: break-word;">如果是代码表示，上面的文件系统可以写为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</code><span>&nbsp;</span>。<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\n'</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\t'</code><span>&nbsp;</span>分别是换行符和制表符。</p><p style="line-height: 1.6; overflow-wrap: break-word;">文件系统中的每个文件和文件夹都有一个唯一的<span>&nbsp;</span><strong style="font-weight: 600;">绝对路径</strong><span>&nbsp;</span>，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'/'</code><span>&nbsp;</span>连接。上面例子中，指向<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">file2.ext</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">绝对路径</strong><span>&nbsp;</span>是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"dir/subdir2/subsubdir2/file2.ext"</code><span>&nbsp;</span>。每个目录名由字母、数字和/或空格组成，每个文件名遵循<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">name.extension</code><span>&nbsp;</span>的格式，其中&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">name</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">extension</code>由字母、数字和/或空格组成。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个以上述格式表示文件系统的字符串<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">input</code><span>&nbsp;</span>，返回文件系统中&nbsp;<em>指向&nbsp;<strong style="font-weight: 600;">文件</strong>&nbsp;的<span>&nbsp;</span><strong style="font-weight: 600;">最长绝对路径</strong><span>&nbsp;</span>的长度</em>&nbsp;。 如果系统中没有文件，返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/28/dir1.jpg" style="max-width: 100%; height: 101px; width: 200px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"<strong style="font-weight: 600;">输出：</strong>20<strong style="font-weight: 600;">解释：</strong>只有一个文件，绝对路径为 "dir/subdir2/file.ext" ，路径长度 20</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2020/08/28/dir2.jpg" style="max-width: 100%; height: 151px; width: 300px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"<strong style="font-weight: 600;">输出：</strong>32<strong style="font-weight: 600;">解释：</strong>存在两个文件："dir/subdir1/file1.ext" ，路径长度 21"dir/subdir2/subsubdir2/file2.ext" ，路径长度 32返回 32 ，因为这是最长的路径</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "a"<strong style="font-weight: 600;">输出：</strong>0<strong style="font-weight: 600;">解释：</strong>不存在任何文件</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>input = "file1.txt\nfile2.txt\nlongfile.txt"<strong style="font-weight: 600;">输出：</strong>12<strong style="font-weight: 600;">解释：</strong>根目录下有 3 个文件。因为根目录中任何东西的绝对路径只是名称本身，所以答案是 "longfile.txt" ，路径长度为 12</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= input.length &lt;= 10<sup>4</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">input</code><span>&nbsp;</span>可能包含小写或大写的英文字母，一个换行符<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\n'</code>，一个制表符<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'\t'</code>，一个点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'.'</code>，一个空格<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">' '</code>，和数字。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/longest-absolute-file-path/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 388. 文件的最长绝对路径</a>。</strong></details><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">基本思路</a></h3><p>我觉得这道题还是比较实用的，因为在我做这道题之前，我就思考并解决过这个问题，可以在这里和大家分享下我的使用场景：</p><p>你可以看我的 <a href="https://github.com/labuladong/fucking-algorithm#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">GitHub 仓库中的文章目录</a>，是通过缩进来表示层级的，很类似本题所说的场景。然而我需要把这些目录转化成 HTML 文档，按照文件目录的形式把这些 HTML 部署到 <a href="https://labuladong.gitee.io/algo/">我的网站</a> 上。你看，这是不是就涉及到本题生成文件的绝对路径的问题？</p><p>对于这个场景，我当时其实尝试很多可行的办法。但这里我还是写一个最简单直接容易理解的解法吧，那就是用栈来辅助，对于每一个路径，都去维护正确的父路径，从而计算最长路径的长度。具体看代码注释吧。</p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthLongestPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 这个栈存储之前的父路径。实际上这里只用存父路径的长度就够了，这个优化留给你吧</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        max_len <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> part <span class="token keyword">in</span> <span class="token builtin">input</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            level <span class="token operator">=</span> part<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment"># 让栈中只保留当前目录的父路径</span>            <span class="token keyword">while</span> level <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span> <span class="token operator">-</span> level<span class="token punctuation">)</span>            <span class="token comment"># 如果是文件，就计算路径长度</span>            <span class="token keyword">if</span> <span class="token string">"."</span> <span class="token keyword">in</span> part<span class="token punctuation">:</span>                total_length <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>                <span class="token comment"># 加上父路径的分隔符</span>                max_len <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>max_len<span class="token punctuation">,</span> total_length<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的设计题"><a href="#栈的设计题" class="headerlink" title="栈的设计题"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E6%A0%88%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%A2%98">栈的设计题</a></h2><p>除了上面几道题，还有一类常考题目是让你设计具备额外功能的栈结构。</p><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_min-stack">155. 最小栈</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">155. 最小栈</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/min-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/min-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个支持<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code><span>&nbsp;</span>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code><span>&nbsp;</span>，<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>操作，并能在常数时间内检索到最小元素的栈。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MinStack</code><span>&nbsp;</span>类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">MinStack()</code><span>&nbsp;</span>初始化堆栈对象。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void push(int val)</code><span>&nbsp;</span>将元素val推入堆栈。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void pop()</code><span>&nbsp;</span>删除堆栈顶部的元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int top()</code><span>&nbsp;</span>获取堆栈顶部的元素。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int getMin()</code><span>&nbsp;</span>获取堆栈中的最小元素。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]<p><strong style="font-weight: 600;">输出：</strong><br>[null,null,null,null,-3,null,0,-2]</p><p><strong style="font-weight: 600;">解释：</strong><br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>、<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getMin</code><span>&nbsp;</span>操作总是在<span>&nbsp;</span><strong style="font-weight: 600;">非空栈</strong><span>&nbsp;</span>上调用</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>,&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">top</code>, and&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">getMin</code>最多被调用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">3 * 10<sup>4</sup></code>&nbsp;次</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/min-stack/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 155. 最小栈</a>。</strong></details></p><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">基本思路</a></h3><p><a href="https://labuladong.online/algo/data-structure-basic/queue-stack-basic/">根据我们之前亲自动手实现的栈</a>，我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 <code>getMin</code> 方法，只能老老实实把所有元素弹出来然后找最小值。<strong>想提高时间效率，那肯定要通过空间换时间的思路</strong>。</p><p>不过在具体说解法之前，我想聊一下动态集合中维护最值的问题。这类问题看似简单，但实际上是个很棘手的问题。其实本题就是如下一个场景：</p><p>假设你有若干数字，你用一个 <code>min</code> 变量维护了其中的最小值，如果现在给这些数字中添加一个新数字，那么只要比较这个新数字和 <code>min</code> 的大小就可以得出最新的最小值。但如果现在从这些数字钟删除一个数字，你还能用 <code>min</code> 变量得到最小值吗？答案是不能，因为如果这个被删除的数字恰好是最小值，那么新的 <code>min</code> 变量应该更新为第二小的元素对吧，但是我没有记录第二小的元素是多少，所以只能把所有数字重新遍历一遍。</p><p>明确了难点再回到本题，就可以对症下药了。删除栈顶元素的时候，不确定新的最小值是多少，但楼下那哥们知道啊，他当时入栈时的最小值，就是现在的最小值呗。</p><p>所以这道题的关键就是，<strong>每个元素入栈时，还要记下来当前栈中的最小值</strong>。比方说，可以用一个额外的栈 <code>minStk</code> 来记录栈中每个元素入栈时的栈中的最小元素是多少，这样每次删除元素时就能快速得到剩余栈中的最小元素了。</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/155.jpeg" alt="img"></p><p>当然，我们还可以做一些优化，减少 <code>minStk</code> 中存储的元素个数，我把原始解法和优化解法都写出来了，供参考。</p><blockquote><p>PS：这道题并不难，但我还是很细致地分析了，希望你深刻理解其中的难点。下一步可以做一下 <a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值</a>，请仔细观察和思考，队列结构是如何解决这个难点的。</p></blockquote><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/ds-design/">【练习】更多经典设计习题</a></li><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 原始思路</span><span class="token keyword">class</span> <span class="token class-name">MinStack1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录栈中的所有元素</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 阶段性记录栈中的最小元素</span>        self<span class="token punctuation">.</span>minStk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 维护 minStk 栈顶为全栈最小元素</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>minStk <span class="token keyword">or</span> val <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 新插入的这个元素就是全栈最小的</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 插入的这个元素比较大</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minStk 栈顶为全栈最小元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 优化版</span><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录栈中的所有元素</span>        self<span class="token punctuation">.</span>stk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 阶段性记录栈中的最小元素</span>        self<span class="token punctuation">.</span>minStk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 维护 minStk 栈顶为全栈最小元素</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>minStk <span class="token keyword">or</span> val <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 新插入的这个元素就是全栈最小的</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 注意 Java 的语言特性，比较 Integer 相等要用 equals 方法</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment"># 弹出的元素是全栈最小的</span>            self<span class="token punctuation">.</span>minStk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># minStk 栈顶为全栈最小元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>minStk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似题目</strong>：</p><ul><li><a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值 🔴</a></li><li><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">剑指 Offer 30. 包含min函数的栈 🟢</a></li><li><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">剑指 Offer 59 - I. 滑动窗口的最大值 🔴</a></li></ul><h2 id="895-最大频率栈"><a href="#895-最大频率栈" class="headerlink" title="895. 最大频率栈"></a><a href="https://labuladong.online/algo/problem-set/stack/#slug_maximum-frequency-stack">895. 最大频率栈</a></h2><details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">895. 最大频率栈</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/maximum-frequency-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/maximum-frequency-stack/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong style="font-weight: 600;">出现频率</strong>最高的元素。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FreqStack</code>&nbsp;类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">FreqStack()</code>&nbsp;构造一个空的堆栈。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">void push(int val)</code>&nbsp;将一个整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code>&nbsp;压入栈顶。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int pop()</code>&nbsp;删除并返回堆栈中出现频率最高的元素。<ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<strong style="font-weight: 600;">输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]<strong style="font-weight: 600;">解释：</strong>FreqStack = new FreqStack();freqStack.push (5);//堆栈为 [5]freqStack.push (7);//堆栈是 [5,7]freqStack.push (5);//堆栈是 [5,7,5]freqStack.push (7);//堆栈是 [5,7,5,7]freqStack.push (4);//堆栈是 [5,7,5,7,4]freqStack.push (5);//堆栈是 [5,7,5,7,4,5]freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= val &lt;= 10<sup>9</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">push</code>&nbsp;和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>&nbsp;的操作数不大于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2 * 10<sup>4</sup></code>。</li><li>输入保证在调用&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">pop</code>&nbsp;之前堆栈中至少有一个元素。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/maximum-frequency-stack/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 895. 最大频率栈</a>。</strong></details><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-7">基本思路</a></h3><p><strong>这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API</strong>。</p><p>那么，我们仔细思考一下 <code>push</code> 和 <code>pop</code> 方法，难点如下：</p><p>1、每次 <code>pop</code> 时，必须要知道频率最高的元素是什么。</p><p>2、如果频率最高的元素有多个，还得知道哪个是最近 <code>push</code> 进来的元素是哪个。</p><p>为了实现上述难点，我们要做到以下几点：</p><p>1、肯定要有一个变量 <code>maxFreq</code> 记录当前栈中最高的频率是多少。</p><p>2、我们得知道一个频率 <code>freq</code> 对应的元素有哪些，且这些元素要有时间顺序。</p><p>3、随着 <code>pop</code> 的调用，每个 <code>val</code> 对应的频率会变化，所以还得维持一个映射记录每个 <code>val</code> 对应的 <code>freq</code>。</p><p>综上，我们可以先实现 <code>FreqStack</code> 所需的数据结构：</p><pre class="line-numbers language-none"><code class="language-none">class FreqStack &#123;    &#x2F;&#x2F; 记录 FreqStack 中元素的最大频率    int maxFreq &#x3D; 0;    &#x2F;&#x2F; 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表    HashMap&lt;Integer, Integer&gt; valToFreq &#x3D; new HashMap&lt;&gt;();    &#x2F;&#x2F; 记录频率 freq 对应的 val 列表，后文就称为 FV 表    HashMap&lt;Integer, Stack&lt;Integer&gt;&gt; freqToVals &#x3D; new HashMap&lt;&gt;();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这有点类似后文 <a href="https://labuladong.online/algo/frequency-interview/lfu/">手把手实现 LFU 算法</a>，注意 <code>freqToVals</code> 中 <code>val</code> 列表用一个栈实现，如果一个 <code>freq</code> 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。</p><p>具体看解法代码吧，要记住在 <code>push</code> 和 <code>pop</code> 方法中同时修改 <code>maxFreq</code>、<code>VF</code> 表、<code>FV</code> 表，否则容易出现 bug。</p><p>算法执行过程如下 GIF 所示：</p><p><img src="/2025/06/14/lian-xi-zhan-de-jing-dian-xi-ti/1.gif" alt="img"></p><p><strong>详细题解</strong>：</p><ul><li><a href="https://labuladong.online/algo/problem-set/ds-design/">【练习】更多经典设计习题</a></li><li><a href="https://labuladong.online/algo/problem-set/stack/">【练习】栈的经典习题</a></li></ul><h3 id="解法代码-7"><a href="#解法代码-7" class="headerlink" title="解法代码"></a><a href="https://labuladong.online/algo/problem-set/stack/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-7">解法代码</a></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">FreqStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 记录 FreqStack 中元素的最大频率</span>        self<span class="token punctuation">.</span>maxFreq <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表</span>        self<span class="token punctuation">.</span>valToFreq <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment"># 记录频率 freq 对应的 val 列表，后文就称为 FV 表</span>        self<span class="token punctuation">.</span>freqToVals <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 修改 VF 表：val 对应的 freq 加一</span>        freq <span class="token operator">=</span> self<span class="token punctuation">.</span>valToFreq<span class="token punctuation">.</span>get<span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>valToFreq<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> freq        <span class="token comment"># 修改 FV 表：在 freq 对应的列表加上 val</span>        <span class="token keyword">if</span> freq <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">[</span>freq<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token comment"># 更新 maxFreq</span>        self<span class="token punctuation">.</span>maxFreq <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxFreq<span class="token punctuation">,</span> freq<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 修改 FV 表：pop 出一个 maxFreq 对应的元素 v</span>        vals <span class="token operator">=</span> self<span class="token punctuation">.</span>freqToVals<span class="token punctuation">[</span>self<span class="token punctuation">.</span>maxFreq<span class="token punctuation">]</span>        v <span class="token operator">=</span> vals<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 修改 VF 表：v 对应的 freq 减一</span>        self<span class="token punctuation">.</span>valToFreq<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 更新 maxFreq</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> vals<span class="token punctuation">:</span>            <span class="token comment"># 如果 maxFreq 对应的元素空了</span>            self<span class="token punctuation">.</span>maxFreq <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列实现栈以及栈实现队列</title>
      <link href="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/"/>
      <url>/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h1><p>队列是一种先进先出的数据结构，栈是一种先进后出的数据结构，形象一点就是这样：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/1.jpg" alt="img"></p><p>这两种数据结构底层其实都是数组或者链表实现的，只是 API 限定了它们的特性</p><p>今天来看看如何使用「栈」的特性来实现一个「队列」，如何用「队列」实现一个「栈」。</p><h3 id="一、用栈实现队列"><a href="#一、用栈实现队列" class="headerlink" title="一、用栈实现队列"></a><a href="https://labuladong.online/algo/data-structure/stack-queue/#%E4%B8%80%E3%80%81%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">一、用栈实现队列</a></h3><p>力扣第 232 题「<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a>」让我们实现的 API 如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">lass MyQueue<span class="token punctuation">:</span>    <span class="token comment"># 添加元素到队尾</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 删除队头的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 返回队头元素</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 判断队列是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用两个栈 <code>s1, s2</code> 就能实现一个队列的功能（这样放置栈可能更容易理解）：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/2.jpg" alt="img"></p><p>当调用 <code>push</code> 让元素入队时，只要把元素压入 <code>s1</code> 即可，比如说 <code>push</code> 进 3 个元素分别是 1,2,3，那么底层结构就是这样：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/3.jpg" alt="img"></p><p>那么如果这时候使用 <code>peek</code> 查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在 <code>s1</code> 中 1 被压在栈底，现在就要轮到 <code>s2</code> 起到一个中转的作用了：当 <code>s2</code> 为空时，可以把 <code>s1</code> 的所有元素取出再添加进 <code>s2</code>，<strong>这时候 <code>s2</code> 中元素就是先进先出顺序了</strong>：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/4.jpg" alt="img"></p><p>当 <code>s2</code> 中存在元素时，直接调用操作 <code>s2</code> 的 <code>pop</code> 方法，弹出的就是最先插入的元素，即实现了队列的 <code>pop</code> 操作。</p><p>完整代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用两个栈s1和s2</span>        self<span class="token punctuation">.</span>s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 添加元素到队尾</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment"># 返回队头元素</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>s2<span class="token punctuation">:</span>            <span class="token comment"># 把 s1 元素压入 s2</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>s1<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>s2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>s2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># 删除队头元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 先调用 peek 保证 s2 非空</span>        self<span class="token punctuation">.</span>peek<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>s2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 判断队列是否为空</span>    <span class="token comment"># 两个栈都为空才说明队列为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>s1 <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>s2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，就用栈结构实现了一个队列，核心思想是利用两个栈互相配合。</p><p>值得一提的是，这几个操作的时间复杂度是多少呢？</p><p>有点意思的是 <code>peek</code> 操作，调用它时可能触发 <code>while</code> 循环，这样的话时间复杂度是 O(N)，但是大部分情况下 <code>while</code> 循环不会被触发，时间复杂度是 O(1)。由于 <code>pop</code> 操作调用了 <code>peek</code>，它的时间复杂度和 <code>peek</code> 相同。</p><p>像这种情况，可以说它们的<strong>最坏时间复杂度</strong>是 O(N)，因为包含 <code>while</code> 循环，<strong>可能</strong>需要从 <code>s1</code> 往 <code>s2</code> 搬移元素。</p><p>但是它们的<strong>均摊时间复杂度</strong>是 O(1)，这个要这么理解：对于一个元素，最多只可能被搬运一次，也就是说 <code>peek</code> 操作平均到每个元素的时间复杂度是 O(1)。</p><h3 id="二、用队列实现栈"><a href="#二、用队列实现栈" class="headerlink" title="二、用队列实现栈"></a><a href="https://labuladong.online/algo/data-structure/stack-queue/#%E4%BA%8C%E3%80%81%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">二、用队列实现栈</a></h3><p>如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构就能实现了。</p><p>力扣第 225 题「<a href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈</a>」让我们实现如下 API：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token comment"># 添加元素到栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 判断栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先说 <code>push</code> API，直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 <code>top</code> 查看栈顶元素的话可以直接返回：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 使用一个队列 q 来实现一个栈</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 栈顶元素</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 添加元素到栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># x 是队列的队尾，是栈的栈顶</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> x        <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top_elem    <span class="token comment"># 检查栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的底层数据结构是先进先出的队列，每次 <code>pop</code> 只能从队头取元素；但是栈是后进先出，也就是说 <code>pop</code> API 要从队尾取元素：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/5.jpg" alt="img"></p><p>解决方法简单粗暴，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出了：</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/6.jpg" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token comment"># 为了节约篇幅，省略上文给出的代码部分...</span>    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 之前的队尾元素已经到了队头</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样实现还有一点小问题就是，原来的队尾元素被推到队头并删除了，但是 <code>top_elem</code> 变量没有更新，我们还需要一点小修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token comment"># 为了节约篇幅，省略上文给出的代码部分...</span>    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">)</span>        <span class="token comment"># 留下队尾 2 个元素</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 记录新的队尾元素</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 删除之前的队尾元素</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就实现完了，完整的代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 添加元素到栈顶</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> x    <span class="token comment"># 删除栈顶的元素并返回</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            size <span class="token operator">-=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>top_elem <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 返回栈顶元素</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>top_elem    <span class="token comment"># 判断栈是否为空</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，用队列实现栈的话，<code>pop</code> 操作时间复杂度是 O(N)，其他操作都是 O(1)。</p><p>个人认为，用队列实现栈是没啥亮点的问题，但是用双栈实现队列是值得学习的。</p><p><img src="/2025/06/14/dui-lie-shi-xian-zhan-yi-ji-zhan-shi-xian-dui-lie/4.jpg" alt="img"></p><p>从栈 <code>s1</code> 搬运元素到 <code>s2</code> 之后，元素在 <code>s2</code> 中就变成了队列的先进先出顺序，这个特性有点类似「负负得正」，确实不太容易想到。</p>]]></content>
      
      
      <categories>
          
          <category> 经典队列/栈算法 </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的花式反转方法汇总</title>
      <link href="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/"/>
      <url>/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="反转整个单链表"><a href="#反转整个单链表" class="headerlink" title="反转整个单链表"></a>反转整个单链表</h2><p>在 力扣&#x2F;LeetCode 中，单链表的通用结构是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 单链表节点的结构</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单链表反转是一个比较基础的算法题，力扣第 206 题 <a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a> 就是这个问题：</p><p>下面我们来尝试用多种方法解决这个问题。</p><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>这道题的常规做法就是迭代解法，通过操作几个指针，将链表中的每个节点的指针方向反转，没什么难点，主要是指针操作的细节问题。</p><p>这里直接给出代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 反转以 head 为起点的单链表</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment"># 由于单链表的结构，至少要用三个指针才能完成迭代反转</span>        <span class="token comment"># cur 是当前遍历的节点，pre 是 cur 的前驱结点，nxt 是 cur 的后继结点</span>        pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> nxt <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token keyword">while</span> cur <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 逐个结点反转</span>            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre            <span class="token comment"># 更新指针位置</span>            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> nxt            <span class="token keyword">if</span> nxt <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                nxt <span class="token operator">=</span> nxt<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 返回反转后的头结点</span>        <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个解法的思路是：</p><ul><li>首先判断链表是否为空或只有一个结点，如果是，则直接返回原链表。</li><li>然后初始化三个指针：<code>pre</code> 是前驱指针，<code>cur</code> 是当前指针，<code>nxt</code> 是后继指针。</li><li>然后开始迭代，每次迭代都将当前结点的 <code>next</code> 指针指向 <code>pre</code>，然后更新 <code>pre</code>、<code>cur</code>、<code>nxt</code> 指针的位置。</li><li>最后返回 <code>pre</code> 指针，即为反转后的头结点。</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>上面的迭代解法操作指针虽然有些繁琐，但是思路还是比较清晰的。如果现在让你用递归来反转单链表，你有啥想法没？</p><p><strong>递归反转单链表的关键在于，这个问题本身是存在子问题结构的。</strong></p><p>比方说，现在给你输入一个以 1 为头结点单链表 1-&gt;2-&gt;3-&gt;4，那么如果我忽略这个头结点 1，只拿出 2-&gt;3-&gt;4 这个子链表，它也是个单链表对吧？</p><p>那么你这个 <code>reverseList</code> 函数，只要输入一个单链表，就能给我反转对吧？那么你能不能用这个函数先来反转 <code>2-&gt;3-&gt;4 </code>这个子链表呢，然后再想办法把 <code>1</code> 接到反转后的 <code>4-&gt;3-&gt;2 </code>的最后面，是不是就完成了整个链表的反转？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-></span><span class="token number">2</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这就是「分解问题」的思路，通过递归函数的定义，把原问题分解成若干规模更小、结构相同的子问题，最后通过子问题的答案组装原问题的解。</strong></p><p>因此，我们可以用递归函数来反转单链表，如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        last <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">)</span>         head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head         head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">return</span> last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于「分解问题」思路的递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 <code>reverseList</code> 函数定义是这样的：</p><p><strong>输入一个节点 <code>head</code>，将「以 <code>head</code> 为起点」的链表反转，并返回反转之后的头结点</strong>。</p><p>明白了函数的定义，再来看这个问题。比如说我们想反转这个链表：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/1.jpg" alt="img"></p><p>那么输入 <code>reverseList(head)</code> 后，会在这里进行递归：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode last <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/2.jpg" alt="img"></p><p>这个 <code>reverseList(head.next)</code> 执行完成后，整个链表就成了这样：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/3.jpg" alt="img"></p><p>现在再来看下面的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/4.jpg" alt="img"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">return</span> last<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/5.jpg" alt="img"></p><p>神不神奇，这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：</p><p>1、递归函数要有 base case，也就是这句：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>意思是如果链表为空或者只有一个节点的时候，反转结果就是它自己，直接返回即可。</p><p>2、当链表递归反转之后，新的头结点是 <code>last</code>，而之前的 <code>head</code> 变成了最后一个节点，别忘了链表的末尾要指向 null：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，整个单链表就完成反转了。</p><blockquote><p>递归操作链表的效率不如迭代</p><p>值得一提的是，递归操作链表并不高效。</p><p>递归解法和迭代解法相比，时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。</p><p>所以递归操作链表可以用来练习递归思维，但是考虑效率的话还是使用迭代算法更好。</p></blockquote><h2 id="反转链表前-N-个节点"><a href="#反转链表前-N-个节点" class="headerlink" title="反转链表前 N 个节点"></a>反转链表前 N 个节点</h2><p>这次我们实现一个这样的函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将链表的前 n 个节点反转（n &lt;= 链表长度）</span><span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/6.jpg" alt="img"></p><h3 id="迭代解法-1"><a href="#迭代解法-1" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>迭代解法应该比较好写，在之前实现的 <code>reverseList</code> 基础上稍加修改就可以了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> head    pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> nxt <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre        pre <span class="token operator">=</span> cur        cur <span class="token operator">=</span> nxt        <span class="token keyword">if</span> nxt <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            nxt <span class="token operator">=</span> nxt<span class="token punctuation">.</span><span class="token builtin">next</span>        n <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token comment"># 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点</span>    head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur     <span class="token comment"># 此时的 pre 是反转后的头结点</span>    <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 后驱节点</span>successor <span class="token operator">=</span> <span class="token boolean">None</span><span class="token comment"># 反转以 head 为起点的 n 个节点，返回新的头结点</span><span class="token keyword">def</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> successor    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment"># 记录第 n + 1 个节点</span>        successor <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token keyword">return</span> head    <span class="token comment"># 以 head.next 为起点，需要反转前 n - 1 个节点</span>    last <span class="token operator">=</span> reverseN<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head    <span class="token comment"># 让反转之后的 head 节点和后面的节点连起来</span>    head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> successor    <span class="token keyword">return</span> last <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的区别：</p><p>1、base case 变为 <code>n == 1</code>，反转一个元素，就是它本身，<strong>同时要记录后驱节点</strong>，即要记录第 <code>n + 1</code> 个节点。</p><p>2、刚才我们直接把 <code>head.next</code> 设置为 null，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 <code>n + 1</code> 个节点），反转之后将 <code>head</code> 连接上。</p><p><img src="/2025/05/21/dan-lian-biao-de-hua-shi-fan-zhuan-fang-fa-hui-zong/7.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 反转链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法核心</title>
      <link href="/2025/05/08/hua-dong-chuang-kou-suan-fa-he-xin/"/>
      <url>/2025/05/08/hua-dong-chuang-kou-suan-fa-he-xin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长&#x2F;最短子数组。</p></blockquote><h2 id="滑动窗口框架概览"><a href="#滑动窗口框架概览" class="headerlink" title="滑动窗口框架概览"></a>滑动窗口框架概览</h2><p>如果用暴力解的话，你需要嵌套 for 循环这样穷举所有子数组，时间复杂度是 $O(n^2)$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// nums[i, j] 是一个子数组</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>滑动窗口算法技巧的思路也不难，就是维护一个窗口，不断滑动，然后更新答案，该算法的大致逻辑如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 增大窗口</span>    window<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>window needs shrink<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 缩小窗口</span>        window<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于滑动窗口算法框架写出的代码，时间复杂度是 $O(N)$，比嵌套 <code>for</code> 循环的暴力解法效率高。</p><h2 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h2><p>先来看看力扣第 76 题<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>难度 Hard：</p><hr><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例 1</strong>：</p><p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</p><p><strong>示例 2：</strong></p><p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>解释：整个字符串 s 是最小覆盖子串。</p><p><strong>示例 3:</strong></p><p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p><hr><p>就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p><h3 id="滑动窗口算法的思路是这样："><a href="#滑动窗口算法的思路是这样：" class="headerlink" title="滑动窗口算法的思路是这样："></a>滑动窗口算法的思路是这样：</h3><p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引左闭右开区间 <code>[left, right)</code> 称为一个「窗口」。</p><p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p><p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p><blockquote><p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，就好像一条毛毛虫，一伸一缩，不断向右滑动，这就是「滑动窗口」这个名字的来历</p></blockquote><h3 id="现在开始套模板，只需要思考以下几个问题："><a href="#现在开始套模板，只需要思考以下几个问题：" class="headerlink" title="现在开始套模板，只需要思考以下几个问题："></a>现在开始套模板，只需要思考以下几个问题：</h3><p>1、什么时候应该移动 right 扩大窗口？窗口加入字符时，应该更新哪些数据？</p><p>2、什么时候窗口应该暂停扩大，开始移动 left 缩小窗口？从窗口移出字符时，应该更新哪些数据？</p><p>3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p><p>如果一个字符进入窗口，应该增加 window 计数器；如果一个字符将移出窗口的时候，应该减少 window 计数器；当 valid 满足 need 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p><p><img src="/2025/05/08/hua-dong-chuang-kou-suan-fa-he-xin/1(1).jpg" alt=" "></p><p>下面是完整代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        need<span class="token punctuation">,</span> window <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> t<span class="token punctuation">:</span>            need<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> need<span class="token punctuation">.</span>get<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token number">0</span>        valid <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># valid变量表示窗口中满足 need 条件的字符个数</span>        <span class="token comment"># 记录最小覆盖子串的起始索引及长度</span>        start <span class="token operator">=</span> <span class="token number">0</span>        length <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># c 是将移入窗口的字符</span>            c <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token comment"># 扩大窗口</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 进行窗口内数据的一系列更新</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> need<span class="token punctuation">:</span>                window<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> window<span class="token punctuation">.</span>get<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">if</span> window<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> need<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>                    valid <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 判断左侧窗口是否要收缩</span>            <span class="token keyword">while</span> valid <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>need<span class="token punctuation">)</span><span class="token punctuation">:</span>                 <span class="token comment"># 在这里更新最小覆盖子串</span>                <span class="token keyword">if</span> right <span class="token operator">-</span> left <span class="token operator">&lt;</span> length<span class="token punctuation">:</span>                    start <span class="token operator">=</span> left                    length <span class="token operator">=</span> right <span class="token operator">-</span> left                <span class="token comment"># d 是将移出窗口的字符</span>                d <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                <span class="token comment"># 缩小窗口</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment"># 进行窗口内数据的一系列更新</span>                <span class="token keyword">if</span> d <span class="token keyword">in</span> need<span class="token punctuation">:</span>                    <span class="token keyword">if</span> window<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">==</span> need<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">:</span>                        valid <span class="token operator">-=</span> <span class="token number">1</span>                    window<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 返回最小覆盖子串</span>        <span class="token keyword">return</span> <span class="token string">""</span> <span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span> start <span class="token operator">+</span> length<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2025/05/05/lian-biao-shuang-zhi-zhen/"/>
      <url>/2025/05/05/lian-biao-shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="链表的合并"><a href="#链表的合并" class="headerlink" title="链表的合并"></a>链表的合并</h1><blockquote><p>有些题目虽然不是链表的题目，但其中蕴含了合并有序链表的思想。</p></blockquote><h2 id="264-丑数-II-力扣"><a href="#264-丑数-II-力扣" class="headerlink" title="264. 丑数 II 力扣"></a>264. 丑数 II <a href="https://leetcode.cn/problems/ugly-number-ii/description/">力扣</a></h2><hr><p>给你一个整数 n ，请你找出并返回第 n 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是质因子只包含 2、3 和 5 的正整数。</p><p>示例 1：</p><p>输入：n &#x3D; 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1<br>解释：1 通常被视为丑数。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1690</p><hr><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题很精妙，你看着它好像是道数学题，实际上它却是一个合并多个有序链表的问题，同时用到了筛选素数的思路。</p><p>根据题意，每个丑数都可以由其他较小的丑数通过乘以 2 或 3 或 5 得到。<br>我们把所有丑数想象成一个从小到大排序的链表，就是这个样子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">2</span> <span class="token operator">-></span> <span class="token number">3</span> <span class="token operator">-></span> <span class="token number">4</span> <span class="token operator">-></span> <span class="token number">5</span> <span class="token operator">-></span> <span class="token number">6</span> <span class="token operator">-></span> <span class="token number">8</span> <span class="token operator">-></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数（按照题目的意思，1 算作特殊的丑数，放在开头），这三类丑数就好像三条有序链表，如下：</p><p>能被 2 整除的丑数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">3</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">-></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能被 3 整除的丑数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">3</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">-></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能被 5 整除的丑数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">3</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">5</span> <span class="token operator">-></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们其实就是想把这三条<strong>有序链表</strong>一起并<strong>去重</strong>，合并的结果就是丑数的序列。然后求合并后的这条有序链表中第 n 个元素是什么。所以这里就和合并多个有序链表一样</p><p>具体思路看注释吧</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 可以理解为三个指向有序链表头结点的指针，p2,p3,p5代表的是第几个数的 2 倍、第几个数 3 倍、第几个数 5 倍</span>        p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p5 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token comment"># 可以理解为三个有序链表的头节点的值</span>        product2<span class="token punctuation">,</span> product3<span class="token punctuation">,</span> product5 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token comment"># 可以理解为最终合并的有序链表（结果链表）</span>        ugly <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 可以理解为结果链表上的指针</span>        p <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment"># 开始合并三个有序链表</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            <span class="token comment"># 取三个链表的最小结点</span>            min_val <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>product2<span class="token punctuation">,</span> product3<span class="token punctuation">,</span> product5<span class="token punctuation">)</span>            <span class="token comment"># 接到结果链表上</span>            ugly<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> min_val            p <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment"># 前进对应有序链表上的指针</span>            <span class="token keyword">if</span> min_val <span class="token operator">==</span> product2<span class="token punctuation">:</span>                product2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span>p2<span class="token punctuation">]</span>                p2 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> min_val <span class="token operator">==</span> product3<span class="token punctuation">:</span>                product3 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span>p3<span class="token punctuation">]</span>                p3 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> min_val <span class="token operator">==</span> product5<span class="token punctuation">:</span>                product5 <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span>p5<span class="token punctuation">]</span>                p5 <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment"># 返回第 n 个丑数</span>        <span class="token keyword">return</span> ugly<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="链表运算题"><a href="#链表运算题" class="headerlink" title="链表运算题"></a>链表运算题</h1><blockquote><p>有些题目虽然不是链表的题目，但其中蕴含了合并有序链表的思想。</p></blockquote><h2 id="445-两数相加-II-力扣"><a href="#445-两数相加-II-力扣" class="headerlink" title="445. 两数相加 II 力扣"></a>445. 两数相加 II <a href="https://leetcode.cn/problems/add-two-numbers-ii/description/">力扣</a></h2><hr><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>示例1：</p><p><img src="/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88%5C1626420025-fZfzMX-image.png"></p><p>输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,8,0,7]<br>示例2：</p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[8,0,7]<br>示例3：</p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p><p>提示：</p><p>链表的长度范围为 [1, 100]<br>0 &lt;&#x3D; node.val &lt;&#x3D; 9<br>输入数据保证链表代表的数字无前导 0</p><p>进阶：如果输入链表不能翻转该如何解决？</p><hr><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>这道题是 两数相加 的进阶问题，我们模拟加法运算当然是从最低位开始加，这样才能正确的处理进位。但现在单链表的开头是最高位，那么最直接的想法就是先 <strong>翻转链表</strong>，这样就没什么难度。</p><p>不过本题也说了，如果不让你反转链表怎么办？其实也好办，我们可以利用栈这种先进后出的数据结构，把链表节点从头到尾放进栈中，再从栈拿出来就是从尾到头的顺序，相当于是反转链表的效果，然后再进行加法运算即可。</p><p>还有一个需要注意的是，计算结果的高位也应该放在结果链表的左侧，也就是插入到 dummy 节点的后面。具体看代码吧。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token comment"># 把链表元素转入栈中</span>        stk1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> l1<span class="token punctuation">:</span>            stk1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span><span class="token builtin">next</span>        stk2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> l2<span class="token punctuation">:</span>            stk2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token comment"># 接下来基本上是复用我在第 2 题的代码逻辑</span>        <span class="token comment"># 注意新节点要直接插入到 dummy 后面</span>        <span class="token comment"># 虚拟头结点（构建新链表时的常用技巧）</span>        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 记录进位</span>        carry <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 开始执行加法，两条链表走完且没有进位时才能结束循环</span>        <span class="token keyword">while</span> stk1 <span class="token keyword">or</span> stk2 <span class="token keyword">or</span> carry <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 先加上上次的进位</span>            val <span class="token operator">=</span> carry            <span class="token keyword">if</span> stk1<span class="token punctuation">:</span>                val <span class="token operator">+=</span> stk1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> stk2<span class="token punctuation">:</span>                val <span class="token operator">+=</span> stk2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 处理进位情况</span>            carry <span class="token operator">=</span> val <span class="token operator">//</span> <span class="token number">10</span>            val <span class="token operator">=</span> val <span class="token operator">%</span> <span class="token number">10</span>            <span class="token comment"># 构建新节点，直接接在 dummy 后面</span>            newNode <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            newNode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span>            dummy<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> newNode        <span class="token comment"># 返回结果链表的头结点（去除虚拟头结点）</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效寻找素数</title>
      <link href="/2025/05/05/ru-he-gao-xiao-xun-zhao-su-shu/"/>
      <url>/2025/05/05/ru-he-gao-xiao-xun-zhao-su-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>素数的定义看起来很简单，如果一个数如果只能被 <code>1</code> 和它本身整除，那么这个数就是素数</p></blockquote><ul><li>比如力扣第 204 题<a href="https://leetcode.cn/problems/count-primes/">计数质数</a></li></ul><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><p>我们可以从 2 开始，判断每个数是否是素数，如果是素数，我们就把count加1，如果不是素数，我们就跳过它。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isPrime<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> count<span class="token comment"># 判断整数 n 是否是素数</span><span class="token keyword">def</span> <span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 有其他整除因子</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这样写的话时间复杂度 $O(n^2)$，<strong>问题很大</strong>。首先你用 <code>isPrime</code> 函数来辅助的思路就不够高效；而且就算你要用 <code>isPrime</code> 函数，这样写算法也是<strong>存在计算冗余</strong>的。</p></blockquote><p><strong>优化思路</strong></p><p>先来说下如果你要判断一个数是不是素数，应该如何写算法。只需稍微修改一下上面的 isPrime 代码中的 for 循环条件：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">boolean isPrime<span class="token punctuation">(</span><span class="token builtin">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token builtin">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>换句话说，i 不需要遍历到 n，而只需要到 sqrt(n) 即可。为什么呢，我们举个例子，假设 n &#x3D; 12。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">2</span> × <span class="token number">6</span><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">3</span> × <span class="token number">4</span><span class="token number">12</span> <span class="token operator">=</span> sqrt<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> × sqrt<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">4</span> × <span class="token number">3</span><span class="token number">12</span> <span class="token operator">=</span> <span class="token number">6</span> × <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，后两个乘积就是前面两个反过来，反转临界点就在 <code>sqrt(n)</code>。</p><p>换句话说，如果在 <code>[2,sqrt(n)]</code> 这个区间之内没有发现可整除因子，就可以直接断定 n 是素数了，因为在区间 <code>[sqrt(n),n]</code> 也一定不会发现可整除因子。</p><p>现在，<code>isPrime</code> 函数的时间复杂度降为$O(sqrt(N))$，但是我们实现 <code>countPrimes</code> 函数其实并不需要这个函数，以上只是希望读者明白 <code>sqrt(n)</code> 的含义，因为等会还会用到。</p><h2 id="高效实现-countPrimes"><a href="#高效实现-countPrimes" class="headerlink" title="高效实现 countPrimes"></a>高效实现 countPrimes</h2><p>接下来介绍的方法叫做「素数筛选法」，这个方法是古希腊一位名叫埃拉托色尼的大佬发明</p><p>素数筛选法的核心思路是和上面的常规思路反着来：</p><p>首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 &#x3D; 4, 3 × 2 &#x3D; 6, 4 × 2 &#x3D; 8… 都不可能是素数了。</p><p>然后我们发现 3 也是素数，那么 3 × 2 &#x3D; 6, 3 × 3 &#x3D; 9, 3 × 4 &#x3D; 12… 也都不可能是素数了。</p><p>Wikipedia 的这个 GIF 很形象：</p><p><img src="/2025/05/05/ru-he-gao-xiao-xun-zhao-su-shu/1.gif" alt="素数筛选法"></p><p>看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        isPrime <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                 count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。</p><p>首先，回想本文开头介绍的 <code>isPrime</code> 素数判定函数，由于因子的对称性，其中的 <code>for</code> 循环只需要遍历 <code>[2,sqrt(n)]</code> 就够了。这里也是类似的，我们外层的 <code>for</code> 循环也只需要遍历到 <code>sqrt(n)</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>isPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span>     isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样可以把 i 的整数倍都标记为 false，但是仍然存在计算冗余。</p><p>比如 n &#x3D; 25，i &#x3D; 5 时算法会标记 5 × 2 &#x3D; 10，5 × 3 &#x3D; 15 等等数字，但是这两个数字已经被 i &#x3D; 2 和 i &#x3D; 3 的 2 × 5 和 3 × 5 标记了。</p><p>我们可以稍微优化一下，让 j 从 i * i 开始遍历，而不是从 2 * i 开始：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span>     isPrime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：</p><pre><code class="language-python">class Solution:    def countPrimes(self, n: int) -&gt; int:        isPrime = [True] * n        for i in range(2, int(n ** 0.5) + 1):            if isPrime[i]:                for j in range(i * i, n, i):                    isPrime[j] = False        count = 0        for i in range(2, n):            if isPrime[i]:                 count += 1        return count</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="/2025/05/02/tong-pai-xu/"/>
      <url>/2025/05/02/tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>桶排序算法的核心思想分三步：</p><p>1、将待排序数组中的元素使用映射函数分配到若干个「桶」中。</p><p>2、对每个桶中的元素进行排序。</p><p>3、最后将这些排好序的桶进行合并，得到排序结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/2025/05/02/ji-shu-pai-xu/"/>
      <url>/2025/05/02/ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计数排序的原理比较简单：统计每种元素出现的次数，进而推算出每个元素在排序后数组中的索引位置，最终完成排序。</p></blockquote><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>比方说，输入一个 <code>nums</code> 数组，我统计出其中有 <code>2</code> 个元素 <code>1</code>，<code>1</code> 个元素 <code>3</code>，<code>3</code> 个元素 <code>6</code>，那么只要我在数组中依次填入 <code>2</code> 个 <code>1</code>，<code>1</code> 个 <code>3</code>，<code>3</code> 个 <code>6</code>，就能得到排序结果 <code>[1, 1, 3, 6, 6, 6]</code>。</p><p>看个题目就明白了 <a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></p><hr><blockquote><ol start="75"><li>颜色分类 | 力扣 | LeetCode |  🟠<br>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li></ol><p>我们使用整数 0、 1 和 2 分别表示<font color="red">红色</font>、白色和<font color="blue">蓝色</font>。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><p>输入：nums &#x3D; [2,0,2,1,1,0]</p><p>输出：[0,0,1,1,2,2]</p><p><strong>示例 2：</strong></p><p>输入：nums &#x3D; [2,0,1]</p><p>输出：[0,1,2]</p><p><strong>提示：</strong></p><p>n &#x3D;&#x3D; nums.length</p><p>1 &lt;&#x3D; n &lt;&#x3D; 300</p><p>nums[i] 为 0、1 或 2</p><p><strong>进阶：</strong></p><p>你能想出一个仅使用常数空间的一趟扫描算法吗？</p></blockquote><hr><p>我们用计数排序的思路来解决这个问题，说白了就是让你对数组排序，且这个数组里只有 0、1、2 三种元素。</p><p>我们可以创建一个大小为 <code>3</code> 的 <code>count</code> 数组，<code>count[0]</code>, <code>count[1]</code>, <code>count[2]</code> 分别表示数组中 <code>0</code>、<code>1</code>、<code>2</code> 出现的次数。然后我们按照 <code>count</code> 数组的统计结果，依次填充原数组即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 统计 0, 1, 2 出现的次数</span>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>        <span class="token keyword">for</span> element <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>element<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 按照 count 数组的统计结果，依次填充原数组</span>        index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>count<span class="token punctuation">[</span>element<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element                index <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，我们就完成了颜色分类问题的排序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2025/05/02/dui-pai-xu/"/>
      <url>/2025/05/02/dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>堆排序是从 <em><strong>二叉堆结构</strong></em> 衍生出来的排序算法，复杂度为 $O(NlogN)$。堆排序主要分两步，第一步是在待排序数组上原地创建二叉堆（Heapify），然后进行原地排序（Sort）。</p></blockquote><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><blockquote><p>堆排序的两个关键步骤：</p><p>1、原地建堆（Heapify）：直接把待排序数组原地变成一个二叉堆。</p><p>2、排序（Sort）：将元素不断地从堆中取出，最终得到有序的结果。</p></blockquote><p>下面这些函数就是从 <strong>二叉堆实现优先级队列</strong> 中的优先级队列实现里抠出来的，把数组作为函数参数传入，其他的逻辑完全一样：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">min_heap_swim</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 小顶堆的上浮操作，时间复杂度是树高 O(logN)</span>    <span class="token keyword">while</span> node <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> heap<span class="token punctuation">[</span>parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>        node <span class="token operator">=</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">min_heap_sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 小顶堆的下沉操作，时间复杂度是树高 O(logN)</span>    <span class="token keyword">while</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">or</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>        <span class="token comment"># 比较自己和左右子节点，看看谁最小</span>        min_index <span class="token operator">=</span> node        <span class="token keyword">if</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>left<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            min_index <span class="token operator">=</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>right<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            min_index <span class="token operator">=</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> min_index <span class="token operator">==</span> node<span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token comment"># 如果左右子节点中有比自己小的，就交换</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> min_index<span class="token punctuation">)</span>        node <span class="token operator">=</span> min_index<span class="token keyword">def</span> <span class="token function">max_heap_swim</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 大顶堆的上浮操作</span>    <span class="token keyword">while</span> node <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> heap<span class="token punctuation">[</span>parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>        node <span class="token operator">=</span> parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">max_heap_sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 大顶堆的下沉操作</span>    <span class="token keyword">while</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">or</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>        <span class="token comment"># 小顶堆和大顶堆的唯一区别就在这里，比较逻辑相反</span>        <span class="token comment"># 比较自己和左右子节点，看看谁最大</span>        max_index <span class="token operator">=</span> node        <span class="token keyword">if</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>left<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            max_index <span class="token operator">=</span> left<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&lt;</span> size <span class="token keyword">and</span> heap<span class="token punctuation">[</span>right<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            max_index <span class="token operator">=</span> right<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">if</span> max_index <span class="token operator">==</span> node<span class="token punctuation">:</span>            <span class="token keyword">break</span>        swap<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> node<span class="token punctuation">,</span> max_index<span class="token punctuation">)</span>        node <span class="token operator">=</span> max_index<span class="token keyword">def</span> <span class="token function">parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 父节点的索引</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>node <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">left</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 左子节点的索引</span>    <span class="token keyword">return</span> node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">def</span> <span class="token function">right</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 右子节点的索引</span>    <span class="token keyword">return</span> node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 交换数组中两个元素的位置</span>    heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单直接的堆排序实现"><a href="#简单直接的堆排序实现" class="headerlink" title="简单直接的堆排序实现"></a>简单直接的堆排序实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 第一步，原地建堆，注意这里创建的是大顶堆</span>    <span class="token comment"># 只要从左往右对每个元素调用 swim 方法，就可以原地建堆</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        max_heap_swim<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token comment"># 第二步，排序</span>    <span class="token comment"># 现在整个数组已经是一个大顶了，直接模拟删除堆顶元素的过程即可</span>    heap_size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">while</span> heap_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token comment"># 从堆顶删除元素，放到堆的后面</span>        swap<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heap_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        heap_size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 恢复堆的性质</span>        max_heap_sink<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heap_size<span class="token punctuation">)</span>        <span class="token comment"># 现在 nums[0..heap_size) 是一个大顶堆，nums[heap_size..) 是有序元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面一个关键点是要用大顶堆来完成 <code>nums</code> 从小到大的排序，因为从堆顶删除的元素是从后往前填到 <code>nums</code> 数组中的，最终 <code>nums</code> 中的元素是从小到大排序的。</p><p>如果你用小顶堆的话，最终 <code>nums</code> 中的元素是从大到小排序的，还需要再翻转一下数组，没有大顶堆的效率高。</p><h2 id="堆排序的复杂度分析"><a href="#堆排序的复杂度分析" class="headerlink" title="堆排序的复杂度分析"></a>堆排序的复杂度分析</h2><p>我们来分析一下上述代码的时间复杂度，假设 <code>nums</code> 的元素个数为 <code>N</code>：</p><ul><li>第一步建堆的过程中，<code>swim</code> 方法的时间复杂度是<br>$O(logN)$，算法对每个元素调用一次 <code>swim</code> 方法，所以总时间复杂度是 $O(NlogN)$。</li><li>第二步排序的过程中，每次 <code>sink</code> 方法的时间复杂度是 $O(logN)$，算法对每个元素调用一次 <code>sink</code> 方法，所以总时间复杂度是 $O(NlogN)$。</li></ul><p><strong>综上，整个堆排序的时间复杂度是 $2NlogN$，用 Big O 表示就是 $O(NlogN)$</strong>。与 快速排序、归并排序 是一个级别的排序算法。</p><h2 id="堆排序的稳定性"><a href="#堆排序的稳定性" class="headerlink" title="堆排序的稳定性"></a>堆排序的稳定性</h2><p>堆排序是一种不稳定的排序算法，原因在于它在排序过程中交换元素时，可能会改变相同元素的相对顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2025/05/02/gui-bing-pai-xu/"/>
      <url>/2025/05/02/gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>归并排序的核心思路需要结合<em><strong>二叉树的后序遍历</strong></em> 来理解：先利用递归把左右两半子数组排好序，然后在二叉树的后序位置合并两个有序数组。</p></blockquote><h2 id="归并排序核心思路"><a href="#归并排序核心思路" class="headerlink" title="归并排序核心思路"></a>归并排序核心思路</h2><p>前文快速排序的思路是，先把一个元素放到正确的位置（排好序），然后将这个元素左右两边剩下的元素利用递归分别排好序，最终整个数组就排好序了。代码框架如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># ****** 前序位置 ******</span>    <span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span>    <span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>    p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>    <span class="token comment"># 去左右子数组进行切分</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序的思路是，把数组切成两半，先把这两半子数组分别排好序，然后再合并这两个有序数组，整个数组就排好序了。代码框架如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：排序 nums[lo..hi]</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>        <span class="token keyword">return</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo <span class="token operator">+</span> hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token comment"># 利用定义，排序 nums[lo..mid]</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>    <span class="token comment"># 利用定义，排序 nums[mid+1..hi]</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>    <span class="token comment"># ****** 后序位置 ******</span>    <span class="token comment"># 此时两部分子数组已经被排好序</span>    <span class="token comment"># 合并两个有序数组，使 nums[lo..hi] 有序</span>    merge<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>归并排序的时间复杂度是 $O(nlogn)$，其中 $n$ 是数组的长度。</p><p><img src="/2025/05/02/gui-bing-pai-xu/1.jpeg"></p><p>每向下一层，每个节点的数组元素就减半，但是每一层总的元素数量就是数组的长度 $O(n)$。</p><p>这棵二叉树是平衡二叉树，即树高是$O(logn)$，所以总的时间复杂度是 $O(nlogn)$，即树高乘以每层的复杂度。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>归并排序的空间复杂度是 $O(n)$，其中 $n$ 是数组的长度。</p><h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>归并排序是一种稳定的排序算法，归并排序的稳定性取决于 merge 函数的实现</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2025/05/02/kuai-su-pai-xu/"/>
      <url>/2025/05/02/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>快速排序的核心思路需要结合<em><strong>二叉树的前序遍历</strong></em> 来理解：在二叉树遍历的前序位置将一个元素排好位置，然后递归地将剩下的元素排好位置。</p></blockquote><h2 id="快速排序核心思路"><a href="#快速排序核心思路" class="headerlink" title="快速排序核心思路"></a>快速排序核心思路</h2><p>快速排序的基本思路是这样的：</p><p>1、在 <code>nums</code> 数组中任意选择一个元素作为切分元素 <code>pivot</code>（一般选择第一个元素）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">^</span>pivot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、对数组中的元素进行若干交换操作，将小于 <code>pivot</code> 的元素放到 <code>pivot</code> 的左边，大于 <code>pivot</code> 的元素放到 <code>pivot</code> 的右边（换句话说，其实就是将 <code>pivot</code> 这一个元素排好序）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>          <span class="token operator">^</span>        pivot    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、递归地对 <code>pivot</code> 左边和右边的子数组进行快速排序。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">^</span>         <span class="token operator">^</span>   <span class="token operator">^</span>pivot1          pivot2 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>        <span class="token operator">^</span>   <span class="token operator">^</span>            <span class="token operator">^</span>    pivot1             pivot2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、递归地重复上述操作，直到所有元素都放到正确的位置：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h2><ul><li>代码框架  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>    <span class="token keyword">return</span><span class="token comment"># ****** 前序位置 ******</span><span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span><span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token comment"># 去左右子数组进行切分</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>具体代码  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># ****** 前序位置 ******</span>    <span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span>    <span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>    p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>    <span class="token comment"># 去左右子数组进行切分</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>    pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>    left <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token number">1</span>    right <span class="token operator">=</span> hi    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right <span class="token keyword">and</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right <span class="token keyword">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> left <span class="token operator">></span> right<span class="token punctuation">:</span>            <span class="token keyword">break</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>    <span class="token keyword">return</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>快速排序的平均时间复杂度为$O(n\log n)$，最坏情况时间复杂度为$O(n^2)$。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>快速排序不需要额外的辅助空间，是原地排序算法。</p><p>递归遍历二叉树时，递归函数的堆栈深度为树的高度，所以空间复杂度是$O(n\log n)$</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>快速排序是不稳定排序算法，因为在 <code>partition</code> 函数中，不会考虑相同元素的相对位置，所以相同元素的相对位置可能会发生变化。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2025/04/28/xi-er-pai-xu/"/>
      <url>/2025/04/28/xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>希尔排序是基于插入排序 的简单改进，通过预处理增加数组的局部有序性，突破了插入排序的$O(n^2)$时间复杂度。</p></blockquote><h2 id="h有序数组"><a href="#h有序数组" class="headerlink" title="h有序数组"></a><code>h</code>有序数组</h2><p>一个数组是<code>h</code>有序的，是指这个数组中任意间隔为 <code>h</code>（或者说间隔元素的个数为 <code>h-1</code>）的元素都是有序的。</p><p>这个概念用文字不好描述清楚，直接看个例子吧。比方说 <code>h=3 </code>时，一个 <code>3</code> 有序数组是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">nums<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span>    <span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span>       <span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">^</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">9</span>    <span class="token number">2</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">12</span>        <span class="token number">4</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">7</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，数组中任意间隔为 <code>3</code>的元素都是有序的。</p><p>另外，按照这个定义，当一个数组完成排序的时候，其实就是 <code>1</code> 有序数组。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序要发表看法了：</p><p>你插入排序的问题是，上来就想着一步到位，直接把乱序数组变成 <code>1</code> 有序数组。而我希尔排序不着急，比方说，我先把乱序数组变成一个 <code>16</code> 有序数组，然后再变成 <code>8</code> 有序数组，<code>4 </code>有序数组，<code>2</code> 有序数组，最后变成 <code>1</code> 有序数组，完成排序。</p><p>这个<code>1, 2, 4, 8, 16...</code>的序列称之为「<strong>递增函数</strong>」，我上面举的例子的递增函数就是 $2^(k-1)$</p><p>那么如何把一个数组变成 h 有序数组呢？基于插入排序的代码改动几个地方就行了，直接看希尔排序的代码吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 希尔排序，对 h 有序数组进行插入排序</span><span class="token comment"># 逐渐缩小 h，最后 h=1 时，完成整个数组的排序</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># 我们使用的生成函数是 2^(k-1)</span>    <span class="token comment"># 即 h = 1, 2, 4, 8, 16...</span>    h <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> h <span class="token operator">&lt;</span> n <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">:</span>        h <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> h    <span class="token comment"># 改动一，把插入排序的主要逻辑套在 h 的 while 循环中</span>    <span class="token keyword">while</span> h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment"># 改动二，sorted_index 初始化为 h，而不是 1</span>        sorted_index <span class="token operator">=</span> h        <span class="token keyword">while</span> sorted_index <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            <span class="token comment"># 改动三，把比较和交换元素的步长设置为 h，而不是相邻元素</span>            i <span class="token operator">=</span> sorted_index            <span class="token keyword">while</span> i <span class="token operator">>=</span> h<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token comment"># swap(nums[i], nums[i - h])</span>                    tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span> <span class="token operator">=</span> tmp                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                i <span class="token operator">-=</span> h            sorted_index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 按照递增函数的规则，缩小 h</span>        h <span class="token operator">//=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="递增函数的选择是关键"><a href="#递增函数的选择是关键" class="headerlink" title="递增函数的选择是关键"></a>递增函数的选择是关键</h3></blockquote><p>希尔排序的性能和递增函数的选择有很大关系，上面的代码中我们使用的递增函数是 $h &#x3D; 2^k-1$。因为这是最简单的，但这并不最优的选择。</p><p>比方说《算法4》中给的递增函数是 $h &#x3D; (3^k - 1) &#x2F; 2$，即<code>1，4，13，40，121 ...</code>这个递增函数的选择是比较合理的。代码如下，主要修改 <code>h</code> 的初始化和更新逻辑：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 把生成函数换成 (3^k - 1) / 2</span><span class="token comment"># 即 h = 1, 4, 13, 40, 121, 364...</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    h <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> h <span class="token operator">&lt;</span> n <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">:</span>        h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">while</span> h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>        sorted_index <span class="token operator">=</span> h        <span class="token keyword">while</span> sorted_index <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            i <span class="token operator">=</span> sorted_index            <span class="token keyword">while</span> i <span class="token operator">>=</span> h<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i <span class="token operator">-</span> h<span class="token punctuation">]</span> <span class="token operator">=</span> tmp                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                i <span class="token operator">-=</span> h            sorted_index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># 按照递增函数的规则，缩小 h</span>        h <span class="token operator">//=</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h2><p>希尔排序是不稳定排序。</p><p>这个比较容易理解吧，当 <code>h</code> 大于 <code>1</code> 时进行的排序操作，就可能打乱相同元素的相对位置了。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>希尔排序的空间复杂度是 $O(1)$，是原地排序。</p><p>希尔排序的时间复杂度很难分析，主要取决于递增函数的选择，且涉及较多的数学知识，这里就不展开了，不过一个重要结论是：<strong>希尔排序的时间复杂度是小于 $O(n^2)$ 的</strong>。</p><blockquote><p>绕了一大圈，终于能够成功通过第 912 题「<a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a>」了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2025/04/27/cha-ru-pai-xu/"/>
      <url>/2025/04/27/cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>插入排序是基于选择排序的一种优化，将 <code>nums[sortedIndex]</code> 插入到左侧的有序数组中。对于有序度较高的数组，插入排序的效率比较高。</p></blockquote><ul><li>练习题目: 力扣第 912 题 <a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a>，先不纠结时间复杂度。</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>选择排序的思路是：在 <code>nums[sortedIndex..]</code> 中找到最小值，然后将其插入到 <code>nums[sortedIndex]</code> 的位置。</p><p>那么我们能不能反过来想，在 <code>nums[0..sortedIndex-1]</code> 这个部分有序的数组中，找到 <code>nums[sortedIndex]</code> 应该插入的位置，然后进行插入呢？</p><p>我想利用数组的有序性：既然 <code>nums[0..sortedIndex-1]</code> 这部分是已经排好序的，那么我就可以用二分搜索来寻找 <code>nums[sortedIndex]</code> 应该插入的位置。  </p><p>用二分搜索好像是多此一举的。因为就算我用二分搜索找到了 <code>nums[sortedIndex]</code> 应该插入的位置，我还是需要搬移元素进行插入，那还不如一边遍历一遍交换元素的方法简单高效呢。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>从 <code>nums[1..n]</code> 开始遍历，对于 <code>nums[sortedIndex]</code>，在 <code>nums[0..sortedIndex-1]</code> 中找到 <code>nums[sortedIndex]</code> 应该插入的位置 <code>j</code>，并一步步左移 <code>nums[sortedIndex]</code> 到 <code>nums[j]</code>的位置</li><li>重复步骤 1，直到 <code>nums[sortedIndex]</code> 到达 <code>nums[n]</code>。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对选择排序进一步优化，向左侧有序数组中插入元素</span><span class="token comment"># 这个算法有另一个名字，叫做插入排序</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># 维护 [0, sorted_index) 是有序数组</span>    sorted_index <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sorted_index <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 将 nums[sorted_index] 插入到有序数组 [0, sorted_index) 中</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sorted_index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># swap(nums[i], nums[i - 1])</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        sorted_index <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><font color=Blue >这个算法的名字叫做插入排序，它的执行过程就像是打扑克牌时，将新抓到的牌插入到手中已经排好序的牌中。</font>        </p></blockquote><h2 id="初始有序度越高，效率越高"><a href="#初始有序度越高，效率越高" class="headerlink" title="初始有序度越高，效率越高"></a>初始有序度越高，效率越高</h2><p>插入排序的空间复杂度是$O(1)$，是原地排序算法。时间复杂度是$O(n^2)$ ，具体的操作次数和选择排序类似，是一个等差数列求和，大约是 $ n^2&#x2F;2 $次。</p><p>如果输入数组已经有序，或者仅有个别元素逆序，那么插入排序的内层 for 循环几乎不需要执行元素交换，所以时间复杂度接近$O(n)$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2025/04/27/mou-pao-pai-xu/"/>
      <url>/2025/04/27/mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>冒泡算法是对选择排序的一种优化，通过交换 nums[sortedIndex] 右侧的逆序对完成排序，是一种<strong>稳定</strong>排序算法。</p></blockquote><ul><li>练习题目: 力扣第 912 题 <a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a>，先不纠结时间复杂度。</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>选择排序失去稳定性的原因，即每次都要交换最小元素<code>nums[minIndex]</code>和当前元素<code>nums[sortedIndex]</code>，这样可能会改变相同元素的相对位置。  </p><p>所以优化的方向就在这里，你不要图省事儿直接把 <code>nums[sortedIndex]</code> 交换到 <code>nums[minIndex]</code>，而是模仿<br>在数组中部插入元素的操作，将 <code>nums[sortedIndex..minIndex]</code> 的元素整体向后移动一位，把 <code>nums[sortedIndex + 1]</code> 的位置空出来让 <code>nums[sortedIndex]</code> 这个元素去那里待着。</p><p>这就是冒泡排序实际做的事。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。 </li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 </li><li>针对所有的元素重复以上的步骤，除了最后一个。 </li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对选择排序进行第一波优化，获得了稳定性</span><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sortedIndex <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 在未排序部分中找到最小值 nums[minIndex]</span>        minIndex <span class="token operator">=</span> sortedIndex        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sortedIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>                minIndex <span class="token operator">=</span> i        <span class="token comment"># 优化：将 nums[minIndex] 插入到 nums[sortedIndex] 的位置</span>        <span class="token comment"># 将 nums[sortedIndex..minIndex] 的元素整体向后移动一位</span>        minVal <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span>        <span class="token comment"># 数组搬移数据的操作</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>minIndex<span class="token punctuation">,</span> sortedIndex<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> minVal        sortedIndex <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码上优化一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sortedIndex <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 通过一次循环,一边找最小值一边换位，可以将一个元素换到正确的位置</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>sortedIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># Output: n-1,n-2,..., 0 </span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                sortedIndex <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>稳定性：稳定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2025/04/27/xuan-ze-pai-xu/"/>
      <url>/2025/04/27/xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>选择排序是最简单朴素的排序算法，但是时间复杂度较高，且不是稳定排序。其他基础排序算法都是基于选择排序的优化。</p></blockquote><ul><li>练习题目: 力扣第 912 题 <a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a>，先不纠结时间复杂度</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>现在就是给你输入一个数组，让你写个排序算法把所有元素从小到大排序，你来说，怎么写？  </p><p>我第一次思考这个问题时，想到的最直接的方法是这样的：</p><p>先遍历一遍数组，找到数组中的最小值，然后把它和数组的第一个元素交换位置；接着再遍历一遍数组，找到第二小的元素，和数组的第二个元素交换位置；以此类推，直到整个数组有序。</p><p>这个算法有一个被大家熟知的名字，叫做「选择排序」，即每次都去遍历选择最小的元素。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。      </li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到<strong>已排序序列</strong>的末尾。      </li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token comment"># sortedIndex 是一个分割线</span>    <span class="token comment"># 索引 &lt; sortedIndex 的元素都是已排序的</span>    <span class="token comment"># 索引 >= sortedIndex 的元素都是未排序的</span>    <span class="token comment"># 初始化为 0，表示整个数组都是未排序的</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> sortedIndex <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token comment"># 找到未排序部分 [sortedIndex, n) 中的最小值</span>        minIndex <span class="token operator">=</span> sortedIndex        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sortedIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>                minIndex <span class="token operator">=</span> i        <span class="token comment"># 交换最小值和 sortedIndex 处的元素</span>        nums<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span>        <span class="token comment"># sortedIndex 后移一位</span>        sortedIndex <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>选择排序的最好时间复杂度是 $O(n^2)$，最坏时间复杂度是 $O(n^2)$，平均时间复杂度是 $O(n^2)$。  </p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>选择排序的空间复杂度是$O(1)$，因为只需要一个辅助变量来记录最小（大）元素的索引。  </p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>选择排序不是稳定排序算法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法的关键指标</title>
      <link href="/2025/04/27/pai-xu-suan-fa-de-guan-jian-zhi-biao/"/>
      <url>/2025/04/27/pai-xu-suan-fa-de-guan-jian-zhi-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>首先一个指标肯定是时间复杂度和空间复杂度。</p><p>正如 时空复杂度入门 中所说，对于任意一个算法，其时间复杂度和空间复杂度都是越小越好的。</p><h3 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h3><p>稳定性是排序算法的一个重要性质，我们可以简单总结为：</p><p><strong>对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。</strong></p><p>如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定排序就会有一定的优势。</p><p>比如说现在你有若干订单数据，已经按照交易日期排好序了，现在你想对用户 ID 再进行排序，<br>如果你用稳定排序算法，那么排序完成后，相同用户 ID 的订单依然会按照交易日期有序排列</p><h3 id="是否原地排序"><a href="#是否原地排序" class="headerlink" title="是否原地排序"></a>是否原地排序</h3><p>原地排序就是指排序过程中不需要额外的辅助空间，只需要常数级别的额外空间，直接操作原数组进行排序。</p><p>注意，关键是是否需要额外的空间，而不是是否返回一个新的数组。具体来说就是类似这样的区别：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 非原地排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 排序过程中需要额外的辅助数组，消耗 O(N) 的空间</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 对 nums 进行排序</span>    <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">// 原地排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 直接操作 nums，不需要额外的辅助数组，消耗 O(1) 的空间</span>    <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难想到，对于大数据量的排序，原地排序算法是比较有优势的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo图片加载问题</title>
      <link href="/2025/04/27/hexo-tu-pian-jia-zai-wen-ti/"/>
      <url>/2025/04/27/hexo-tu-pian-jia-zai-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通用解决方案（推荐）"><a href="#一、通用解决方案（推荐）" class="headerlink" title="一、通用解决方案（推荐）"></a>一、通用解决方案（推荐）</h3><h4 id="1-启用资源文件夹并配置插件"><a href="#1-启用资源文件夹并配置插件" class="headerlink" title="1. 启用资源文件夹并配置插件"></a>1. <strong>启用资源文件夹并配置插件</strong></h4><ul><li><p>步骤1：在_config.yml中配置</p>  <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>步骤 2：安装适配新版 Hexo 的插件（二选一）</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方案一：改进版插件（兼容性更强）</span><span class="token function">npm</span> uninstall hexo-asset-image <span class="token parameter variable">--save</span><span class="token function">npm</span> <span class="token function">install</span> hexo-asset-img <span class="token parameter variable">--save</span><span class="token comment"># 方案二：官方推荐语法（无需插件）</span><span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-marked <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在_config.yml中补充配置：</p>  <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">marked</span><span class="token punctuation">:</span>  <span class="token key atrule">prependRoot</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">postAsset</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-Typora-与-Markdown-协作优化"><a href="#2-Typora-与-Markdown-协作优化" class="headerlink" title="2. Typora 与 Markdown 协作优化"></a>2. <strong>Typora 与 Markdown 协作优化</strong></h4><ul><li><p>Typora设置：<code> 偏好设置 → 图像 → 复制到 ./$&#123;filename&#125;</code>，实现图片自动存入同名文件夹</p></li><li><p>Markdown 语法：</p> <pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token comment">&lt;!-- 插件方案 --></span>&#123;% asset_img image.jpg 图片描述 %&#125;<span class="token comment">&lt;!-- 无插件方案（需 hexo-renderer-marked） --></span><span class="token url"><span class="token operator">!</span>[<span class="token content">图片描述</span>](<span class="token url">image.jpg</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-验证生成路径"><a href="#3-验证生成路径" class="headerlink" title="3. 验证生成路径"></a>3. <strong>验证生成路径</strong></h4><ul><li>执行<pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo g --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>检查 <code>public/年份/月份/日期/文章名/</code> 目录下是否包含图片文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程线程协程</title>
      <link href="/2025/04/17/jin-cheng-xian-cheng/"/>
      <url>/2025/04/17/jin-cheng-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><p>  进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p><p><img src="/2025/04/17/jin-cheng-xian-cheng/6470aeedc4699483fdcae88b3edb7a36.png"></p><p><img src="/2025/04/17/jin-cheng-xian-cheng/29c6aba84af60c91c99d25eb92b26ac7.jpeg"></p><p><strong>【进程间通信（IPC）】：</strong></p><p>管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存（Shared Memory）；套接字（Socket）。</p><h1 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h1><p>  线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</p><h1 id="三、进程和线程的区别与联系"><a href="#三、进程和线程的区别与联系" class="headerlink" title="三、进程和线程的区别与联系"></a>三、进程和线程的区别与联系</h1><h3 id="【区别】："><a href="#【区别】：" class="headerlink" title="【区别】："></a>【区别】：</h3><p><strong>调度</strong>：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p><strong>并发性</strong>：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><p><strong>拥有资源</strong>：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p><p><strong>系统开销</strong>：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><h3 id="【联系】："><a href="#【联系】：" class="headerlink" title="【联系】："></a>【联系】：</h3><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><h1 id="四、一个形象的例子解释进程和线程的区别"><a href="#四、一个形象的例子解释进程和线程的区别" class="headerlink" title="四、一个形象的例子解释进程和线程的区别"></a>四、一个形象的例子解释进程和线程的区别</h1><p>进程就好比一个车间，线程就是车间的工人</p><h1 id="五、协程"><a href="#五、协程" class="headerlink" title="五、协程"></a>五、协程</h1><p>  协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><img src="/2025/04/17/jin-cheng-xian-cheng/b7a5938afc75f67d3f1554fd98875f75-1744896323880-35.png"></p><p>  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>  协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p><strong>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</strong></p><p><strong>极高的执行效率</strong>：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p><strong>不需要多线程的锁机制</strong>：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github配置SSH-Key保姆教程</title>
      <link href="/2025/04/15/github-pei-zhi-ssh-key/"/>
      <url>/2025/04/15/github-pei-zhi-ssh-key/</url>
      
        <content type="html"><![CDATA[<h1 id="github配置SSH-Key保姆级教程"><a href="#github配置SSH-Key保姆级教程" class="headerlink" title="github配置SSH-Key保姆级教程"></a>github配置SSH-Key保姆级教程</h1><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><h3 id="第1步：查看-或者-生成一个SSH-Key"><a href="#第1步：查看-或者-生成一个SSH-Key" class="headerlink" title="第1步：查看 或者 生成一个SSH-Key"></a>第1步：查看 或者 生成一个<a href="https://zhida.zhihu.com/search?content_id=241042157&content_type=Article&match_order=1&q=SSH-Key&zhida_source=entity">SSH-Key</a></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 新环境大概率会报错 ，因为这个目录不存在</span>$ cd <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果报错如下</p><p><img src="https://picx.zhimg.com/v2-8cd1f45e079593a46cbb4bc449c86609_1440w.jpg" alt="img"></p><p>使用下面命令生成ssh-key</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"xxx@xxx.com"</span>  <span class="token comment">// 将 "xxx@xxx.com" 替换为你自己GitHub的邮箱地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后一直按 “enter”键，如下图</p><p><img src="https://pic3.zhimg.com/v2-0be2a290a6a935679ac33b3eb9518686_1440w.jpg" alt="img"></p><h3 id="第2步：获取ssh-key公钥内容"><a href="#第2步：获取ssh-key公钥内容" class="headerlink" title="第2步：获取ssh key公钥内容"></a>第2步：获取ssh key公钥内容</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 进入ssh目录</span>$ cd <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token comment">//其中：</span><span class="token comment">//id_rsa：是私钥</span><span class="token comment">//id_rsa.pub：是公钥</span><span class="token comment">// 查看ssh 公钥  进行复制</span>$ cat id_rsa<span class="token punctuation">.</span>pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic3.zhimg.com/v2-3dec0306103257b6adfdb581aa640f28_1440w.jpg" alt="img"></p><h3 id="第3步：GitHub设置中添加公钥"><a href="#第3步：GitHub设置中添加公钥" class="headerlink" title="第3步：GitHub设置中添加公钥"></a>第3步：GitHub设置中添加公钥</h3><p>点击GitHub中设置标签，然后点击 <strong>SSH and GPG keys</strong> 、 <strong>New SSH key</strong> 将复制好的链接粘贴进去</p><p><img src="https://pic4.zhimg.com/v2-61ad52bd47aedb08f6d39fa4750ad847_1440w.jpg" alt="img"></p><p><img src="https://picx.zhimg.com/v2-7ff3ec3c4945801c9174f40dda7a7ba3_1440w.jpg" alt="img"></p><h3 id="第4步：检查是否设置成功"><a href="#第4步：检查是否设置成功" class="headerlink" title="第4步：检查是否设置成功"></a>第4步：检查是否设置成功</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ ssh <span class="token operator">-</span>T git@github<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到<strong>successfully</strong>字样就成功了</p><h3 id="第5步：GitHub中创建仓库，并使用ssh链接进行下拉"><a href="#第5步：GitHub中创建仓库，并使用ssh链接进行下拉" class="headerlink" title="第5步：GitHub中创建仓库，并使用ssh链接进行下拉"></a>第5步：GitHub中创建仓库，并使用ssh链接进行下拉</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git clone <span class="token operator">+</span> <span class="token string">"ssh链接"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第6步：编码，代码上传"><a href="#第6步：编码，代码上传" class="headerlink" title="第6步：编码，代码上传"></a>第6步：编码，代码上传</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">解释<span class="token comment">// 查看更改项</span>$ git status<span class="token comment">// 添加所有更改项</span>$ git add <span class="token punctuation">.</span><span class="token comment">// 提交commit , 这一步可能会有问题</span>$ git commit <span class="token operator">-</span>m <span class="token string">"feat:add code"</span><span class="token comment">// 推送至远端</span>$git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在commit的时候可能会碰到问题 “<strong>please tell me who you are</strong>”,按照提示进行设置就行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"you@example.com"</span>   <span class="token comment">// "you@example.com"替换为你的GitHub邮箱地址</span>$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Your Name"</span>   <span class="token comment">// "Your Name"替换为你的GitHub名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/15/hello-world/"/>
      <url>/2025/04/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

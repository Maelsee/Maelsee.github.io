<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="二叉树的拓展, Maelsee Blog">
    <meta name="description" content="拓展：最近公共祖先系列解题框架如果说笔试的时候经常遇到各种动归回溯这类稍有难度的题目，那么面试会倾向于一些比较经典的问题，难度不算大，而且也比较实用。
本文就用 Git 引出一个经典的算法问题：最近公共祖先（Lowest Common An">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>二叉树的拓展 | Maelsee Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Maelsee Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/hexo/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/Algorithm/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Maelsee Blog</div>
        <div class="logo-desc">
            
            学习记录
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/hexo/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/Algorithm/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">二叉树的拓展</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%AE%9E%E8%B7%B5/">
                                <span class="chip bg-color">实践</span>
                            </a>
                        
                            <a href="/tags/LeetCode/">
                                <span class="chip bg-color">LeetCode</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/" class="post-category">
                                二叉树算法
                            </a>
                        
                            <a href="/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/Algorithm/" class="post-category">
                                算法
                            </a>
                        
                            <a href="/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/Algorithm/Data-Structure/" class="post-category">
                                数据结构
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-08-08
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.5k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="拓展：最近公共祖先系列解题框架"><a href="#拓展：最近公共祖先系列解题框架" class="headerlink" title="拓展：最近公共祖先系列解题框架"></a>拓展：最近公共祖先系列解题框架</h1><p>如果说笔试的时候经常遇到各种动归回溯这类稍有难度的题目，那么面试会倾向于一些比较经典的问题，难度不算大，而且也比较实用。</p>
<p>本文就用 Git 引出一个经典的算法问题：最近公共祖先（Lowest Common Ancestor，简称 LCA）。</p>
<p><code>git pull</code> 这个命令我们经常会用，它默认是使用 <code>merge</code> 方式将远端别人的修改拉到本地；如果带上参数 <code>git pull -r</code>，就会使用 <code>rebase</code> 的方式将远端修改拉到本地。</p>
<p>这二者最直观的区别就是：<code>merge</code> 方式合并的分支会看到很多「分叉」，而 <code>rebase</code> 方式合并的分支就是一条直线。但无论哪种方式，如果存在冲突，Git 都会检测出来并让你手动解决冲突。</p>
<p>那么问题来了，Git 是如何检测两条分支是否存在冲突的呢？</p>
<p>以 <code>rebase</code> 命令为例，比如下图的情况，我站在 <code>dev</code> 分支执行 <code>git rebase master</code>，然后 <code>dev</code> 就会接到 <code>master</code> 分支之上：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1.jpeg" alt="img"></p>
<p>这个过程中，Git 是这么做的：</p>
<p>首先，找到这两条分支的最近公共祖先 <code>LCA</code>，然后从 <code>master</code> 节点开始，重演 <code>LCA</code> 到 <code>dev</code> 几个 <code>commit</code> 的修改，如果这些修改和 <code>LCA</code> 到 <code>master</code> 的 <code>commit</code> 有冲突，就会提示你手动解决冲突，最后的结果就是把 <code>dev</code> 的分支完全接到 <code>master</code> 上面。</p>
<p>那么，Git 是如何找到两条不同分支的最近公共祖先的呢？这就是一个经典的算法问题了，下面我来由浅入深讲一讲。</p>
<hr>
<h2 id="寻找一个元素"><a href="#寻找一个元素" class="headerlink" title="寻找一个元素"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">寻找一个元素</a></h2><p>先不管最近公共祖先问题，我请你实现一个简单的算法：</p>
<p>给你输入一棵<strong>没有重复元素</strong>的二叉树根节点 <code>root</code> 和一个目标值 <code>val</code>，请你写一个函数寻找树中值为 <code>val</code> 的节点。</p>
<p>函数签名如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个函数应该很容易实现对吧，比如我这样写代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：在以 root 为根的二叉树中寻找值为 val 的节点</span>
<span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
    <span class="token comment"># base case</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token comment"># 看看 root.val 是不是要找的</span>
    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>
        <span class="token keyword">return</span> root
    <span class="token comment"># root 不是目标节点，那就去左子树找</span>
    left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">if</span> left<span class="token punctuation">:</span>
        <span class="token keyword">return</span> left
    <span class="token comment"># 左子树找不着，那就去右子树找</span>
    right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">if</span> right<span class="token punctuation">:</span>
        <span class="token keyword">return</span> right
    <span class="token comment"># 实在找不到了</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码应该不用我多解释了，下面的可视化面板展示了这段代码的执行过程，你可以多次点击 这一行，即可展示出函数在二叉树上的搜索过程：</p>
<details data-v-ee1a9bd0="" id="div_lca-example1" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lca-example1" src="https://labuladong.online/algo-visualize/tutorial/lca-example1/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>下面我将基于这段代码做一些简单的改写，请你分析一下我的改动会造成什么影响。</p>
<p>首先，如果修改一下 return 的位置：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token comment"># 前序位置</span>
    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>
        <span class="token keyword">return</span> root
    <span class="token comment"># root 不是目标节点，去左右子树寻找</span>
    left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token comment"># 看看哪边找到了</span>
    <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码也可以达到目的，但是实际运行的效率会低一些。</p>
<p>原因也很简单，如果你能够在左子树找到目标节点，还有没有必要去右子树找了？没有必要。但这段代码还是会去右子树找一圈，所以效率相对差一些。</p>
<p>下面的可视化面板展示了这段代码的执行过程，你可以多次点击 这一行，即可展示出函数在二叉树上的搜索过程，对比上面的可视化面板，这个函数会遍历二叉树的所有节点：</p>
<details data-v-ee1a9bd0="" id="div_lca-example2" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lca-example2" src="https://labuladong.online/algo-visualize/tutorial/lca-example2/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>那么，是不是说这种写法一定会遍历二叉树的所有节点呢？<strong>不一定，还有一个特殊情况</strong>，即要找的目标节点恰好就是根节点。</p>
<p>因为你是在前序位置判断 <code>if (root.val == val)</code> 的，所以这种特殊情况下函数可以直接结束。</p>
<p>更进一步，我把对 <code>root.val</code> 的判断从前序位置移动到后序位置：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token comment"># 先去左右子树寻找</span>
    left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token comment"># 后序位置，看看 root 是不是目标节点</span>
    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>
        <span class="token keyword">return</span> root
    <span class="token comment"># root 不是目标节点，再去看看哪边的子树找到了</span>
    <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码相当于你先去左右子树找，最后才检查 <code>root</code>，依然可以到达目的，但是效率会进一步下降，<strong>因为这种写法必然会遍历二叉树的每一个节点</strong>。</p>
<p>没办法，你是在后序位置判断，那么就算根节点就是目标节点，你也要去左右子树遍历完所有节点才能判断出来。</p>
<p>下面的可视化面板展示了这段代码的执行过程，你可以多次点击 这一行，即可展示出函数在二叉树上的搜索过程：</p>
<details data-v-ee1a9bd0="" id="div_lca-example3" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lca-example3" src="https://labuladong.online/algo-visualize/tutorial/lca-example3/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>最后，我再改一下题目，现在不让你找值为 <code>val</code> 的节点，而是寻找值为 <code>val1</code> <strong>或</strong> <code>val2</code> 的节点，函数签名如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val1<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> val2<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>为什么要写这样一个奇怪的 <code>find</code> 函数呢？因为最近公共祖先系列问题的解法都是把这个函数作为框架的</strong>。</p>
<p>这和我们第一次实现的 <code>find</code> 函数基本上是一样的，而且你应该知道可以有多种写法，比方说我可以这样写代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span>
<span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># base case</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token comment"># 前序位置，看看 root 是不是目标值</span>
    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val1 <span class="token keyword">or</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val2<span class="token punctuation">:</span>
        <span class="token keyword">return</span> root
    <span class="token comment"># 去左右子树寻找</span>
    left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
    right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>

    <span class="token comment"># 后序位置，已经知道左右子树是否存在目标值</span>
    <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然，这种写法会有重复遍历的问题，不过先不急着优化，最近公共祖先的一系列算法问题还就得基于这种写法展开。</p>
<p>下面一道一道题目来看，后文我用 <code>LCA</code>（Lowest Common Ancestor）作为最近公共祖先节点的缩写。</p>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#_236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">236. 二叉树的最近公共祖先</a></h2><p>先来看看力扣第 236 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a>」：</p>
<p>给你输入一棵<strong>不含重复值</strong>的二叉树，以及<strong>存在于树中的</strong>两个节点 <code>p</code> 和 <code>q</code>，请你计算 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</p>
<p>比如输入这样一棵二叉树：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/2.jpg" alt="img"></p>
<p>如果 <code>p</code> 是节点 <code>6</code>，<code>q</code> 是节点 <code>7</code>，那么它俩的 <code>LCA</code> 就是节点 <code>5</code>：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/3.jpg" alt="img"></p>
<p>当然，<code>p</code> 和 <code>q</code> 本身也可能是 <code>LCA</code>，比如这种情况 <code>q</code> 本身就是 <code>LCA</code> 节点：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/4.jpg" alt="img"></p>
<p>两个节点的最近公共祖先其实就是这两个节点向根节点的「延长线」的交汇点，那么对于任意一个节点，它怎么才能知道自己是不是 <code>p</code> 和 <code>q</code> 的最近公共祖先？</p>
<p><strong>如果一个节点能够在它的左右子树中分别找到 <code>p</code> 和 <code>q</code>，则该节点为 <code>LCA</code> 节点</strong>。</p>
<p>这就要用到之前实现的 <code>find</code> 函数了，只需在后序位置添加一个判断逻辑，即可改造成寻找最近公共祖先的解法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">.</span>val<span class="token punctuation">,</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

    <span class="token comment"># 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span>
    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> val1<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> val2<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token comment"># 前序位置</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val1 <span class="token keyword">or</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val2<span class="token punctuation">:</span>
            <span class="token comment"># 如果遇到目标值，直接返回</span>
            <span class="token keyword">return</span> root
        left <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        <span class="token comment"># 后序位置，已经知道左右子树是否存在目标值</span>
        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 当前节点是 LCA 节点</span>
            <span class="token keyword">return</span> root
        
        <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 <code>find</code> 函数的后序位置，如果发现 <code>left</code> 和 <code>right</code> 都非空，就说明当前节点是 <code>LCA</code> 节点，即解决了第一种情况：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/3.jpg" alt="img"></p>
<p>在 <code>find</code> 函数的前序位置，如果找到一个值为 <code>val1</code> 或 <code>val2</code> 的节点则直接返回，恰好解决了第二种情况：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/4.jpg" alt="img"></p>
<p>因为题目说了 <code>p</code> 和 <code>q</code> 一定存在于二叉树中（这点很重要），所以即便我们遇到 <code>q</code> 就直接返回，根本没遍历到 <code>p</code>，也依然可以断定 <code>p</code> 在 <code>q</code> 底下，<code>q</code> 就是 <code>LCA</code> 节点。</p>
<p>下面这个可视化面板展示了这段代码的执行过程，你可以多次点击 这一行，即可展示出函数在二叉树上的搜索过程，你也可以自行修改测试用例玩一玩：</p>
<details data-v-ee1a9bd0="" id="div_lowest-common-ancestor-of-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lowest-common-ancestor-of-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/lowest-common-ancestor-of-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>结合可视化面板，我们也能发现一个优化的点，就是当我们在左子树找到目标 <code>LCA</code> 节点后，算法并没有结束，而是把右子树又遍历了一遍，这其实是没有必要的。</p>
<p>有前面的铺垫，你是不是想做类似这样的优化？</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> root 不是目标节点，那就去左子树找
TreeNode left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> left<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">//</span> 左子树找不着，那就去右子树找
TreeNode right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> right<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不行的，因为我们本来就要同时去左子树和右子树寻找，来判断当前节点是不是 <code>LCA</code>。</p>
<p>如果你非要优化，只能用一个外部变量来辅助判断是否已经找到答案，如果已经找到 <code>LCA</code>，则不再继续遍历二叉树：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 用一个外部变量来记录是否已经找到 LCA 节点</span>
        self<span class="token punctuation">.</span>lca <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">.</span>val<span class="token punctuation">,</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> val1<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> val2<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token comment"># 如果已经找到 LCA 节点，直接返回</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>lca <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val1 <span class="token keyword">or</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val2<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        left <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 当前节点是 LCA 节点，记录下来</span>
            self<span class="token punctuation">.</span>lca <span class="token operator">=</span> root 
            <span class="token keyword">return</span> root
        
        <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段算法的可视化面板如下，你可以多次点击 这一行，即可展示出函数在二叉树上的搜索过程，找到 <code>LCA</code> 节点后，算法就不再继续遍历右侧的子树了：</p>
<details data-v-ee1a9bd0="" id="div_lowest-common-ancestor-of-a-binary-tree-optimized" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lowest-common-ancestor-of-a-binary-tree-optimized" src="https://labuladong.online/algo-visualize/tutorial/lowest-common-ancestor-of-a-binary-tree-optimized/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>这样，标准的最近公共祖先问题就解决了，接下来看看这个题目有什么变体。</p>
<h2 id="1676-二叉树的最近公共祖先-IV"><a href="#1676-二叉树的最近公共祖先-IV" class="headerlink" title="1676. 二叉树的最近公共祖先 IV"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#_1676-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-iv">1676. 二叉树的最近公共祖先 IV</a></h2><p>比如力扣第 1676 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/">二叉树的最近公共祖先 IV</a>」：</p>
<p>依然给你输入一棵不含重复值的二叉树，但这次不是给你输入 <code>p</code> 和 <code>q</code> 两个节点了，而是给你输入一个包含若干节点的列表 <code>nodes</code>（这些节点都存在于二叉树中），让你算这些节点的最近公共祖先。</p>
<p>函数签名如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> nodes<span class="token punctuation">:</span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>比如还是这棵二叉树：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/2.jpg" alt="img"></p>
<p>输入 <code>nodes = [7,4,6]</code>，那么函数应该返回节点 <code>5</code>。</p>
<p>看起来怪吓人的，实则解法逻辑是一样的，把刚才的代码逻辑稍加改造即可解决这道题：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> nodes<span class="token punctuation">:</span> <span class="token string">'List[TreeNode]'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token comment"># 将列表转化成哈希集合，便于判断元素是否存在</span>
        values <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>
            values<span class="token punctuation">.</span>add<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">,</span> values<span class="token punctuation">)</span>
    
    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> values<span class="token punctuation">:</span> <span class="token string">'set'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token comment"># 前序位置</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token keyword">in</span> values<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root

        left <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> values<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> values<span class="token punctuation">)</span>
        <span class="token comment"># 后序位置，已经知道左右子树是否存在目标值</span>
        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 当前节点是 LCA 节点</span>
            <span class="token keyword">return</span> root
        
        <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类比一下上一道题应该不难理解这个解法。当找到 <code>LCA</code> 节点后，也可以提前停止算法，这个优化就留给你吧。</p>
<p><strong>需要注意的是，这两道题的题目都明确告诉我们这些节点必定存在于二叉树中，如果没有这个前提条件，就需要修改代码了</strong>。</p>
<h2 id="1644-二叉树的最近公共祖先-II"><a href="#1644-二叉树的最近公共祖先-II" class="headerlink" title="1644. 二叉树的最近公共祖先 II"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#_1644-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-ii">1644. 二叉树的最近公共祖先 II</a></h2><p>比如力扣第 1644 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/">二叉树的最近公共祖先 II</a>」：</p>
<p>给你输入一棵<strong>不含重复值</strong>的二叉树的，以及两个节点 <code>p</code> 和 <code>q</code>，如果 <code>p</code> 或 <code>q</code> 不存在于树中，则返回空指针，否则的话返回 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</p>
<p>在解决标准的最近公共祖先问题时，我们在 <code>find</code> 函数的前序位置有这样一段代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> 前序位置
<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> val1 <span class="token operator">|</span><span class="token operator">|</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">//</span> 如果遇到目标值，直接返回
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我也进行了解释，因为 <code>p</code> 和 <code>q</code> 都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/4.jpg" alt="img"></p>
<p>但对于这道题来说，<code>p</code> 和 <code>q</code> 不一定存在于树中，所以你不能遇到一个目标值就直接返回，而应该对二叉树进行<strong>完全搜索</strong>（遍历每一个节点），如果发现 <code>p</code> 或 <code>q</code> 不存在于树中，那么是不存在 <code>LCA</code> 的。</p>
<p>回想我在文章开头分析的几种 <code>find</code> 函数的写法，哪种写法能够对二叉树进行完全搜索来着？</p>
<p>这种：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token comment"># 先去左右子树寻找</span>
    left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token comment"># 后序位置，看看 root 是不是目标节点</span>
    <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>
        <span class="token keyword">return</span> root
    <span class="token comment"># root 不是目标节点，再去看看哪边的子树找到了</span>
    <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么解决这道题也是类似的，我们只需要把前序位置的判断逻辑放到后序位置即可：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 用于记录 p 和 q 是否存在于二叉树中</span>
        self<span class="token punctuation">.</span>foundP <span class="token operator">=</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>foundQ <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        res <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">.</span>val<span class="token punctuation">,</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>foundP <span class="token keyword">or</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>foundQ<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token comment"># p 和 q 都存在二叉树中，才有公共祖先</span>
        <span class="token keyword">return</span> res
        
    <span class="token comment"># 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span>
    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        left <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        
        <span class="token comment"># 后序位置，判断当前节点是不是 LCA 节点</span>
        <span class="token keyword">if</span> left <span class="token keyword">and</span> right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        
        <span class="token comment"># 后序位置，判断当前节点是不是目标值</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val1 <span class="token keyword">or</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val2<span class="token punctuation">:</span>
            <span class="token comment"># 找到了，记录一下</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val1<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>foundP <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val2<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>foundQ <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">return</span> root

        <span class="token keyword">return</span> left <span class="token keyword">if</span> left <span class="token keyword">else</span> right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样改造，对二叉树进行完全搜索，同时记录 <code>p</code> 和 <code>q</code> 是否同时存在树中，从而满足题目的要求。</p>
<p>这段算法的可视化面板如下，我构造了一个 <code>q</code> 不在树中的场景，多次点击 即可查看函数搜索二叉树的过程：</p>
<details data-v-ee1a9bd0="" id="div_lowest-common-ancestor-of-a-binary-tree-ii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lowest-common-ancestor-of-a-binary-tree-ii" src="https://labuladong.online/algo-visualize/leetcode/lowest-common-ancestor-of-a-binary-tree-ii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>接下来，我们再变一变，如果让你在二叉搜索树中寻找 <code>p</code> 和 <code>q</code> 的最近公共祖先，应该如何做呢？</p>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#_235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">235. 二叉搜索树的最近公共祖先</a></h2><p>看力扣第 235 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a>」：</p>
<p>给你输入一棵不含重复值的<strong>二叉搜索树</strong>，以及<strong>存在于树中</strong>的两个节点 <code>p</code> 和 <code>q</code>，请你计算 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</p>
<p>把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「左小右大」的性质，显然效率不是最高的。</p>
<p>在标准的最近公共祖先问题中，我们要在后序位置通过左右子树的搜索结果来判断当前节点是不是 <code>LCA</code>：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">TreeNode left <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span>
TreeNode right <span class="token operator">=</span> find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">//</span> 后序位置，判断当前节点是不是 LCA 节点
<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;</span><span class="token operator">&amp;</span> right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，将当前节点的值与 <code>val1</code> 和 <code>val2</code> 作对比即可判断当前节点是不是 <code>LCA</code></strong>：</p>
<p>假设 <code>val1 &lt; val2</code>，那么 <code>val1 &lt;= root.val &lt;= val2</code> 则说明当前节点就是 <code>LCA</code>；若 <code>root.val</code> 比 <code>val1</code> 还小，则需要去值更大的右子树寻找 <code>LCA</code>；若 <code>root.val</code> 比 <code>val2</code> 还大，则需要去值更小的左子树寻找 <code>LCA</code>。</p>
<p>依据这个思路就可以写出解法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token comment"># 保证 val1 较小，val2 较大</span>
        val1 <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">,</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        val2 <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">,</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>

    <span class="token comment"># 在 BST 中寻找 val1 和 val2 的最近公共祖先节点</span>
    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> val1<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> val2<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> val2<span class="token punctuation">:</span>
            <span class="token comment"># 当前节点太大，去左子树找</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val1<span class="token punctuation">:</span>
            <span class="token comment"># 当前节点太小，去右子树找</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span>
        <span class="token comment"># val1 &lt;= root.val &lt;= val2</span>
        <span class="token comment"># 则当前节点就是最近公共祖先</span>
        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码的可视化面板如下，可以看到在 BST 中寻找最近公共祖先的过程非常快，不需要遍历整棵树：</p>
<details data-v-ee1a9bd0="" id="div_lowest-common-ancestor-of-a-binary-search-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lowest-common-ancestor-of-a-binary-search-tree" src="https://labuladong.online/algo-visualize/leetcode/lowest-common-ancestor-of-a-binary-search-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<h2 id="1650-二叉树的最近公共祖先-III"><a href="#1650-二叉树的最近公共祖先-III" class="headerlink" title="1650. 二叉树的最近公共祖先 III"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#_1650-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-iii">1650. 二叉树的最近公共祖先 III</a></h2><p>再看最后一道最近公共祖先的题目吧，力扣第 1650 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/">二叉树的最近公共祖先 III</a>」，这次输入的二叉树节点比较特殊，包含指向父节点的指针。题目会给你输入一棵存在于二叉树中的两个节点 <code>p</code> 和 <code>q</code>，请你返回它们的最近公共祖先。函数签名如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>

<span class="token comment"># 函数签名</span>
<span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>p<span class="token punctuation">:</span> Node<span class="token punctuation">,</span> q<span class="token punctuation">:</span> Node<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Node<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于节点中包含父节点的指针，所以二叉树的根节点就没必要输入了。</p>
<p><strong>这道题其实不是公共祖先的问题，而是单链表相交的问题</strong>，你把 <code>parent</code> 指针想象成单链表的 <code>next</code> 指针，题目就变成了：</p>
<p>给你输入两个单链表的头结点 <code>p</code> 和 <code>q</code>，这两个单链表必然会相交，请你返回相交点。</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/5.png" alt="img"></p>
<p>我在前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">单链表的六大解题套路</a> 中详细讲解过求链表交点的问题，具体思路在本文就不展开了，直接给出本题的解法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token comment"># 施展链表双指针技巧</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">,</span> q
        <span class="token keyword">while</span> a <span class="token operator">!=</span> b<span class="token punctuation">:</span>
            <span class="token comment"># a 走一步，如果走到根节点，转到 q 节点</span>
            <span class="token keyword">if</span> a <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                a <span class="token operator">=</span> q
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                a <span class="token operator">=</span> a<span class="token punctuation">.</span>parent
            <span class="token comment"># b 走一步，如果走到根节点，转到 p 节点</span>
            <span class="token keyword">if</span> b <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                b <span class="token operator">=</span> p
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                b <span class="token operator">=</span> b<span class="token punctuation">.</span>parent
        <span class="token keyword">return</span> a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码的可视化面板如下，可以多次点击 这一行代码查看两个指针交替移动的过程：</p>
<details data-v-ee1a9bd0="" id="div_lowest-common-ancestor-of-a-binary-tree-iii" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_lowest-common-ancestor-of-a-binary-tree-iii" src="https://labuladong.online/algo-visualize/leetcode/lowest-common-ancestor-of-a-binary-tree-iii/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>至此，5 道最近公共祖先的题目就全部讲完了，前 3 道题目从一个基本的 <code>find</code> 函数衍生出解法，后 2 道比较特殊，分别利用了 BST 和单链表相关的技巧，希望本文对你有启发。</p>
<h1 id="拓展：如何计算完全二叉树的节点数"><a href="#拓展：如何计算完全二叉树的节点数" class="headerlink" title="拓展：如何计算完全二叉树的节点数"></a>拓展：如何计算完全二叉树的节点数</h1><p>如果让你数一下一棵普通二叉树有多少个节点，这很简单，只要在二叉树的遍历框架上加一点代码就行了。</p>
<p>但是，力扣第第 222 题「完全二叉树的节点个数」给你一棵完全二叉树，让你计算它的节点个数，你会不会？算法的时间复杂度是多少？</p>
<p>这个算法的时间复杂度应该是$ O(logN∗logN)，如果你心中的算法没有达到这么高效，那么本文就是给你写的。</p>
<p>关于「完全二叉树」和「满二叉树」等名词的定义，可以参考基础知识章节的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure-basic/binary-tree-basic/">二叉树基础</a>。</p>
<h3 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="一、思路分析"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/count-complete-tree-nodes/#%E4%B8%80%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">一、思路分析</a></h3><p>现在回归正题，如何求一棵完全二叉树的节点个数呢？</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入一棵完全二叉树，返回节点总数</span>
<span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果是一个<strong>普通</strong>二叉树，显然只要向下面这样遍历一边即可，时间复杂度 $O(N)$：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>那如果是一棵<strong>满</strong>二叉树，节点总数就和树的高度呈指数关系：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    h <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment"># 计算树的高度</span>
    <span class="token keyword">while</span> root<span class="token punctuation">:</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
        h <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token comment"># 节点总数就是 2^h - 1</span>
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">**</span> h <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>完全</strong>二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        l <span class="token operator">=</span> root
        r <span class="token operator">=</span> root
        hl <span class="token operator">=</span> <span class="token number">0</span>
        hr <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token comment"># 沿最左侧和最右侧分别计算高度</span>
        <span class="token keyword">while</span> l <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            l <span class="token operator">=</span> l<span class="token punctuation">.</span>left
            hl <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> r <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            r <span class="token operator">=</span> r<span class="token punctuation">.</span>right
            hr <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token comment"># 如果左右侧计算的高度相同，则是一棵满二叉树</span>
        <span class="token keyword">if</span> hl <span class="token operator">==</span> hr<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> hl<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token comment"># 如果左右侧的高度不同，则按照普通二叉树的逻辑计算</span>
        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<details data-v-ee1a9bd0="" id="div_count-complete-tree-nodes" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_count-complete-tree-nodes" src="https://labuladong.online/algo-visualize/leetcode/count-complete-tree-nodes/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<p>结合刚才针对满二叉树和普通二叉树的算法，上面这段代码应该不难理解，就是一个结合版，但是<strong>其中降低时间复杂度的技巧是非常微妙的</strong>。</p>
<h3 id="二、复杂度分析"><a href="#二、复杂度分析" class="headerlink" title="二、复杂度分析"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/count-complete-tree-nodes/#%E4%BA%8C%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">二、复杂度分析</a></h3><p>开头说了，这个算法的时间复杂度是 $O(log⁡N×log⁡N)$，这是怎么算出来的呢？</p>
<p>直觉感觉好像最坏情况下是 $O(N×log⁡N)$ 吧，因为之前的 while 需要$ log⁡N$的时间，最后要 $O(N)$ 的时间向左右子树递归：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 <code>hl == hr</code> 而立即返回，不会递归下去</strong>。</p>
<p>为什么呢？原因如下：</p>
<p><strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong>：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1.jpg" alt="img"></p>
<p>看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 <code>hl == hr</code>，只消耗 $O*(log*N)$ 的复杂度而不会继续递归。</p>
<p>综上，算法的递归深度就是树的高度 $ O(logN) $，每次递归所花费的时间就是 while 循环，需要 $O(logN)$，所以总体的时间复杂度是$O(logN×logN)$。</p>
<p>所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。</p>
<h1 id="拓展：惰性展开多叉树"><a href="#拓展：惰性展开多叉树" class="headerlink" title="拓展：惰性展开多叉树"></a>拓展：惰性展开多叉树</h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">一、题目描述</a></h2><p>这是力扣第 341 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-nested-list-iterator/">扁平化嵌套列表迭代器</a>」：</p>
<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">341. 扁平化嵌套列表迭代器</strong>&nbsp;|<span>&nbsp;</span><span><a target="_blank" href="https://leetcode.cn/problems/flatten-nested-list-iterator/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<externallinkicon></externallinkicon></a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a target="_blank" href="https://leetcode.com/problems/flatten-nested-list-iterator/" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<externallinkicon></externallinkicon></a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个嵌套的整数列表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nestedList</code><span>&nbsp;</span>。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现扁平迭代器类<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">NestedIterator</code><span>&nbsp;</span>：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">NestedIterator(List&lt;NestedInteger&gt; nestedList)</code><span>&nbsp;</span>用嵌套列表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nestedList</code><span>&nbsp;</span>初始化迭代器。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">int next()</code><span>&nbsp;</span>返回嵌套列表的下一个整数。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">boolean hasNext()</code><span>&nbsp;</span>如果仍然存在待迭代的整数，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">你的代码将会用下述伪代码检测：</p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;">initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res</pre><p style="line-height: 1.6; overflow-wrap: break-word;">如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">res</code><span>&nbsp;</span>与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nestedList = [[1,1],2,[1,1]]
<strong style="font-weight: 600;">输出：</strong>[1,1,2,1,1]
<strong style="font-weight: 600;">解释：</strong>通过重复调用&nbsp;<em>next </em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">[1,1,2,1,1]</code>。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nestedList = [1,[4,[6]]]
<strong style="font-weight: 600;">输出：</strong>[1,4,6]
<strong style="font-weight: 600;">解释：</strong>通过重复调用&nbsp;<em>next&nbsp;</em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">[1,4,6]</code>。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nestedList.length &lt;= 500</code></li><li>嵌套列表中的整数值在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-10<sup>6</sup>, 10<sup>6</sup>]</code><span>&nbsp;</span>内</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/flatten-nested-list-iterator/" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 341. 扁平化嵌套列表迭代器</a>。</strong></details>

<p>我们的算法会被输入一个 <code>NestedInteger</code> 列表，我们需要做的就是写一个迭代器类 <code>NestedIterator</code>，将这个带有嵌套结构 <code>NestedInteger</code> 的列表「拍平」：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NestedIterator</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nestedList<span class="token punctuation">:</span> List<span class="token punctuation">[</span>NestedInteger<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 构造器输入一个 NestedInteger 列表</span>
        <span class="token keyword">pass</span>

    <span class="token comment"># 返回下一个整数</span>
    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

    <span class="token comment"># 是否还有下一个元素？</span>
    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们写的这个 <code>NestedIterator</code> 类会被这样调用，<strong>先调用 <code>hasNext</code> 方法，后调用 <code>next</code> 方法</strong>：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">NestedIterator i <span class="token operator">=</span> new NestedIterator<span class="token punctuation">(</span>nestedList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>学过设计模式的朋友应该知道，迭代器也是设计模式的一种，目的就是为调用者屏蔽底层数据结构的细节，简单地通过 <code>hasNext</code> 和 <code>next</code> 方法有序地进行遍历。</p>
<p>为什么说这个题目很有启发性呢？因为我最近在用一款类似印象笔记的软件，叫做 Notion（挺有名的）。这个软件的一个亮点就是「万物皆 block」，比如说标题、页面、表格都是 block。有的 block 甚至可以无限嵌套，这就打破了传统笔记本「文件夹」-&gt;「笔记本」-&gt;「笔记」的三层结构。</p>
<p>回想这个算法问题，<code>NestedInteger</code> 结构实际上也是一种支持无限嵌套的结构，而且可以同时表示整数和列表两种不同类型，我想 Notion 的核心数据结构 block 估计也是这样的一种设计思路。</p>
<p>那么话说回来，对于这个算法问题，我们怎么解决呢？<code>NestedInteger</code> 结构可以无限嵌套，怎么把这个结构「打平」，为迭代器的调用者屏蔽底层细节，得到扁平化的输出呢？</p>
<h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/#%E4%BA%8C%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">二、解题思路</a></h2><p>显然，<code>NestedInteger</code> 这个神奇的数据结构是问题的关键，不过题目专门提醒我们不要尝试去实现它，也不要去猜测它的实现。</p>
<p><strong>为什么？凭什么？是不是题目在误导我？是不是我进行推测之后，这道题就不攻自破了</strong>？</p>
<p>你不让推测，我就偏偏要去推测！我反手就把 <code>NestedInteger</code> 这个结构给实现出来：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义嵌套整型类</span>
<span class="token keyword">class</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">:</span>
    <span class="token comment"># 嵌套整型类型，通过一个整数初始化</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> lst<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token string">'NestedInteger'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 当前嵌套整型类的整型值</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        <span class="token comment"># 当前嵌套整型类嵌套的整型类列表</span>
        self<span class="token punctuation">.</span>lst <span class="token operator">=</span> lst

    <span class="token comment"># 如果其中存的是一个整数，则返回 true，否则返回 false</span>
    <span class="token keyword">def</span> <span class="token function">isInteger</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>val <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>

    <span class="token comment"># 如果其中存的是一个整数，则返回这个整数，否则返回 null</span>
    <span class="token keyword">def</span> <span class="token function">getInteger</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>val

    <span class="token comment"># 如果其中存的是一个列表，则返回这个列表，否则返回 null</span>
    <span class="token keyword">def</span> <span class="token function">getList</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token string">'NestedInteger'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>lst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>嗯，其实这个实现也不难嘛，写出来之后，我不禁翻出前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure-basic/n-ary-tree-traverse-basic/">多叉树基础及遍历</a>，发现这玩意儿竟然……</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># 基本的 N 叉树节点</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>这玩意儿不就是棵 N 叉树吗？叶子节点是 <code>Integer</code> 类型，其 <code>val</code> 字段非空；其他节点都是 <code>List&lt;NestedInteger&gt;</code> 类型，其 <code>val</code> 字段为空，但是 <code>list</code> 字段非空，装着孩子节点</strong>。</p>
<p>比如说输入是 <code>[[1,1],2,[1,1]]</code>，其实就是如下树状结构：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1-1754615108529-13.jpeg" alt="img"></p>
<p>好的，刚才题目说什么来着？把一个 <code>NestedInteger</code> 扁平化对吧？<strong>这不就等价于遍历一棵 N 叉树的所有「叶子节点」吗</strong>？我把所有叶子节点都拿出来，不就可以作为迭代器进行遍历了吗？</p>
<p>N 叉树的遍历怎么整？我又不禁翻出前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure-basic/n-ary-tree-traverse-basic/">多叉树遍历框架</a>：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
        traverse<span class="token punctuation">(</span>child<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个框架可以遍历所有节点，而我们只对整数型的 <code>NestedInteger</code> 感兴趣，也就是我们只想要「叶子节点」，所以 <code>traverse</code> 函数只要在到达叶子节点的时候把 <code>val</code> 加入结果列表即可：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NestedIterator</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nestedList<span class="token punctuation">:</span> List<span class="token punctuation">[</span>NestedInteger<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 存放将 nestedList 打平的结果</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> nestedList<span class="token punctuation">:</span>
            <span class="token comment"># 以每个节点为根遍历</span>
            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>node<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>result <span class="token operator">=</span> result

    <span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>isInteger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 到达叶子节点</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>getInteger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token comment"># 遍历框架</span>
        <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>getList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>traverse<span class="token punctuation">(</span>child<span class="token punctuation">,</span> result<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> self<span class="token punctuation">.</span>result<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>index <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> res

    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样，我们就把原问题巧妙转化成了一个 N 叉树的遍历问题，并且得到了解法。</p>
<h2 id="三、进阶思路"><a href="#三、进阶思路" class="headerlink" title="三、进阶思路"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/#%E4%B8%89%E3%80%81%E8%BF%9B%E9%98%B6%E6%80%9D%E8%B7%AF">三、进阶思路</a></h2><p>以上解法虽然可以通过，但是在面试中，也许是有瑕疵的。</p>
<p>我们的解法中，一次性算出了所有叶子节点的值，全部装到 <code>result</code> 列表，也就是内存中，<code>next</code> 和 <code>hasNext</code> 方法只是在对 <code>result</code> 列表做迭代。如果输入的规模非常大，构造函数中的计算就会很慢，而且很占用内存。</p>
<p>一般的迭代器求值应该是「惰性的」，也就是说，如果你要一个结果，我就算一个（或是一小部分）结果出来，而不是一次把所有结果都算出来。</p>
<p>如果想做到这一点，使用递归函数进行 DFS 遍历肯定是不行的，而且我们其实只关心「叶子节点」，所以传统的 BFS 算法也不行。实际的思路很简单：</p>
<p><strong>调用 <code>hasNext</code> 时，如果 <code>nestedList</code> 的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型</strong>。</p>
<p>仔细想一下这个过程应该就能理解了，一次只展开一个最内层的 <code>nestedList</code>，不会一次性把所有 <code>nestedList</code> 展开，相当于惰性的 DFS 遍历。</p>
<p>由于调用 <code>next</code> 方法之前一定会调用 <code>hasNext</code> 方法，这就可以保证每次调用 <code>next</code> 方法的时候第一个元素是整数型，直接返回并删除第一个元素即可。</p>
<p>看一下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NestedIterator</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nestedList<span class="token punctuation">:</span> <span class="token punctuation">[</span>NestedInteger<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 不直接用 nestedList 的引用，是因为不能确定它的底层实现</span>
        <span class="token comment"># 必须保证是 LinkedList，否则下面的 addFirst 会很低效</span>
        self<span class="token punctuation">.</span><span class="token builtin">list</span> <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>nestedList<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># hasNext 方法保证了第一个元素一定是整数类型</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getInteger<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token comment"># 循环拆分列表元素，直到列表第一个元素是整数类型</span>
        <span class="token keyword">while</span> self<span class="token punctuation">.</span><span class="token builtin">list</span> <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isInteger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 当列表开头第一个元素是列表类型时，进入循环</span>
            first <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getList<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 将第一个列表打平并按顺序添加到开头</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>first<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token builtin">bool</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">list</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以这种方法，符合迭代器惰性求值的特性，是比较好的解法。</p>
<h1 id="拓展：归并排序详解及应用"><a href="#拓展：归并排序详解及应用" class="headerlink" title="拓展：归并排序详解及应用"></a>拓展：归并排序详解及应用</h1><p>一直都有很多读者说，想让我用框架思维讲一讲基本的排序算法，我觉得确实得讲讲，毕竟学习任何东西都讲求一个融会贯通，只有对其本质进行比较深刻的理解，才能运用自如。</p>
<p>本文就先讲归并排序，给一套代码模板，然后讲讲它在算法问题中的应用。阅读本文前我希望你读过前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（纲领篇）</a>。</p>
<p>我在讲二叉树的时候，提了一嘴归并排序，说归并排序就是二叉树的后序遍历，当时就有很多读者留言说醍醐灌顶。</p>
<p>知道为什么很多读者遇到递归相关的算法就觉得烧脑吗？因为还处在「看山是山，看水是水」的阶段。</p>
<p>就说归并排序吧，如果给你看代码，让你脑补一下归并排序的过程，你脑子里会出现什么场景？</p>
<p>这是一个数组排序算法，所以你脑补一个数组的 GIF，在那一个个交换元素？如果是这样的话，那格局就低了。</p>
<p>但如果你脑海中浮现出的是一棵二叉树，甚至浮现出二叉树后序遍历的场景，那格局就高了，大概率掌握了我经常强调的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/algorithm-summary/">框架思维</a>，用这种抽象能力学习算法就省劲多了。</p>
<p>那么，归并排序明明就是一个数组算法，和二叉树有什么关系？接下来我就具体讲讲。</p>
<hr>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">算法思路</a></h2><p><strong>就这么说吧，所有递归的算法，你甭管它是干什么的，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么</strong>。</p>
<p>你看归并排序的代码框架：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：排序 nums[lo..hi]</span>
<span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo <span class="token operator">+</span> hi<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    <span class="token comment"># 利用定义，排序 nums[lo..mid]</span>
    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
    <span class="token comment"># 利用定义，排序 nums[mid+1..hi]</span>
    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    <span class="token comment"># ***** 后序位置 *****</span>
    <span class="token comment"># 此时两部分子数组已经被排好序</span>
    <span class="token comment"># 合并两个有序数组，使 nums[lo..hi] 有序</span>
    merge<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

<span class="token comment"># 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span>
<span class="token comment"># 合并为有序数组 nums[lo..hi]</span>
<span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> mid<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>看这个框架，也就明白那句经典的总结：归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。</p>
<p>上述代码和二叉树的后序遍历很像：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 二叉树遍历框架 </span>
<span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span> 
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token comment"># 后序位置</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再进一步，你联想一下求二叉树的最大深度的算法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义：输入根节点，返回这棵二叉树的最大深度</span>
<span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token comment"># 利用定义，计算左右子树的最大深度</span>
	leftMax <span class="token operator">=</span> maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
	rightMax <span class="token operator">=</span> maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
	<span class="token comment"># 整棵树的最大深度等于左右子树的最大深度取最大值，</span>
	<span class="token comment"># 然后再加上根节点自己</span>
	res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span> rightMax<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>

	<span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>是不是更像了？</p>
<p>前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（纲领篇）</a> 说二叉树问题可以分为两类思路，一类是遍历一遍二叉树的思路，另一类是分解问题的思路，根据上述类比，显然归并排序利用的是分解问题的思路（<a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/divide-and-conquer/">分治算法</a>）。</p>
<p><strong>归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 <code>nums[lo..hi]</code>，叶子节点的值就是数组中的单个元素</strong>：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1-1754615251849-16.jpeg" alt="img"></p>
<p>然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 <code>merge</code> 函数，合并两个子节点上的子数组：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/2.jpeg" alt="img"></p>
<p>这个 <code>merge</code> 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。</p>
<p>后序遍历二叉树大家应该已经烂熟于心了，就是下图这个遍历顺序：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/3.jpeg" alt="img"></p>
<p>结合上述基本分析，我们把 <code>nums[lo..hi]</code> 理解成二叉树的节点，<code>sort</code> 函数理解成二叉树的遍历函数，整个归并排序的执行过程就是以下 GIF 描述的这样：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/4.gif" alt="img"></p>
<p>这样，归并排序的核心思路就分析完了，接下来只要把思路翻译成代码就行。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></h2><p><strong>只要拥有了正确的思维方式，理解算法思路是不困难的，但把思路实现成代码，也很考验一个人的编程能力</strong>。</p>
<p>毕竟算法的时间复杂度只是一个理论上的衡量标准，而算法的实际运行效率要考虑的因素更多，比如应该避免内存的频繁分配释放，代码逻辑应尽可能简洁等等。</p>
<p>这里我参考《算法 4》这本书中归并排序代码给出归并排序的代码实现：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Merge</span><span class="token punctuation">:</span>

    <span class="token comment"># 用于辅助合并有序数组</span>
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 先给辅助数组开辟内存空间</span>
        Merge<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token comment"># 排序整个数组（原地修改）</span>
        Merge<span class="token punctuation">.</span>_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment"># 定义：将子数组 nums[lo..hi] 进行排序</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>
            <span class="token comment"># 单个元素不用排序</span>
            <span class="token keyword">return</span>
        <span class="token comment"># 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span>
        mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token comment"># 先对左半部分数组 nums[lo..mid] 排序</span>
        Merge<span class="token punctuation">.</span>_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
        <span class="token comment"># 再对右半部分数组 nums[mid+1..hi] 排序</span>
        Merge<span class="token punctuation">.</span>_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
        <span class="token comment"># 将两部分有序数组合并成一个有序数组</span>
        Merge<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    <span class="token comment"># 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 先把 nums[lo..hi] 复制到辅助数组中</span>
        <span class="token comment"># 以便合并后的结果能够直接存入 nums</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

        <span class="token comment"># 数组双指针技巧，合并两个有序数组</span>
        i<span class="token punctuation">,</span> j <span class="token operator">=</span> lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 左半边数组已全部被合并</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> j <span class="token operator">==</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 右半边数组已全部被合并</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> Merge<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有了之前的铺垫，这里只需要着重讲一下这个 <code>merge</code> 函数。</p>
<p><code>sort</code> 函数对 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 递归排序完成之后，我们没有办法原地把它俩合并，所以需要 copy 到 <code>temp</code> 数组里面，然后通过类似于前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">单链表的六大技巧</a> 中合并有序链表的双指针技巧将 <code>nums[lo..hi]</code> 合并成一个有序数组：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/5.jpeg" alt="img"></p>
<p>注意我们不是在 <code>merge</code> 函数执行的时候 new 辅助数组，而是提前把 <code>temp</code> 辅助数组 new 出来了，这样就避免了在递归中频繁分配和释放内存可能产生的性能问题。</p>
<p>贴一个归并排序过程的可视化动画，方便大家理解算法运行的过程：</p>
<details data-v-ee1a9bd0="" id="div_merge-sort" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_merge-sort" src="https://labuladong.online/algo-visualize/tutorial/merge-sort/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">复杂度分析</a></h2><p>再说一下归并排序的时间复杂度，虽然大伙儿应该都知道是 O(NlogN)，但不见得所有人都知道这个复杂度怎么算出来的。</p>
<p>前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划详解</a> 说过递归算法的复杂度计算，就是子问题个数 x 解决一个子问题的复杂度。对于归并排序来说，时间复杂度显然集中在 <code>merge</code> 函数遍历 <code>nums[lo..hi]</code> 的过程，但每次 <code>merge</code> 输入的 <code>lo</code> 和 <code>hi</code> 都不同，所以不容易直观地看出时间复杂度。</p>
<p><code>merge</code> 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？这就要结合之前画的这幅图来看：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1-1754615251849-16.jpeg" alt="img"></p>
<p><strong>执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数</strong>。</p>
<p>所以从整体上看，这个二叉树的高度是 <code>logN</code>，其中每一层的元素个数就是原数组的长度 <code>N</code>，所以总的时间复杂度就是 O(NlogN)。</p>
<h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#_912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">912. 排序数组</a></h2><p>力扣第 912 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">排序数组</a>」就是让你对数组进行排序，我们可以直接套用归并排序代码模板：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        Merge<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">return</span> nums

<span class="token keyword">class</span> <span class="token class-name">Merge</span><span class="token punctuation">:</span>
    <span class="token comment"># 见上文</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#_315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0">315. 计算右侧小于当前元素的个数</a></h2><p>除了最基本的排序问题，归并排序还可以用来解决力扣第 315 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a>」：</p>
<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">315. 计算右侧小于当前元素的个数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><em><span>&nbsp;</span></em>，按要求返回一个新数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">counts</code><em><span>&nbsp;</span></em>。数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">counts</code><span>&nbsp;</span>有该性质：<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">counts[i]</code><span>&nbsp;</span>的值是&nbsp;<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code><span>&nbsp;</span>右侧小于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i]</code><span>&nbsp;</span>的元素的数量。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [5,2,6,1]
<strong style="font-weight: 600;">输出：</strong><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">[2,1,1,0] 
<strong style="font-weight: 600;">解释：</strong></code>
5 的右侧有 <strong style="font-weight: 600;">2 </strong>个更小的元素 (2 和 1)
2 的右侧仅有 <strong style="font-weight: 600;">1 </strong>个更小的元素 (1)
6 的右侧有 <strong style="font-weight: 600;">1 </strong>个更小的元素 (1)
1 的右侧有 <strong style="font-weight: 600;">0 </strong>个更小的元素
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [-1]
<strong style="font-weight: 600;">输出：</strong>[0]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [-1,-1]
<strong style="font-weight: 600;">输出：</strong>[0,0]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>4</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>4</sup></code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 315. 计算右侧小于当前元素的个数</a>。</strong></details>

<p>我用比较数学的语言来描述一下（方便和后续类似题目进行对比），题目让你求出一个 <code>count</code> 数组，使得：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> COUNT<span class="token punctuation">(</span>j<span class="token punctuation">)</span> where j <span class="token operator">></span> i <span class="token keyword">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>拍脑袋的暴力解法就不说了，嵌套 for 循环，平方级别的复杂度。</p>
<p>这题和归并排序什么关系呢，主要在 <code>merge</code> 函数，<strong>我们在使用 <code>merge</code> 函数合并两个有序数组的时候，其实是可以知道一个元素 <code>nums[i]</code> 后边有多少个元素比 <code>nums[i]</code> 小的</strong>。</p>
<p>具体来说，比如这个场景：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/6.jpeg" alt="img"></p>
<p>这时候我们应该把 <code>temp[i]</code> 放到 <code>nums[p]</code> 上，因为 <code>temp[i] &lt; temp[j]</code>。</p>
<p>但就在这个场景下，我们还可以知道一个信息：5 后面比 5 小的元素个数就是 左闭右开区间 <code>[mid + 1, j)</code> 中的元素个数，即 2 和 4 这两个元素：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/7.jpeg" alt="img"></p>
<p><strong>换句话说，在对 <code>nums[lo..hi]</code> 合并的过程中，每当执行 <code>nums[p] = temp[i]</code> 时，就可以确定 <code>temp[i]</code> 这个元素后面比它小的元素个数为 <code>j - mid - 1</code></strong>。</p>
<p>当然，<code>nums[lo..hi]</code> 本身也只是一个子数组，这个子数组之后还会被执行 <code>merge</code>，其中元素的位置还是会改变。但这是其他递归节点需要考虑的问题，我们只要在 <code>merge</code> 函数中做一些手脚，叠加每次 <code>merge</code> 时记录的结果即可。</p>
<p>发现了这个规律后，我们只要在 <code>merge</code> 中添加两行代码即可解决这个问题，看解法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 记录数组的元素值</span>
            self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
            <span class="token comment"># 记录元素在数组中的原始索引</span>
            self<span class="token punctuation">.</span><span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">id</span>

    <span class="token comment"># 归并排序所用的辅助数组</span>
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 记录每个元素后面比自己小的元素个数</span>
    count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment"># 主函数</span>
    <span class="token keyword">def</span> <span class="token function">countSmaller</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
        self<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>Pair<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment"># 记录元素原始的索引位置，以便在 count 数组中更新结果</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Pair<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token comment"># 执行归并排序，本题结果被记录在 count 数组中</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> c <span class="token keyword">in</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res

    <span class="token comment"># 归并排序</span>
    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    <span class="token comment"># 合并两个有序数组</span>
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

        i<span class="token punctuation">,</span> j <span class="token operator">=</span> lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> j <span class="token operator">==</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token comment"># 更新 count 数组</span>
                self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">id</span><span class="token punctuation">]</span> <span class="token operator">+=</span> j <span class="token operator">-</span> mid <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">></span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token comment"># 更新 count 数组</span>
                self<span class="token punctuation">.</span>count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">id</span><span class="token punctuation">]</span> <span class="token operator">+=</span> j <span class="token operator">-</span> mid <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为在排序过程中，每个元素的索引位置会不断改变，所以我们用一个 <code>Pair</code> 类封装每个元素及其在原始数组 <code>nums</code> 中的索引，以便 <code>count</code> 数组记录每个元素之后小于它的元素个数。</p>
<p>接下来我们再看几道原理类似的题目，都是通过给归并排序的 <code>merge</code> 函数加一些私货完成目标。</p>
<h2 id="493-翻转对"><a href="#493-翻转对" class="headerlink" title="493. 翻转对"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#_493-%E7%BF%BB%E8%BD%AC%E5%AF%B9">493. 翻转对</a></h2><p>看一下力扣第 493 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-pairs/">翻转对</a>」：</p>
<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">493. 翻转对</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/reverse-pairs/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/reverse-pairs/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个数组&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code>&nbsp;，如果&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i &lt; j</code>&nbsp;且&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums[i] &gt; 2*nums[j]</code>&nbsp;我们就将&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(i, j)</code>&nbsp;称作一个<strong style="font-weight: 600;"><em>重要翻转对</em></strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你需要返回给定数组中的重要翻转对的数量。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>: [1,3,2,3,1]
<strong style="font-weight: 600;">输出</strong>: 2
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入</strong>: [2,4,3,5,1]
<strong style="font-weight: 600;">输出</strong>: 3
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意:</strong></p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定数组的长度不会超过<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">50000</code>。</li><li>输入数组中的所有数字都在32位整数的表示范围内。</li></ol></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/reverse-pairs/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 493. 翻转对</a>。</strong></details>

<p>我把这道题换个表述方式，你注意和上一道题目对比：</p>
<p>请你先求出一个 <code>count</code> 数组，其中：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> COUNT<span class="token punctuation">(</span>j<span class="token punctuation">)</span> where j <span class="token operator">></span> i <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">2</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后请你求出这个 <code>count</code> 数组中所有元素的和。</p>
<p>你看，这样说其实和题目是一个意思，而且和上一道题非常类似，只不过上一题求的是 <code>nums[i] &gt; nums[j]</code>，这里求的是 <code>nums[i] &gt; 2*nums[j]</code> 罢了。</p>
<p>所以解题的思路当然还是要在 <code>merge</code> 函数中做点手脚，当 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 两个子数组完成排序后，对于 <code>nums[lo..mid]</code> 中的每个元素 <code>nums[i]</code>，去 <code>nums[mid+1..hi]</code> 中寻找符合条件的 <code>nums[j]</code> 就行了。</p>
<p>看一下我们对上一题 <code>merge</code> 函数的改造：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 记录「翻转对」的个数</span>
count <span class="token operator">=</span> <span class="token number">0</span>

<span class="token comment"># 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span>
<span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> count
    temp <span class="token operator">=</span> nums<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 在合并有序数组之前，加点私货</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 对于左半边的每个 nums[i]，都去右半边寻找符合条件的元素</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long</span>
            <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">int</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                count <span class="token operator">+=</span> <span class="token number">1</span>

    <span class="token comment"># 数组双指针技巧，合并两个有序数组</span>
    i<span class="token punctuation">,</span> j <span class="token operator">=</span> lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不过呢，这样修改代码会超时，毕竟额外添加了一个嵌套 for 循环。怎么进行优化呢，注意子数组 <code>nums[lo..mid]</code> 是排好序的，也就是 <code>nums[i] &lt;= nums[i+1]</code>。</p>
<p>所以，对于 <code>nums[i], lo &lt;= i &lt;= mid</code>，我们在找到的符合 <code>nums[i] &gt; 2*nums[j]</code> 的 <code>nums[j], mid+1 &lt;= j &lt;= hi</code>，也必然也符合 <code>nums[i+1] &gt; 2*nums[j]</code>。</p>
<p><strong>换句话说，我们不用每次都傻乎乎地去遍历整个 <code>nums[mid+1..hi]</code>，只要维护一个开区间边界 <code>end</code>，维护 <code>nums[mid+1..end-1]</code> 是符合条件的元素即可</strong>。</p>
<p>看最终的解法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 记录「翻转对」的个数</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># 执行归并排序</span>
        self<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count

    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 归并排序</span>
        <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>
            <span class="token keyword">return</span>

        mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        
        <span class="token comment"># 维护左闭右开区间 [mid+1, end) 中的元素乘 2 小于 nums[i]</span>
        <span class="token comment"># 为什么 end 是开区间？因为这样的话可以保证初始区间 [mid+1, mid+1) 是一个空区间</span>
        end <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long</span>
            <span class="token keyword">while</span> end <span class="token operator">&lt;=</span> hi <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">:</span>
                end <span class="token operator">+=</span> <span class="token number">1</span>

            self<span class="token punctuation">.</span>count <span class="token operator">+=</span> end <span class="token operator">-</span> <span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

        <span class="token comment"># 数组双指针技巧，合并两个有序数组</span>
        i<span class="token punctuation">,</span> j <span class="token operator">=</span> lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> j <span class="token operator">==</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327. 区间和的个数"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/#_327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0">327. 区间和的个数</a></h2><p>如果你能够理解这道题目，我们最后来看一道难度更大的题目，力扣第 327 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-range-sum/">区间和的个数</a>」：</p>
<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem; color: rgb(60, 60, 67); font-family: Inter, ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">327. 区间和的个数</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/count-of-range-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/count-of-range-sum/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>以及两个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">lower</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">upper</code><span>&nbsp;</span>。求数组中，值位于范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[lower, upper]</code><span>&nbsp;</span>（包含<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">lower</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">upper</code>）之内的<span>&nbsp;</span><strong style="font-weight: 600;">区间和的个数</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">区间和</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">S(i, j)</code><span>&nbsp;</span>表示在<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">nums</code><span>&nbsp;</span>中，位置从<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code><span>&nbsp;</span>的元素之和，包含<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code><span>&nbsp;</span>(<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">i</code><span>&nbsp;</span>≤<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">j</code>)。</p><strong style="font-weight: 600;">示例 1：</strong><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [-2,5,-1], lower = -2, upper = 2
<strong style="font-weight: 600;">输出：</strong>3
<strong style="font-weight: 600;">解释：</strong>存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>nums = [0], lower = 0, upper = 0
<strong style="font-weight: 600;">输出：</strong>1
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-2<sup>31</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup><span>&nbsp;</span>&lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li><li>题目数据保证答案是一个<span>&nbsp;</span><strong style="font-weight: 600;">32 位</strong><span>&nbsp;</span>的整数</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/count-of-range-sum/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 327. 区间和的个数</a>。</strong></details>

<p>简单说，题目让你计算元素和落在 <code>[lower, upper]</code> 中的所有子数组的个数。</p>
<p>拍脑袋的暴力解法我就不说了，依然是嵌套 for 循环，这里还是说利用归并排序实现的高效算法。</p>
<p>首先，解决这道题需要快速计算子数组的和，所以你需要阅读前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和数组技巧</a>，创建一个前缀和数组 <code>preSum</code> 来辅助我们迅速计算区间和。</p>
<p>我继续用比较数学的语言来表述下这道题，题目让你通过 <code>preSum</code> 数组求一个 <code>count</code> 数组，使得：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> COUNT<span class="token punctuation">(</span>j<span class="token punctuation">)</span> where lower <span class="token operator">&lt;=</span> preSum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> upper<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后请你求出这个 <code>count</code> 数组中所有元素的和。</p>
<p>你看，这是不是和题目描述一样？<code>preSum</code> 中的两个元素之差其实就是区间和。</p>
<p>有了之前两道题的铺垫，我直接给出这道题的解法代码吧，思路见注释：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 定义实例变量</span>
        self<span class="token punctuation">.</span>lower <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>upper <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">countRangeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> upper<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 赋值实例变量</span>
        self<span class="token punctuation">.</span>lower <span class="token operator">=</span> lower
        self<span class="token punctuation">.</span>upper <span class="token operator">=</span> upper
        
        <span class="token comment"># 构建前缀和数组，注意 int 可能溢出，用 long 存储</span>
        preSum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            
        <span class="token comment"># 对前缀和数组进行归并排序</span>
        self<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>preSum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preSum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count
        
        
    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 填充 temp 数组</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        
        <span class="token comment"># 在合并有序数组之前加点私货（这段代码会超时）</span>
        <span class="token comment"># for i in range(lo, mid + 1):</span>
        <span class="token comment">#     for j in range(mid + 1, hi + 1):</span>
        <span class="token comment"># 寻找符合条件的 nums[j]</span>
        <span class="token comment">#</span>
        <span class="token comment">#         delta = nums[j] - nums[i]</span>
        <span class="token comment">#         if delta &lt;= self.upper and delta >= self.lower:</span>
        <span class="token comment">#             self.count += 1</span>

        <span class="token comment"># 进行效率优化</span>
        <span class="token comment"># 维护左闭右开区间 [start, end) 中的元素和 nums[i] 的差在 [lower, upper] 中</span>
        start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        end <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果 nums[i] 对应的区间是 [start, end)，</span>
            <span class="token comment"># 那么 nums[i+1] 对应的区间一定会整体右移，类似滑动窗口</span>
            <span class="token keyword">while</span> start <span class="token operator">&lt;=</span> hi <span class="token keyword">and</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>lower<span class="token punctuation">:</span>
                start <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">while</span> end <span class="token operator">&lt;=</span> hi <span class="token keyword">and</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>upper<span class="token punctuation">:</span>
                end <span class="token operator">+=</span> <span class="token number">1</span>
            self<span class="token punctuation">.</span>count <span class="token operator">+=</span> end <span class="token operator">-</span> start

        <span class="token comment"># 数组双指针技巧，合并两个有序数组</span>
        i<span class="token punctuation">,</span> j <span class="token operator">=</span> lo<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> j <span class="token operator">==</span> hi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们依然在 <code>merge</code> 函数合并有序数组之前加了一些逻辑，如果看过前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口核心框架</a>，这个效率优化有点类似维护一个滑动窗口，让窗口中的元素和 <code>nums[i]</code> 的差落在 <code>[lower, upper]</code> 中。</p>
<p>归并排序相关的题目到这里就讲完了，你现在回头体会下我在本文开头说那句话：</p>
<p><strong>所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码。你要写递归算法，本质上就是要告诉每个节点需要做什么</strong>。</p>
<p>比如本文讲的归并排序算法，递归的 <code>sort</code> 函数就是二叉树的遍历函数，而 <code>merge</code> 函数就是在每个节点上做的事情，有没有品出点味道？</p>
<p>最后总结一下吧，本文从二叉树的角度讲了归并排序的核心思路和代码实现，同时讲了几道归并排序相关的算法题。这些算法题其实就是归并排序算法逻辑中夹杂一点私货，但仍然属于比较难的，你可能需要亲自做一遍才能理解。</p>
<p>那我最后留一个思考题吧，下一篇文章我会讲快速排序，你是否能够尝试着从二叉树的角度去理解快速排序？如果让你用一句话总结快速排序的逻辑，你怎么描述？</p>
<p>好了，答案在下篇文章 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/quick-sort/">快速排序详解及应用</a> 揭晓。</p>
<h1 id="拓展：快速排序详解及应用"><a href="#拓展：快速排序详解及应用" class="headerlink" title="拓展：快速排序详解及应用"></a>拓展：快速排序详解及应用</h1><p>前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序算法详解</a> 通过二叉树的视角描述了归并排序的算法原理以及应用，很多读者大呼精妙，那我就趁热打铁，<strong>今天继续用二叉树的视角讲一讲快速排序算法的原理以及运用</strong>。</p>
<h2 id="快速排序算法思路"><a href="#快速排序算法思路" class="headerlink" title="快速排序算法思路"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">快速排序算法思路</a></h2><p>首先我们看一下快速排序的代码框架：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token comment"># ****** 前序位置 ******</span>
    <span class="token comment"># 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span>
    <span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>
    p <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    <span class="token comment"># 去左右子数组进行切分</span>
    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实你对比之后可以发现，快速排序就是一个二叉树的前序遍历：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 二叉树遍历框架</span>
<span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token comment"># 前序位置</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序详解</a> 用一句话总结了归并排序：先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。</p>
<p>同时我提了一个问题，让你一句话总结快速排序，这里说一下我的答案：</p>
<p><strong>快速排序是先将一个元素排好序，然后再将剩下的元素排好序</strong>。</p>
<p>为什么这么说呢，且听我慢慢道来。</p>
<p>快速排序的核心无疑是 <code>partition</code> 函数，<code>partition</code> 函数的作用是在 <code>nums[lo..hi]</code> 中寻找一个切分点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1-1754615459855-31.jpeg" alt="img"></p>
<p>一个元素左边的元素都比它小，右边的元素都比它大，啥意思？不就是它自己已经被放到正确的位置上了吗？</p>
<p>所以 <code>partition</code> 函数干的事情，其实就是把 <code>nums[p]</code> 这个元素排好序了。</p>
<p>一个元素被排好序了，然后呢？你再把剩下的元素排好序不就得了。</p>
<p>剩下的元素有哪些？左边一坨，右边一坨，去吧，对子数组进行递归，用 <code>partition</code> 函数把剩下的元素也排好序。</p>
<p><strong>从二叉树的视角，我们可以把子数组 <code>nums[lo..hi]</code> 理解成二叉树节点上的值，<code>sort</code> 函数理解成二叉树的遍历函数</strong>。</p>
<p>参照二叉树的前序遍历顺序，快速排序的运行过程如下 GIF：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/1.gif" alt="img"></p>
<p>你注意最后形成的这棵二叉树是什么？是一棵二叉搜索树：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/2-1754615478099-34.jpeg" alt="img"></p>
<p>这应该不难理解吧，因为 <code>partition</code> 函数每次都将数组切分成左小右大两部分，恰好和二叉搜索树左小右大的特性吻合。</p>
<p><strong>你甚至可以这样理解：快速排序的过程是一个构造二叉搜索树的过程</strong>。</p>
<p>但谈到二叉搜索树的构造，那就不得不说二叉搜索树不平衡的极端情况，极端情况下二叉搜索树会退化成一个链表，导致操作效率大幅降低。</p>
<p>快速排序的过程中也有类似的情况，比如我画的图中每次 <code>partition</code> 函数选出的切分点都能把 <code>nums[lo..hi]</code> 平分成两半，但现实中你不见得运气这么好。</p>
<p>如果你每次运气都特别背，有一边的元素特别少的话，这样会导致二叉树生长不平衡：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/3-1754615478099-35.jpeg" alt="img"></p>
<p>这样的话，时间复杂度会大幅上升，后面分析时间复杂度的时候再细说。</p>
<p><strong>我们为了避免出现这种极端情况，需要引入随机性</strong>。</p>
<p>常见的方式是在进行排序之前对整个数组执行 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/frequency-interview/random-algorithm/">洗牌算法</a> 进行打乱，或者在 <code>partition</code> 函数中随机选择数组元素作为切分点，本文会使用前者。</p>
<h2 id="快速排序代码实现"><a href="#快速排序代码实现" class="headerlink" title="快速排序代码实现"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">快速排序代码实现</a></h2><p>明白了上述概念，直接看快速排序的代码实现：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random

<span class="token keyword">class</span> <span class="token class-name">Quick</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 为了避免出现耗时的极端情况，先随机打乱</span>
        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token comment"># 排序整个数组（原地修改）</span>
        Quick<span class="token punctuation">.</span>sort_<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">sort_</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> lo <span class="token operator">>=</span> hi<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        <span class="token comment"># 对 nums[lo..hi] 进行切分</span>
        <span class="token comment"># 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span>
        p <span class="token operator">=</span> Quick<span class="token punctuation">.</span>partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

        Quick<span class="token punctuation">.</span>sort_<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        Quick<span class="token punctuation">.</span>sort_<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
    
    <span class="token comment"># 对 nums[lo..hi] 进行切分</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>
        <span class="token comment"># 关于区间的边界控制需格外小心，稍有不慎就会出错</span>
        <span class="token comment"># 我这里把 i, j 定义为开区间，同时定义：</span>
        <span class="token comment"># [lo, i) &lt;= pivot；(j, hi] > pivot</span>
        <span class="token comment"># 之后都要正确维护这个边界区间的定义</span>
        i<span class="token punctuation">,</span> j <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi
        <span class="token comment"># 当 i > j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> j<span class="token punctuation">:</span>
            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> hi <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token comment"># 此 while 结束时恰好 nums[i] > pivot</span>
            <span class="token keyword">while</span> j <span class="token operator">></span> lo <span class="token keyword">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">:</span>
                j <span class="token operator">-=</span> <span class="token number">1</span>
                <span class="token comment"># 此 while 结束时恰好 nums[j] &lt;= pivot</span>

            <span class="token keyword">if</span> i <span class="token operator">>=</span> j<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token comment"># 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] > pivot</span>
            <span class="token comment"># 交换 nums[j] 和 nums[i]</span>
            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token comment"># 此时 [lo, i] &lt;= pivot &amp;&amp; [j, hi] > pivot</span>
        <span class="token comment"># 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span>
        nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>
        <span class="token keyword">return</span> j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里啰嗦一下核心函数 <code>partition</code> 的实现，正如前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索框架详解</a> 所说，想要正确寻找切分点非常考验你对边界条件的控制，稍有差错就会产生错误的结果。</p>
<p><strong>处理边界细节的一个技巧就是，你要明确每个变量的定义以及区间的开闭情况</strong>。具体的细节看代码注释，建议自己动手实践。</p>
<p>贴一个快速排序过程的可视化动画，方便大家理解算法运行的过程：</p>
<details data-v-ee1a9bd0="" id="div_quick-sort" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 780px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_quick-sort" src="https://labuladong.online/algo-visualize/tutorial/quick-sort/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

<h2 id="复杂度分析及其他要点"><a href="#复杂度分析及其他要点" class="headerlink" title="复杂度分析及其他要点"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BB%96%E8%A6%81%E7%82%B9">复杂度分析及其他要点</a></h2><p>接下来分析一下快速排序的时间复杂度。</p>
<p>显然，快速排序的时间复杂度主要消耗在 <code>partition</code> 函数上，因为这个函数中存在循环。</p>
<p>所以 <code>partition</code> 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？</p>
<p>和归并排序类似，需要结合之前画的这幅图来从整体上分析：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/4.jpeg" alt="img"></p>
<p><strong><code>partition</code> 执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组 <code>nums[lo..hi]</code> 的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数</strong>。</p>
<p>假设数组元素个数为 <code>N</code>，那么二叉树每一层的元素个数之和就是 O(N)；切分点 <code>p</code> 每次都落在数组正中间的理想情况下，树的层数为 O(logN)，所以理想的总时间复杂度为 O(NlogN)。</p>
<p>由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 O(logN)。</p>
<p>当然，我们之前说过快速排序的效率存在一定随机性，如果每次 <code>partition</code> 切分的结果都极不均匀：</p>
<p><img src="/2025/08/08/er-cha-shu-de-tuo-zhan/3-1754615478099-35.jpeg" alt="img"></p>
<p>快速排序就退化成选择排序了，树高为 O(N)，每层节点的元素个数从 <code>N</code> 开始递减，总的时间复杂度为：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">N <span class="token operator">+</span> <span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> O<span class="token punctuation">(</span>N<span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>所以我们说，快速排序理想情况的时间复杂度是 O(NlogN)，空间复杂度 O(logN)，极端情况下的最坏时间复杂度是 O(N2)，空间复杂度是 O(N)。</p>
<p>不过大家放心，经过随机化的 <code>partition</code> 函数很难出现极端情况，所以快速排序的效率还是非常高的。</p>
<p><strong>还有一点需要注意的是，快速排序是「不稳定排序」，与之相对的，前文讲的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序</a> 是「稳定排序」</strong>。</p>
<p>对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。</p>
<p>如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定排序就有更大的优势了。</p>
<p>比如说你有若干订单数据，已经按照订单号排好序了，现在你想对订单的交易日期再进行排序：</p>
<p>如果用稳定排序算法（比如归并排序），那么这些订单不仅按照交易日期排好了序，而且相同交易日期的订单的订单号依然是有序的。</p>
<p>但如果你用不稳定排序算法（比如快速排序），那么虽然排序结果会按照交易日期排好序，但相同交易日期的订单的订单号会丧失有序性。</p>
<p><strong>在实际工程中我们经常会将一个复杂对象的某一个字段作为排序的 <code>key</code>，所以应该关注编程语言提供的 API 底层使用的到底是什么排序算法，是稳定的还是不稳定的，这很可能影响到代码执行的效率甚至正确性</strong>。</p>
<p>说了这么多，快速排序算法应该算是讲明白了，力扣第 912 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">排序数组</a>」就是让你对数组进行排序，我们可以直接套用快速排序的代码模板：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment"># 归并排序对数组进行原地排序</span>
        Quick<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">return</span> nums

<span class="token keyword">class</span> <span class="token class-name">Quick</span><span class="token punctuation">:</span>
    <span class="token comment"># 见上文</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a><a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95">快速选择算法</a></h2><p>快速排序算法还有一些有趣的变体，比如快速选择算法（Quick Select），主要场景是寻找第 k<em>k</em> 大的元素或者求中位数（k&#x3D;N&#x2F;2<em>k</em>&#x3D;<em>N</em>&#x2F;2）。</p>
<p>力扣第 215 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中的第 K 个最大元素</a>」就是一道类似的题目，函数签名如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>题目要求我们寻找<strong>第 <code>k</code> 个最大的元素</strong>，稍微有点绕，意思是去寻找 <code>nums</code> 数组降序排列后排名第 <code>k</code> 的那个元素。</p>
<p>比如输入 <code>nums = [2,1,5,4], k = 2</code>，算法应该返回 4，因为 4 是 <code>nums</code> 中第 2 个<strong>最大</strong>的元素。</p>
<p>这种问题有两种解法，一种是 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure-basic/binary-heap-basic/">二叉堆（优先队列）</a> 的解法，另一种就是快速选择算法，我们分别来看。</p>
<p><strong>二叉堆的解法比较简单，但时间复杂度稍高</strong>，直接看代码好了：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> heapq
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 小顶堆，堆顶是最小元素</span>
        pq <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> e <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            <span class="token comment"># 每个元素都要过一遍二叉堆</span>
            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>pq<span class="token punctuation">,</span> e<span class="token punctuation">)</span>
            <span class="token comment"># 堆中元素多于 k 个时，删除堆顶元素</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">:</span>
                heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>pq<span class="token punctuation">)</span>
        <span class="token comment"># pq 中剩下的是 nums 中 k 个最大元素，</span>
        <span class="token comment"># 堆顶是最小的那个，即第 k 个最大元素</span>
        <span class="token keyword">return</span> pq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>二叉堆（优先队列）是一种能够自动排序的数据结构，我们前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure-basic/binary-heap-implement/">手把手实现二叉堆数据结构</a> 实现过这种结构，我就默认大家熟悉它的特性了。</p>
<p>核心思路就是把小顶堆 <code>pq</code> 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 <code>k</code> 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 <code>k</code> 个最大元素嘛。</p>
<p>当 <code>nums</code> 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 <code>k</code> 个元素，而堆顶元素是堆中最小的元素，也就是「第 <code>k</code> 个最大的元素」。</p>
<p>思路很简单吧，唯一注意的是，Java 的 <code>PriorityQueue</code> 默认实现是小顶堆，有的语言的优先队列可能默认是大顶堆，可能需要做一些调整。</p>
<p>二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 <code>k</code>，所以插入和删除元素的复杂度是 O(logk)，再套一层 for 循环，假设数组元素总数为 <code>N</code>，总的时间复杂度就是 O(Nlogk)。</p>
<p>这个解法的空间复杂度很显然就是二叉堆的大小，为 O(k)。</p>
<p><strong>快速选择算法是快速排序的变体，效率更高</strong>，面试中如果能够写出快速选择算法，肯定是加分项。</p>
<p>首先，题目问「第 <code>k</code> 个最大的元素」，相当于数组升序排序后「排名第 <code>n - k</code> 的元素」，为了方便表述，后文另 <code>k&#39; = n - k</code>。</p>
<p>如何知道「排名第 <code>k&#39;</code> 的元素」呢？其实在快速排序算法 <code>partition</code> 函数执行的过程中就可以略见一二。</p>
<p>我们刚说了，<code>partition</code> 函数会将 <code>nums[p]</code> 排到正确的位置，使得 <code>nums[lo..p-1] &lt; nums[p] &lt; nums[p+1..hi]</code>：</p>
<p>这时候，虽然还没有把整个数组排好序，但我们已经让 <code>nums[p]</code> 左边的元素都比 <code>nums[p]</code> 小了，也就知道 <code>nums[p]</code> 的排名了。</p>
<p><strong>那么我们可以把 <code>p</code> 和 <code>k&#39;</code> 进行比较，如果 <code>p &lt; k&#39;</code> 说明第 <code>k&#39;</code> 大的元素在 <code>nums[p+1..hi]</code> 中，如果 <code>p &gt; k&#39;</code> 说明第 <code>k&#39;</code> 大的元素在 <code>nums[lo..p-1]</code> 中</strong>。</p>
<p>进一步，去 <code>nums[p+1..hi]</code> 或者 <code>nums[lo..p-1]</code> 这两个子数组中执行 <code>partition</code> 函数，就可以进一步缩小排在第 <code>k&#39;</code> 的元素的范围，最终找到目标元素。</p>
<p>这样就可以写出解法代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># 首先随机打乱数组</span>
        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        lo<span class="token punctuation">,</span> hi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token comment"># 转化成「排名第 k 的元素」</span>
        k <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k
        <span class="token keyword">while</span> lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">:</span>
            <span class="token comment"># 在 nums[lo..hi] 中选一个切分点</span>
            p <span class="token operator">=</span> self<span class="token punctuation">.</span>partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
            <span class="token keyword">if</span> p <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>
                <span class="token comment"># 第 k 大的元素在 nums[p+1..hi] 中</span>
                lo <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> p <span class="token operator">></span> k<span class="token punctuation">:</span>
                <span class="token comment"># 第 k 大的元素在 nums[lo..p-1] 中</span>
                hi <span class="token operator">=</span> p <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 找到第 k 大元素</span>
                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>

    <span class="token comment"># 对 nums[lo..hi] 进行切分</span>
    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> hi<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># 见前文</span>
        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个代码框架其实非常像我们前文 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索框架</a> 的代码，这也是这个算法高效的原因，但是时间复杂度为什么是 O(N) 呢？</p>
<p>显然，这个算法的时间复杂度也主要集中在 <code>partition</code> 函数上，我们需要估算 <code>partition</code> 函数执行了多少次，每次执行的时间复杂度是多少。</p>
<p>最好情况下，每次 <code>partition</code> 函数切分出的 <code>p</code> 都恰好是正中间索引 <code>(lo + hi) / 2</code>（二分），且每次切分之后会到左边或者右边的子数组继续进行切分，那么 <code>partition</code> 函数执行的次数是 logN，每次输入的数组大小缩短一半。</p>
<p>所以总的时间复杂度为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 等比数列</span>
<span class="token class-name">N</span> <span class="token operator">+</span> <span class="token class-name">N</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token class-name">N</span><span class="token operator">/</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token class-name">N</span><span class="token operator">/</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span>N <span class="token operator">=</span> <span class="token class-name">O</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当然，类似快速排序，快速选择算法中的 <code>partition</code> 函数也可能出现极端情况，最坏情况下 <code>p</code> 一直都是 <code>lo + 1</code> 或者一直都是 <code>hi - 1</code>，这样的话时间复杂度就退化为 O(N2)了：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">N</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token class-name">O</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这也是我们在代码中使用 <code>shuffle</code> 函数的原因，通过引入随机性来避免极端情况的出现，让算法的效率保持在比较高的水平。随机化之后的快速选择算法的复杂度可以认为是 O(N)。</p>
<p>到这里，快速排序算法和快速选择算法就讲完了，从二叉树的视角来理解思路应该是不难的，但 <code>partition</code> 函数对细节的把控需要你多花心思去理解和记忆。</p>
<p>最后你可以比较一下快速排序和前文讲的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序</a> 并且可以说说你的理解：为什么快速排序是不稳定排序，而归并排序是稳定排序？</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Mealsee</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://maelsee.github.io/2025/08/08/er-cha-shu-de-tuo-zhan/">https://maelsee.github.io/2025/08/08/er-cha-shu-de-tuo-zhan/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Mealsee</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%AE%9E%E8%B7%B5/">
                                    <span class="chip bg-color">实践</span>
                                </a>
                            
                                <a href="/tags/LeetCode/">
                                    <span class="chip bg-color">LeetCode</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/08/08/jing-dian-tu-suan-fa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="经典图算法">
                        
                        <span class="card-title">经典图算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-08-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%9B%BE%E7%AE%97%E6%B3%95/" class="post-category">
                                    图算法
                                </a>
                            
                            <a href="/categories/%E5%9B%BE%E7%AE%97%E6%B3%95/Algorithm/" class="post-category">
                                    算法
                                </a>
                            
                            <a href="/categories/%E5%9B%BE%E7%AE%97%E6%B3%95/Algorithm/Data-Structure/" class="post-category">
                                    数据结构
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AE%9E%E8%B7%B5/">
                        <span class="chip bg-color">实践</span>
                    </a>
                    
                    <a href="/tags/LeetCode/">
                        <span class="chip bg-color">LeetCode</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/08/03/er-cha-shu-suan-fa-xi-ti/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="二叉树算法习题">
                        
                        <span class="card-title">二叉树算法习题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-08-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/" class="post-category">
                                    二叉树算法
                                </a>
                            
                            <a href="/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/Algorithm/" class="post-category">
                                    算法
                                </a>
                            
                            <a href="/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/Algorithm/Data-Structure/" class="post-category">
                                    数据结构
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AE%9E%E8%B7%B5/">
                        <span class="chip bg-color">实践</span>
                    </a>
                    
                    <a href="/tags/LeetCode/">
                        <span class="chip bg-color">LeetCode</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">Mealsee</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>

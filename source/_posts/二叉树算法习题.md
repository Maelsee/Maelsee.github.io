---
title: 二叉树算法习题
typora-root-url: 二叉树算法习题
mathjax: true
date: 2025-08-03 14:02:25
tags:
    - 实践
    - LeetCode
categories: 
  - 二叉树算法
  - 算法
  - 数据结构
---

# 【练习】用「遍历」思维解题 I

一般来说，如果让你在二叉树的「树枝」上做文章，那么用遍历的思维模式解题是比较自然的想法。

## [257. 二叉树的所有路径](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_binary-tree-paths)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">257. 二叉树的所有路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-paths/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>，返回所有从根节点到叶子节点的路径。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶子节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p>&nbsp;<p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/03/12/paths-tree.jpg" style="max-width: 100%; width: 207px; height: 293px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,5]
<strong style="font-weight: 600;">输出：</strong>["1-&gt;2-&gt;5","1-&gt;3"]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]
<strong style="font-weight: 600;">输出：</strong>["1"]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 100]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-paths/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 257. 二叉树的所有路径</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#基本思路)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

你让我求所有根节点到叶子节点的路径，那我遍历一遍二叉树肯定可以搞定，遍历到叶子节点的时候想办法把路径生成出来就行了。

**详细题解**：

- [【练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#解法代码)

```python
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        # 遍历一遍二叉树就能出结果了
        self.traverse(root)
        return self.res

    def __init__(self):
        # 记录 traverse 函数递归时的路径
        self.path = []
        # 记录所有从根节点到叶子节点的路径
        self.res = []

    def traverse(self, root: TreeNode):
        if root is None:
            return
        # root 是叶子节点
        if root.left is None and root.right is None:
            self.path.append(str(root.val))
            # 将这条路径装入 res
            self.res.append("->".join(self.path))
            self.path.pop()
            return
        # 前序遍历位置
        self.path.append(str(root.val))
        # 递归遍历左右子树
        self.traverse(root.left)
        self.traverse(root.right)
        # 后序遍历位置
        self.path.pop()
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#可视化)

<details data-v-ee1a9bd0="" id="div_binary-tree-paths" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-paths" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-paths/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [129. 求根节点到叶节点数字之和](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_sum-root-to-leaf-numbers)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">129. 求根节点到叶节点数字之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div>给你一个二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，树中每个节点都存放有一个<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">9</code><span>&nbsp;</span>之间的数字。<div class="original__bRMd"><div><p style="line-height: 1.6; overflow-wrap: break-word;">每条从根节点到叶节点的路径都代表一个数字：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，从根节点到叶节点的路径<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 -&gt; 2 -&gt; 3</code><span>&nbsp;</span>表示数字<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">123</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">计算从根节点到叶节点生成的<span>&nbsp;</span><strong style="font-weight: 600;">所有数字之和</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">叶节点</strong><span>&nbsp;</span>是指没有子节点的节点。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/num1tree.jpg" style="max-width: 100%; width: 212px; height: 182px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3]
<strong style="font-weight: 600;">输出：</strong>25
<strong style="font-weight: 600;">解释：</strong>
从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1-&gt;2</code> 代表数字 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">12</code>
从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1-&gt;3</code> 代表数字 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">13</code>
因此，数字总和 = 12 + 13 = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">25</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/19/num2tree.jpg" style="max-width: 100%; width: 292px; height: 302px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [4,9,0,5,1]
<strong style="font-weight: 600;">输出：</strong>1026
<strong style="font-weight: 600;">解释：</strong>
从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;9-&gt;5</code> 代表数字 495
从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;9-&gt;1</code> 代表数字 491
从根到叶子节点路径 <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">4-&gt;0</code> 代表数字 40
因此，数字总和 = 495 + 491 + 40 = <code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; padding: 0px; border-radius: 0px;">1026</code>
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10</code></li></ul></div></div></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 129. 求根节点到叶节点数字之和</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#基本思路-1)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

你想，让我获取所有路径数字之和，那我递归遍历一遍二叉树，沿路记录下来路径上的数字，到叶子节点的时候求和，不就完事了？

**详细题解**：

- [【练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#解法代码-1)

```python
class Solution:
    def __init__(self):
        self.path = ""
        self.res = 0

    def sumNumbers(self, root: TreeNode) -> int:
        # 遍历一遍二叉树就能出结果
        self.traverse(root)
        return self.res

    # 二叉树遍历函数
    def traverse(self, root):
        if root is None:
            return
        # 前序遍历位置，记录节点值
        self.path += str(root.val)
        if root.left is None and root.right is None:
            # 到达叶子节点，累加路径和
            self.res += int(self.path)
        # 二叉树递归框架，遍历左右子树
        self.traverse(root.left)
        self.traverse(root.right)

        # 后续遍历位置，撤销节点值
        self.path = self.path[:-1]
```

**类似题目**：

- [剑指 Offer II 049. 从根节点到叶节点的路径数字之和 🟠](https://leetcode.cn/problems/3Etpl5)

## [199. 二叉树的右视图](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_binary-tree-right-side-view)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">199. 二叉树的右视图</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/binary-tree-right-side-view/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">根节点</strong><span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/02/14/tree.jpg" style="max-width: 100%; width: 270px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> [1,2,3,null,5,null,4]
<strong style="font-weight: 600;">输出:</strong> [1,3,4]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> [1,null,3]
<strong style="font-weight: 600;">输出:</strong> [1,3]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> []
<strong style="font-weight: 600;">输出:</strong> []
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点个数的范围是<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0,100]</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 199. 二叉树的右视图</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#基本思路-2)

这题有两个思路：

1、用 BFS 层序遍历算法，每一层的最后一个节点就是二叉树的右侧视图。我们可以把 BFS 反过来，从右往左遍历每一行，进一步提升效率。

2、用 DFS 递归遍历算法，同样需要反过来，先递归 `root.right` 再递归 `root.left`，同时用 `res` 记录每一层的最右侧节点作为右侧视图。

**详细题解**：

- [【练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#解法代码-2)

```python
from collections import deque

class Solution:
    # BFS 层序遍历解法
    def rightSideView(self, root) -> list:
        res = []
        if root is None:
            return res
        # BFS 层序遍历，计算右侧视图
        q = deque([root])
        # while 循环控制从上向下一层层遍历
        while q:
            sz = len(q)
            # 每一层头部就是最右侧的元素
            last = q[0]
            for i in range(sz):
                cur = q.popleft()
                # 控制每一层从右向左遍历
                if cur.right:
                    q.append(cur.right)
                if cur.left:
                    q.append(cur.left)
            # 每一层的最后一个节点就是二叉树的右侧视图
            res.append(last.val)
        return res

    # DFS 递归遍历解法
    def rightSideView_DFS(self, root) -> list:
        self.res = []
        # 记录递归的层数
        self.depth = 0
        self.traverse(root)
        return self.res

    # 二叉树遍历函数
    def traverse(self, root):
        if root is None:
            return
        # 前序遍历位置
        self.depth += 1
        if len(self.res) < self.depth:
            # 这一层还没有记录值
            # 说明 root 就是右侧视图的第一个节点
            self.res.append(root.val)
        # 注意，这里反过来，先遍历右子树再遍历左子树
        # 这样首先遍历的一定是右侧节点
        self.traverse(root.right)
        self.traverse(root.left)
        # 后序遍历位置
        self.depth -= 1
# 从左到右正常遍历
class Solution:
    def __init__(self):
        self.res = []

    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        self.bfs(root)
        return self.res

    def bfs(self, root: Optional[TreeNode]):
        if root is None:
            return
        q = [root]
        while q:
            sz = len(q)
            self.res.append(q[-1].val)
            for _ in range(sz):
                cur = q.pop(0)  # 移除并返回第一个元素
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#可视化-1)

<details data-v-ee1a9bd0="" id="div_binary-tree-right-side-view" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_binary-tree-right-side-view" src="https://labuladong.online/algo-visualize/leetcode/binary-tree-right-side-view/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

**类似题目**：

- [662. 二叉树最大宽度 🟠](https://leetcode.cn/problems/maximum-width-of-binary-tree)
- [剑指 Offer II 046. 二叉树的右侧视图 🟠](https://leetcode.cn/problems/WNC0Lk)

## [988. 从叶结点开始的最小字符串](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_smallest-string-starting-from-leaf)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">988. 从叶结点开始的最小字符串</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一颗根结点为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，树中的每一个结点都有一个&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[0, 25]</code>&nbsp;范围内的值，分别代表字母&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'a'</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">'z'</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回<span>&nbsp;</span><em><strong style="font-weight: 600;">按字典序最小</strong><span>&nbsp;</span>的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束</em>。</p><blockquote style="margin: 1rem 0px; padding-block: 0.25rem; padding-inline: 1rem 0px; border-inline-start: 3px solid rgb(184, 184, 186); color: rgba(60, 60, 67, 0.78); font-size: 1rem; overflow-wrap: break-word; transition: border-color 0.3s, color 0.3s;"><p style="line-height: 1.6; overflow-wrap: break-word; margin: inherit;">注<strong style="font-weight: 600;">：</strong>字符串中任何较短的前缀在<span>&nbsp;</span><strong style="font-weight: 600;">字典序上</strong><span>&nbsp;</span>都是<span>&nbsp;</span><strong style="font-weight: 600;">较小</strong><span>&nbsp;</span>的：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，在字典序上&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"ab"</code><span>&nbsp;</span>比&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">"aba"</code>&nbsp;要小。叶结点是指没有子结点的结点。&nbsp;</li></ul></blockquote><p style="line-height: 1.6; overflow-wrap: break-word;">节点的叶节点是没有子节点的节点。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/02/tree1.png" style="max-width: 100%; height: 358px; width: 534px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0,1,2,3,4,3,4]
<strong style="font-weight: 600;">输出：</strong>"dba"
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/01/30/tree2.png" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [25,1,3,1,3,0,2]
<strong style="font-weight: 600;">输出：</strong>"adz"
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2019/02/01/tree3.png" style="max-width: 100%; height: 513px; width: 490px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,2,1,null,1,0,null,0]
<strong style="font-weight: 600;">输出：</strong>"abc"
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定树的结点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 8500]</code><span>&nbsp;</span>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 25</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 988. 从叶结点开始的最小字符串</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#基本思路-3)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

代码看起来虽然多，但思路非常简单：用 `path` 维护递归遍历的路径，到达叶子节点的时候判断字典序最小的路径。

不要忘了在叶子节点的时候也要正确维护 `path` 变量，而且要把 StringBuilder 中的字符串反转才是题目想要的答案。

**详细题解**：

- [【练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#解法代码-3)

```python
class Solution:
    def smallestFromLeaf(self, root: TreeNode) -> str:
        self.traverse(root)
        return self.res
    
    # 遍历过程中的路径
    path = ""
    res = None

    # 二叉树遍历函数
    def traverse(self, root):
        if root is None:
            return
        if root.left is None and root.right is None:
            # 找到叶子结点，比较字典序最小的路径
            # 结果字符串是从叶子向根，所以需要反转
            self.path = chr(ord('a') + root.val) + self.path

            s = self.path
            if self.res is None or self.res > s:
                # 如果字典序更小，则更新 res
                self.res = s

            # 恢复，正确维护 path 中的元素
            self.path = self.path[1:]
            return
        # 前序位置
        self.path = chr(ord('a') + root.val) + self.path

        self.traverse(root.left)
        self.traverse(root.right)

        # 后序位置
        self.path = self.path[1:]
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#可视化-2)

<details data-v-ee1a9bd0="" id="div_smallest-string-starting-from-leaf" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_smallest-string-starting-from-leaf" src="https://labuladong.online/algo-visualize/leetcode/smallest-string-starting-from-leaf/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [1022. 从根到叶的二进制数之和](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_sum-of-root-to-leaf-binary-numbers)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1022. 从根到叶的二进制数之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给出一棵二叉树，其上每个结点的值都是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code>&nbsp;或&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，如果路径为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">01101</code>，也就是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">13</code>&nbsp;。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回这些数字之和。题目数据保证答案是一个<span>&nbsp;</span><strong style="font-weight: 600;">32 位<span>&nbsp;</span></strong>整数。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" style="max-width: 100%;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,0,1,0,1,0,1]
<strong style="font-weight: 600;">输出：</strong>22
<strong style="font-weight: 600;">解释：</strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [0]
<strong style="font-weight: 600;">输出：</strong>0
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">Node.val</code>&nbsp;仅为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1022. 从根到叶的二进制数之和</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#基本思路-4)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

用 `path` 变量维护每一条从根节点到叶子节点的路径形成的二进制数，到了叶子节点之后将这条路径的二进制数累加到 `res` 中即可。

**详细题解**：

- [【练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#解法代码-4)

```python
class Solution:
    def sumRootToLeaf(self, root: TreeNode) -> int:
        self.path = 0
        self.res = 0
        self.traverse(root)
        return self.res

    def traverse(self, root: TreeNode):
        if root is None:
            return
        if root.left is None and root.right is None:
            # 叶子节点
            self.res += self.path << 1 | root.val
            return
        # 前序位置
        self.path = self.path << 1 | root.val
        self.traverse(root.left)
        self.traverse(root.right)
        # 后序位置
        self.path = self.path >> 1
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#可视化-3)

<details data-v-ee1a9bd0="" id="div_sum-of-root-to-leaf-binary-numbers" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-root-to-leaf-binary-numbers" src="https://labuladong.online/algo-visualize/leetcode/sum-of-root-to-leaf-binary-numbers/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [1457. 二叉树中的伪回文路径](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#slug_pseudo-palindromic-paths-in-a-binary-tree)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1457. 二叉树中的伪回文路径</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong style="font-weight: 600;">伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回从根到叶子节点的所有路径中&nbsp;<strong style="font-weight: 600;">伪回文&nbsp;</strong>路径的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png" style="max-width: 100%; height: 201px; width: 300px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,3,1,3,1,null,1]
<strong style="font-weight: 600;">输出：</strong>2 
<strong style="font-weight: 600;">解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。
     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png" style="max-width: 100%; height: 314px; width: 300px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]
<strong style="font-weight: 600;">输出：</strong>1 
<strong style="font-weight: 600;">解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。
     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [9]
<strong style="font-weight: 600;">输出：</strong>1
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定二叉树的节点数目在范围&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>5</sup>]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val &lt;= 9</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1457. 二叉树中的伪回文路径</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#基本思路-5)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

遍历一遍二叉树就能得到每条路径上的数字，但这题的考点在于，如何判断一组数字是否存在一个回文串组合？

稍加思考不难想到：**如果一组数字中，只有最多一个数字出现的次数为奇数，剩余数字的出现次数均为偶数，那么这组数字可以组成一个回文串**。

题目说了 `1 <= root.val <= 9`，所以我们可以用一个大小为 10 的 `count` 数组做计数器来记录每条路径上的元素出现次数，到达叶子节点之后根据元素出现的次数判断是否可以构成回文串。

当然，我们也可以用更巧妙的位运算来实现上述逻辑：

1、首先用到异或运算的特性，1 ^ 1 = 0, 0 ^ 0 = 0, 1 ^ 0 = 1。

2、其次用到 `n & (n - 1)` 去除二进制最后一个 1 的技巧，详见 [东哥教你几招常用的位运算技巧](https://labuladong.online/algo/frequency-interview/bitwise-operation/)。

我同时实现了这两种方法，供你参考。

**详细题解**：

- [【练习】用「遍历」思维解题 I](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#解法代码-5)

```python
class Solution:
    def __init__(self):
        self.count = [0] * 10
        self.res = 0

    def pseudoPalindromicPaths(self, root: TreeNode) -> int:
        self.traverse(root)
        return self.res

    # 二叉树遍历函数
    def traverse(self, root: TreeNode):
        if root is None:
            return
        if root.left is None and root.right is None:
            # 遇到叶子节点，判断路径是否是伪回文串
            self.count[root.val] += 1
            # 如果路径上出现奇数次的数字个数大于 1，
            # 则不可能组成回文串，反之则可以组成回文串
            odd = 0
            for n in self.count:
                if n % 2 == 1:
                    odd += 1
            if odd <= 1:
                self.res += 1
            self.count[root.val] -= 1
            return

        self.count[root.val] += 1
        # 二叉树遍历框架
        self.traverse(root.left)
        self.traverse(root.right)

        self.count[root.val] -= 1

# 用位运算代替数组计数，进一步提升效率
class Solution2:
    def __init__(self):
        self.count = 0
        self.res = 0

    def pseudoPalindromicPaths(self, root: TreeNode) -> int:
        self.traverse(root)
        return self.res

    # 二叉树遍历函数
    def traverse(self, root: TreeNode):
        if root is None:
            return
        if root.left is None and root.right is None:
            # 遇到叶子节点，判断路径是否是伪回文串
            self.count ^= (1 << root.val)
            # 判断二进制中只有一位 1，原理见 https://labuladong.online/algo/frequency-interview/bitwise-operation/
            if (self.count & (self.count - 1)) == 0:
                self.res += 1
            self.count ^= (1 << root.val)
            return
        self.count ^= (1 << root.val)
        # 二叉树遍历框架
        self.traverse(root.left)
        self.traverse(root.right)

        self.count ^= (1 << root.val)
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-i/#可视化-4)

<details data-v-ee1a9bd0="" id="div_pseudo-palindromic-paths-in-a-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 0px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_pseudo-palindromic-paths-in-a-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/pseudo-palindromic-paths-in-a-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>



## [404. 左叶子之和](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_sum-of-left-leaves)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">404. 左叶子之和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-left-leaves/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-left-leaves/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定二叉树的根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;，返回所有左叶子之和。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/04/08/leftsum-tree.jpg" style="max-width: 100%;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [3,9,20,null,null,15,7] 
<strong style="font-weight: 600;">输出:</strong> 24 
<strong style="font-weight: 600;">解释:</strong> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2:</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [1]
<strong style="font-weight: 600;">输出:</strong> 0
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code>&nbsp;范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-1000 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-left-leaves/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 404. 左叶子之和</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

无非就是遍历一遍二叉树，然后找到那些左叶子节点，累加它们的值罢了。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码)

```python
class Solution:
    def __init__(self):
        # 记录左叶子之和
        self.sum = 0

    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.traverse(root)
        return self.sum


    # 二叉树遍历函数
    def traverse(self, root: TreeNode):
        if root is None:
            return

        if (root.left is not None and
            root.left.left is None and root.left.right is None):
            # 找到左侧的叶子节点，记录累加值
            self.sum += root.left.val

        # 递归框架
        self.traverse(root.left)
        self.traverse(root.right)
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#可视化)

<details data-v-ee1a9bd0="" id="div_sum-of-left-leaves" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-left-leaves" src="https://labuladong.online/algo-visualize/leetcode/sum-of-left-leaves/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [623. 在二叉树中增加一行](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_add-one-row-to-tree)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">623. 在二叉树中增加一行</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/add-one-row-to-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/add-one-row-to-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个二叉树的根&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;和两个整数<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>&nbsp;，在给定的深度&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>&nbsp;处添加一个值为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>的节点行。</p><p style="line-height: 1.6; overflow-wrap: break-word;">注意，根节点&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;位于深度&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">加法规则如下:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定整数&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth</code>，对于深度为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth - 1</code><span>&nbsp;</span>的每个非空树节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>，创建两个值为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val</code><span>&nbsp;</span>的树节点作为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>的左子树根和右子树根。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>原来的左子树应该是新的左子树根的左子树。</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">cur</code><span>&nbsp;</span>原来的右子树应该是新的右子树根的右子树。</li><li>如果<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth == 1<span>&nbsp;</span></code>意味着&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">depth - 1</code>&nbsp;根本没有深度，那么创建一个树节点，值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">val<span>&nbsp;</span></code>作为整个原始树的新根，而原始树就是新根的左子树。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/15/addrow-tree.jpg" style="max-width: 100%; height: 231px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2
<strong style="font-weight: 600;">输出:</strong> [4,1,1,2,null,null,6,3,1,5]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img src="https://labuladong.online/algo/images/lc/uploads/2021/03/11/add2-tree.jpg" style="max-width: 100%; height: 277px; width: 500px;"></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入:</strong> root = [4,2,null,3,1], val = 1, depth = 3
<strong style="font-weight: 600;">输出:</strong>  [4,2,null,1,1,3,null,null,1]
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>节点数在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>&nbsp;范围内</li><li>树的深度在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10<sup>4</sup>]</code>范围内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-100 &lt;= Node.val &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">-10<sup>5</sup>&nbsp;&lt;= val &lt;= 10<sup>5</sup></code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= depth &lt;= the depth of tree + 1</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/add-one-row-to-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 623. 在二叉树中增加一行</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路-1)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

用 `traverse` 函数遍历到对应行，进行插入即可。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码-1)

```python
class Solution:
    def __init__(self):
        self.targetVal = 0
        self.targetDepth = 0

    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:
        self.targetVal = val
        self.targetDepth = depth
        # 插入到第一行的话特殊对待一下
        if self.targetDepth == 1:
            newRoot = TreeNode(self.targetVal)
            newRoot.left = root
            return newRoot
        # 遍历二叉树，走到对应行进行插入
        self.traverse(root, 1)

        return root

    def traverse(self, root: TreeNode, curDepth: int):
        if root is None:
            return
        # 前序遍历
        if curDepth == self.targetDepth - 1:
            # 进行插入
            newLeft = TreeNode(self.targetVal)
            newRight = TreeNode(self.targetVal)
            newLeft.left = root.left
            newRight.right = root.right
            root.left = newLeft
            root.right = newRight
        # Recursively traverse the left and right subtree
        self.traverse(root.left, curDepth + 1)
        self.traverse(root.right, curDepth + 1)
        # 后序遍历
        # Note: The original Java code does not have any action in the post-order position,
        # but we keep the comment for consistency.
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#可视化-1)

<details data-v-ee1a9bd0="" id="div_add-one-row-to-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_add-one-row-to-tree" src="https://labuladong.online/algo-visualize/leetcode/add-one-row-to-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [971. 翻转二叉树以匹配先序遍历](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_flip-binary-tree-to-match-preorder-traversal)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">971. 翻转二叉树以匹配先序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，树中有<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个节点，每个节点都有一个不同于其他节点且处于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>之间的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">另给你一个由<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code><span>&nbsp;</span>个值组成的行程序列<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span>，表示<span>&nbsp;</span><strong style="font-weight: 600;">预期</strong><span>&nbsp;</span>的二叉树<span>&nbsp;</span><a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;"><strong style="font-weight: 600;">先序遍历</strong></a><span>&nbsp;</span>结果。</p><p style="line-height: 1.6; overflow-wrap: break-word;">通过交换节点的左右子树，可以<span>&nbsp;</span><strong style="font-weight: 600;">翻转</strong><span>&nbsp;</span>该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/02/15/fliptree.jpg" style="max-width: 100%; width: 400px; height: 187px;"><p style="line-height: 1.6; overflow-wrap: break-word;">请翻转<span>&nbsp;</span><strong style="font-weight: 600;">最少<span>&nbsp;</span></strong>的树中节点，使二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">先序遍历</strong><span>&nbsp;</span>与预期的遍历行程<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span><strong style="font-weight: 600;">相匹配</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果可以，则返回<span>&nbsp;</span><strong style="font-weight: 600;">翻转的</strong><span>&nbsp;</span>所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-1]</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-01.png" style="max-width: 100%; width: 150px; height: 205px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2], voyage = [2,1]
<strong style="font-weight: 600;">输出：</strong>[-1]
<strong style="font-weight: 600;">解释：</strong>翻转节点无法令先序遍历匹配预期行程。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-02.png" style="max-width: 100%; width: 150px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], voyage = [1,3,2]
<strong style="font-weight: 600;">输出：</strong>[1]
<strong style="font-weight: 600;">解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2019/01/02/1219-02.png" style="max-width: 100%; width: 150px; height: 142px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3], voyage = [1,2,3]
<strong style="font-weight: 600;">输出：</strong>[]
<strong style="font-weight: 600;">解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的节点数目为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">n == voyage.length</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= n &lt;= 100</code></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1 &lt;= Node.val, voyage[i] &lt;= n</code></li><li>树中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">voyage</code><span>&nbsp;</span>中的所有值<span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 971. 翻转二叉树以匹配先序遍历</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路-2)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

用 `traverse` 函数遍历整棵二叉树，对比前序遍历结果，如果节点的值对不上，就无解；如果子树对不上 `voyage`，就尝试翻转子树。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码-2)

```python
class Solution:
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        self.res = []
        self.i = 0
        self.can_flip = True
        
        def dfs(node):
            # 遍历的过程中尝试进行反转
            if not node or not self.can_flip:
                return True
            if node.val != voyage[self.i]:
                # 节点的 val 对不上，必然无解
                self.can_flip = False
                return False
            self.i += 1
            # Only flip if there's a left child and the next value in voyage doesn't match the left child's value
            if node.left and node.left.val != voyage[self.i]:
                # 前序遍历结果不对，尝试翻转左右子树
                self.res.append(node.val)
                node.left, node.right = node.right, node.left
            # 记录翻转节点
            # Note: This comment was not in the original Java code, but added to match the pattern of comments. 
            # If this was not intended, it can be removed.
            return dfs(node.left) and dfs(node.right)
        
        if dfs(root):
            return self.res
        else:
            return [-1]
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#可视化-2)

<details data-v-ee1a9bd0="" id="div_flip-binary-tree-to-match-preorder-traversal" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_flip-binary-tree-to-match-preorder-traversal" src="https://labuladong.online/algo-visualize/leetcode/flip-binary-tree-to-match-preorder-traversal/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [987. 二叉树的垂序遍历](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_vertical-order-traversal-of-a-binary-tree)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">987. 二叉树的垂序遍历</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🔴</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你二叉树的根结点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，请你设计算法计算二叉树的<em><span>&nbsp;</span></em><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;">对位于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row, col)</code>&nbsp;的每个结点而言，其左右子结点分别位于&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row + 1, col - 1)</code>&nbsp;和&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(row + 1, col + 1)</code><span>&nbsp;</span>。树的根结点位于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">(0, 0)</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回二叉树的<span>&nbsp;</span><strong style="font-weight: 600;">垂序遍历</strong><span>&nbsp;</span>序列。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 1：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree1.jpg" style="max-width: 100%; width: 431px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,9,20,null,null,15,7]
<strong style="font-weight: 600;">输出：</strong>[[9],[3,15],[20],[7]]
<strong style="font-weight: 600;">解释：</strong>
列 -1 ：只有结点 9 在此列中。
列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列  1 ：只有结点 20 在此列中。
列  2 ：只有结点 7 在此列中。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 2：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree2.jpg" style="max-width: 100%; width: 512px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,5,6,7]
<strong style="font-weight: 600;">输出：</strong>[[4],[2],[1,5,6],[3],[7]]
<strong style="font-weight: 600;">解释：</strong>
列 -2 ：只有结点 4 在此列中。
列 -1 ：只有结点 2 在此列中。
列  0 ：结点 1 、5 和 6 都在此列中。
          1 在上面，所以它出现在前面。
          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。
列  1 ：只有结点 3 在此列中。
列  2 ：只有结点 7 在此列中。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong class="example" style="font-weight: 600;">示例 3：</strong></p><img alt="" src="https://labuladong.online/algo/images/lc/uploads/2021/01/29/vtree3.jpg" style="max-width: 100%; width: 512px; height: 304px;"><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,6,5,7]
<strong style="font-weight: 600;">输出：</strong>[[4],[2],[1,5,6],[3],[7]]
<strong style="font-weight: 600;">解释：</strong>
这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。
因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中结点数目总数在范围<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 1000]</code><span>&nbsp;</span>内</li><li><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0 &lt;= Node.val &lt;= 1000</code></li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 987. 二叉树的垂序遍历</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路-3)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

看这题的难度是困难，但你别被吓住了，我们从简单的开始，如果以整棵树的根节点为坐标 `(0, 0)`，你如何打印出其他节点的坐标？

很简单，写出如下代码遍历一遍二叉树即可：

```cpp
void traverse(TreeNode root, int row, int col) {
    if (root == null) {
        return;
    }
    print(row, col);
    traverse(root.left, row + 1, col - 1);
    traverse(root.right, row + 1, col + 1);
}
```

然后就简单了，把这些坐标收集起来，依据题目要求进行排序，组装成题目要求的返回数据格式即可。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码-3)

```python
class Solution:
    # 记录每个节点和对应的坐标 (row, col)
    class Triple:
        def __init__(self, node, row, col):
            self.node = node
            self.row = row
            self.col = col

    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        # 遍历二叉树，并且为所有节点生成对应的坐标
        self.traverse(root, 0, 0)
        # 根据题意，根据坐标值对所有节点进行排序：
        # 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，
        # 如果 col 和 row 都相同，按照 node.val 从小到大排序。
        self.nodes.sort(key=lambda x: (x.col, x.row, x.node.val))
        # 将排好序的节点组装成题目要求的返回格式
        res = collections.deque()
        # 记录上一列编号，初始化一个特殊值
        preCol = float('-inf')
        for cur in self.nodes:
            if cur.col != preCol:
                # 开始记录新的一列
                res.append(collections.deque())
                preCol = cur.col
            res[-1].append(cur.node.val)

        return [list(col) for col in res]

    def __init__(self):
        self.nodes = []
        
    # 二叉树遍历函数，记录所有节点对应的坐标
    def traverse(self, root: TreeNode, row: int, col: int):
        if root is None:
            return
        # 记录坐标
        self.nodes.append(self.Triple(root, row, col))
        # 二叉树遍历框架
        self.traverse(root.left, row + 1, col - 1)
        self.traverse(root.right, row + 1, col + 1)
```

**类似题目**：

- [666. 路径总和 IV 🟠](https://leetcode.cn/problems/path-sum-iv)

## [993. 二叉树的堂兄弟节点](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_cousins-in-binary-tree)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">993. 二叉树的堂兄弟节点</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/cousins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/cousins-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟢</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在二叉树中，根节点位于深度<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>处，每个深度为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k</code><span>&nbsp;</span>的节点的子节点位于深度<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">k+1</code><span>&nbsp;</span>处。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果二叉树的两个节点深度相同，但<strong style="font-weight: 600;"><span>&nbsp;</span>父节点不同</strong><span>&nbsp;</span>，则它们是一对<em>堂兄弟节点</em>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">我们给出了具有唯一值的二叉树的根节点<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code><span>&nbsp;</span>，以及树中两个不同节点的值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">只有与值<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">x</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">y</code><span>&nbsp;</span>对应的节点是堂兄弟节点时，才返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">true</code><span>&nbsp;</span>。否则，返回<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">false</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" style="max-width: 100%; height: 160px; width: 180px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4], x = 4, y = 3
<strong style="font-weight: 600;">输出：</strong>false
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：<br><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" style="max-width: 100%; height: 160px; width: 201px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4
<strong style="font-weight: 600;">输出：</strong>true
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" style="max-width: 100%; height: 160px; width: 156px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,null,4], x = 2, y = 3
<strong style="font-weight: 600;">输出：</strong>false</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树的节点数介于<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">2</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>之间。</li><li>每个节点的值都是唯一的、范围为<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>的整数。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/cousins-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 993. 二叉树的堂兄弟节点</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路-4)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

遍历找到 x，y 的深度和父节点，对比即可。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码-4)

```python
class Solution:
    def __init__(self):
        self.parentX = None
        self.parentY = None
        self.depthX = 0
        self.depthY = 0
        self.x = 0
        self.y = 0

    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        self.x = x
        self.y = y
        self.traverse(root, 0, None)
        if self.depthX == self.depthY and self.parentX != self.parentY:
            # 判断 x，y 是否是表兄弟节点
            return True
        return False

    def traverse(self, root: TreeNode, depth: int, parent: TreeNode) -> None:
        if root is None:
            return
        if root.val == self.x:
            # 找到 x，记录它的深度和父节点
            self.parentX = parent
            self.depthX = depth
        if root.val == self.y:
            # 找到 y，记录它的深度和父节点
            self.parentY = parent
            self.depthY = depth
        self.traverse(root.left, depth + 1, root)
        self.traverse(root.right, depth + 1, root)
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#可视化-3)

<details data-v-ee1a9bd0="" id="div_cousins-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_cousins-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/cousins-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [1315. 祖父节点值为偶数的节点和](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_sum-of-nodes-with-even-valued-grandparent)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1315. 祖父节点值为偶数的节点和</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">如果不存在祖父节点值为偶数的节点，那么返回&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">0</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png" style="max-width: 100%; height: 214px; width: 350px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
<strong style="font-weight: 600;">输出：</strong>18
<strong style="font-weight: 600;">解释：</strong>图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。
</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中节点的数目在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">10^4</code>&nbsp;之间。</li><li>每个节点的值在&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">1</code><span>&nbsp;</span>到&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">100</code><span>&nbsp;</span>之间。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1315. 祖父节点值为偶数的节点和</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路-5)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维。

很简单，遍历一遍二叉树，对于节点值为偶数的节点，累加它的孙子节点的值即可。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码-5)

```python
class Solution:
    def __init__(self):
        self.sum = 0

    def sumEvenGrandparent(self, root: TreeNode) -> int:
        self.traverse(root)
        return self.sum

    # 二叉树的遍历函数
    def traverse(self, root: TreeNode):
        if root is None:
            return
        if root.val % 2 == 0:
            # 累加左子树孙子节点的值
            if root.left is not None:
                if root.left.left is not None:
                    self.sum += root.left.left.val
                if root.left.right is not None:
                    self.sum += root.left.right.val

            # 累加右子树孙子节点的值
            if root.right is not None:
                if root.right.left is not None:
                    self.sum += root.right.left.val
                if root.right.right is not None:
                    self.sum += root.right.right.val

        # 二叉树的遍历框架
        self.traverse(root.left)
        self.traverse(root.right)
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#可视化-4)

<details data-v-ee1a9bd0="" id="div_sum-of-nodes-with-even-valued-grandparent" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_sum-of-nodes-with-even-valued-grandparent" src="https://labuladong.online/algo-visualize/leetcode/sum-of-nodes-with-even-valued-grandparent/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

## [1448. 统计二叉树中好节点的数目](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#slug_count-good-nodes-in-binary-tree)

<details class="hint-container details" open="" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1.25rem 1rem; border-radius: 0.5rem;"><summary style="position: relative; margin: -1rem -1rem 0.5em; padding-block: 1em; padding-inline: 3em 1.5em; list-style: none; font-size: 16px; cursor: pointer;"><strong style="font-weight: 600;">1448. 统计二叉树中好节点的数目</strong>&nbsp;|<span>&nbsp;</span><span><a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣</a><span>&nbsp;</span>|<span>&nbsp;</span></span><span><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" rel="noopener noreferrer" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode</a><span>&nbsp;</span>|</span><span>&nbsp;</span>&nbsp;🟠</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵根为&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">root</code>&nbsp;的二叉树，请你返回二叉树中好节点的数目。</p><p style="line-height: 1.6; overflow-wrap: break-word;">「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png" style="max-width: 100%; height: 156px; width: 263px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,1,4,3,null,1,5]
<strong style="font-weight: 600;">输出：</strong>4
<strong style="font-weight: 600;">解释：</strong>图中蓝色节点为好节点。
根节点 (3) 永远是个好节点。
节点 4 -&gt; (3,4) 是路径中的最大值。
节点 5 -&gt; (3,4,5) 是路径中的最大值。
节点 3 -&gt; (3,1,3) 是路径中的最大值。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png" style="max-width: 100%; height: 161px; width: 157px;"></strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [3,3,null,4,2]
<strong style="font-weight: 600;">输出：</strong>3
<strong style="font-weight: 600;">解释：</strong>节点 2 -&gt; (3, 3, 2) 不是好节点，因为 "3" 比它大。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="text-align: left; direction: ltr; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: unset; tab-size: 4; hyphens: none; overflow: auto;"><strong style="font-weight: 600;">输入：</strong>root = [1]
<strong style="font-weight: 600;">输出：</strong>1
<strong style="font-weight: 600;">解释：</strong>根节点是好节点。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>二叉树中节点数目范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[1, 10^5]</code>&nbsp;。</li><li>每个节点权值的范围是&nbsp;<code style="font-family: ui-monospace, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; margin: 0px; padding: 3px 6px; border-radius: 4px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.14); font-size: 0.875em; overflow-wrap: break-word; transition: background-color 0.3s, color 0.3s;">[-10^4, 10^4]</code>&nbsp;。</li></ul></div><strong style="font-weight: 600; font-size: small;">题目来源：<a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/" class="" target="_blank" style="color: rgb(7, 86, 171); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣 1448. 统计二叉树中好节点的数目</a>。</strong></details>

### [基本思路](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#基本思路-6)

前文 [手把手刷二叉树总结篇](https://labuladong.online/algo/essential-technique/binary-tree-summary/) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「遍历」的思维，利用函数参数给子树传递信息。

函数参数 `pathMax` 记录从根节点到当前节点路径中的最大值，通过比较 `root.val` 和 `pathMax` 比较就可判断 `root` 节点是不是「好节点」。然后再把 `pathMax` 传递到子树中继续判断其他节点。

**详细题解**：

- [【练习】用「遍历」思维解题 II](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/)

### [解法代码](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#解法代码-6)

```python
class Solution:
    def __init__(self):
        self.count = 0

    def goodNodes(self, root: TreeNode) -> int:
        self.traverse(root, root.val)
        return self.count

    # 二叉树遍历函数，pathMax 参数记录从根节点到当前节点路径中的最大值
    def traverse(self, root: TreeNode, pathMax: int):
        if root is None:
            return
        if pathMax <= root.val:
            # 找到一个「好节点」
            self.count += 1
        # 更新路径上的最大值
        pathMax = max(pathMax, root.val)

        self.traverse(root.left, pathMax)
        self.traverse(root.right, pathMax)
```

### [可视化](https://labuladong.online/algo/problem-set/binary-tree-traverse-ii/#可视化-5)

<details data-v-ee1a9bd0="" id="div_count-good-nodes-in-binary-tree" class="hint-container details" style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(142, 150, 170, 0.1); transition: background 0.3s ease 0s, color 0.3s ease 0s; display: block; margin-block: 0.75rem; padding: 1rem 0px 0px; border-radius: 0.5rem; margin: 1.3em 0px;"><summary data-v-ee1a9bd0="" style="position: relative; margin: -1rem 0px 0px; padding-block: 1em; padding-inline: 2.3em 1.5em; list-style: none; font-size: large; cursor: pointer; display: flex; align-items: center;"><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="m4.415 18.167l7.17-7.17l1.414 1.414l-7.17 7.17z" opacity="0.3"></path><path data-v-ee1a9bd0="" fill="currentColor" d="m20 7l.94-2.06L23 4l-2.06-.94L20 1l-.94 2.06L17 4l2.06.94zM8.5 7l.94-2.06L11.5 4l-2.06-.94L8.5 1l-.94 2.06L5.5 4l2.06.94zM20 12.5l-.94 2.06l-2.06.94l2.06.94l.94 2.06l.94-2.06L23 15.5l-2.06-.94zm-2.29-3.38l-2.83-2.83c-.2-.19-.45-.29-.71-.29s-.51.1-.71.29L2.29 17.46a.996.996 0 0 0 0 1.41l2.83 2.83c.2.2.45.3.71.3s.51-.1.71-.29l11.17-11.17c.39-.39.39-1.03 0-1.42M5.83 19.59l-1.41-1.41L11.59 11L13 12.41zM14.41 11L13 9.59l1.17-1.17l1.41 1.41z"></path></svg>&nbsp;<strong data-v-ee1a9bd0="" style="font-weight: 600;">算法可视化面板</strong><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="0.9em" height="0.9em" viewBox="0 0 24 24" style="margin-left: auto; margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M20 20v1h1v-1zm-4.293-5.707a1 1 0 0 0-1.414 1.414zM19 14v6h2v-6zm1 5h-6v2h6zm.707.293l-5-5l-1.414 1.414l5 5zM4 20H3v1h1zm5.707-4.293a1 1 0 0 0-1.414-1.414zM3 14v6h2v-6zm1 7h6v-2H4zm.707-.293l5-5l-1.414-1.414l-5 5zM20 4h1V3h-1zm-5.707 4.293a1 1 0 0 0 1.414 1.414zM21 10V4h-2v6zm-1-7h-6v2h6zm-.707.293l-5 5l1.414 1.414l5-5zM4 4V3H3v1zm4.293 5.707a1 1 0 0 0 1.414-1.414zM5 10V4H3v6zM4 5h6V3H4zm-.707-.293l5 5l1.414-1.414l-5-5z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" style="margin-right: 10px;"><path data-v-ee1a9bd0="" fill="currentColor" d="M17.65 6.35a7.95 7.95 0 0 0-6.48-2.31c-3.67.37-6.69 3.35-7.1 7.02C3.52 15.91 7.27 20 12 20a7.98 7.98 0 0 0 7.21-4.56c.32-.67-.16-1.44-.9-1.44c-.37 0-.72.2-.88.53a5.994 5.994 0 0 1-6.8 3.31c-2.22-.49-4.01-2.3-4.48-4.52A6.002 6.002 0 0 1 12 6c1.66 0 3.14.69 4.22 1.78l-1.51 1.51c-.63.63-.19 1.71.7 1.71H19c.55 0 1-.45 1-1V6.41c0-.89-1.08-1.34-1.71-.71z"></path></svg><svg data-v-ee1a9bd0="" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path data-v-ee1a9bd0="" fill="currentColor" d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5m-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4zm-3-4h8v2H8z"></path></svg></summary><div data-v-ee1a9bd0="" class="resizable" style="width: 954px; max-width: 100%; height: 70vh; min-height: 500px; overflow: hidden; resize: both;"><iframe data-v-ee1a9bd0="" title="algo-visualize panel" allow="clipboard-write; fullscreen;" id="iframe_count-good-nodes-in-binary-tree" src="https://labuladong.online/algo-visualize/leetcode/count-good-nodes-in-binary-tree/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details>

